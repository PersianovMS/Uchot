#Область БИБЛИОТЕКА_ФУНКЦИЙ

#Область ОТЛАДКА

// Выполняет код и возвращает рассчитанное значение
// Параметры:
//	ТекстКодаПараметр - Строка - Выполняемый код
//	Прм - Произвольный, обычно структура - параметры, по умолчанию Неопределено
//	Результат - Произвольный - Результат, возвращаемый по умолчанию, по умолчанию Неопределено
//	РежимВычисления - Булево - 
//			* При Истина к ТекстКода применяется Вычислить
//			* При Ложь - Выполнить, а возвращается значение переменной Результат.
//			По умолчанию Ложь
//	ПрямоеОбращение - Строка, Массив - Ключи параметров, которые надо сделать доступными в ТекстКода без применения "Прм.".
//			"-В" (По умолчанию) означает, что все ключи Прм переводятся в прямой доступ.  
//	Журнал - Булево - Выполнять в попытке и ошибку записать в журнал. Не используется на клиенте.
//	ИмяПроцесса - Строка - Параметр записи журнала. Не используется на клиенте.
//	ПрефиксОшибки - Строка - Префикс, записываемый в журнал перед сообщением об ошибке. Не используется на клиенте.
//Возвращаемое значение:
//		Произвольное - то, что будет вычислено.
Функция ВыполнитьКод(
		ТекстКодаПараметр,
		Прм = Неопределено, 
		Результат = Неопределено,
		РежимВычисления = Ложь,
		ПрямоеОбращение = "-В",
		Журнал = Ложь,
		ИмяПроцесса = "",
		ПрефиксОшибки = "") Экспорт
	ТекстКода = ?(РежимВычисления, "Результат = ", "") + ТекстКодаПараметр;
	ТипПрм = ТипЗнч(Прм);
	ЭтоСервер = МестоВыполненияКода(Истина) = "Сервер";
	ЭтоСТЗ = ?(ЭтоСервер, ТипПрм = Тип("СтрокаТаблицыЗначений"), Ложь);
	Если (ТипПрм = Тип("Структура")) ИЛИ (ТипПрм = Тип("ФиксированнаяСтруктура")) ИЛИ ЭтоСТЗ Тогда
		Если ПрямоеОбращение = "-В" Тогда
			МассивКлючей = Новый Массив;
			Для каждого КиЗ Из Прм Цикл
				МассивКлючей.Добавить(КиЗ.Ключ);
			КонецЦикла;
		ИначеЕсли ТипЗнч(ПрямоеОбращение) = Тип("Массив") Тогда
			МассивКлючей = ПрямоеОбращение;
		Иначе
			МассивКлючей = СтрРазделить(ПрямоеОбращение, ",", Ложь);
		КонецЕсли;
		Для каждого Ключ_ Из МассивКлючей Цикл
			ТекстКода = Ключ_ + " = Прм[""" + Ключ_ + """];" + ТекстКода + ";Прм[""" + Ключ_ + """] = " + Ключ_;
		КонецЦикла;
	КонецЕсли;
	Если ЭтоСервер И Журнал Тогда
		Попытка
			Выполнить(ТекстКода);
		Исключение
			Результат = ОписаниеОшибки();
			Выполнить("ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ПрефиксОшибки + Результат)");
		КонецПопытки;
	Иначе
		Выполнить(ТекстКода);
	КонецЕсли;
	Возврат Результат
КонецФункции

// Удаляет из текста запроса уничтожение ВТ
// Параметры:
//  ТекстЗапроса  - Строка - Исходный текст запроса
//  Исключения  - Строка - Имена таблиц, уничтожение которых отменять не надо (через запятую). По умолчанию ""
// Возвращаемое значение:
//   Строка   - Текст запроса без уничтожений ВТ
Функция ОтменитьУничтожения(ТекстЗапроса, Исключения = "") Экспорт
	ВесьТекстЗагл = ВРег(ТекстЗапроса);
	ЭтоНачалоЗапроса = Истина;
	Результат = "";
	ДопустимыеСимволыИмени = СимволыГруппы("ДляПеремВсеЗагл");
	ДопустимыйПервый = СимволыГруппы("ДляПерем1Загл");
	ВзятьЭтуПодстроку = Истина;
	УсловноеНачало = "";
	//Цикл по строкам текста запроса
	Для СчСтрТ = 1 По СтрЧислоСтрок(ВесьТекстЗагл) Цикл
		ТекСтрокаЗапроса = СтрПолучитьСтроку(ТекстЗапроса, СчСтрТ);
		ТекСтрокаЗагл = СтрПолучитьСтроку(ВесьТекстЗагл, СчСтрТ);
		ПоложениеКоммента = Найти(ТекСтрокаЗагл, "//");
		ДлинаТекСтроки = СтрДлина(ТекСтрокаЗагл);
		Если ПоложениеКоммента = 0 Тогда
			ПоложениеКоммента = ДлинаТекСтроки + 1;
		КонецЕсли; 
		ТекСтрокаЗагл = СтрЗаменить(Лев(ТекСтрокаЗагл, ПоложениеКоммента - 1), ";", Символы.ПС);
		СчДл = 0;
		РезультатПоСтроке = "";
		КолвоЗапросовВСтроке = СтрЧислоВхождений(ТекСтрокаЗагл, Символы.ПС) + 1;//Именно так! СтрЧислоСтрок(ТекСтрокаЗагл); даёт ошибку!
		СчЗапросов = 0;
		//Цикл по запросам (фрагментам между ;) внутри строки
		Пока СчЗапросов < КолвоЗапросовВСтроке Цикл
			СчЗапросов = СчЗапросов + 1;
			ЭтаПодстрока = СтрПолучитьСтроку(ТекСтрокаЗагл, СчЗапросов);// + ";";//?(СчЗапросов = КолвоЗапросовВСтроке, "", ";");
			ДлинаЭтойПодстроки = СтрДлина(ЭтаПодстрока);
			Если ДлинаЭтойПодстроки + СчДл >= ПоложениеКоммента Тогда
				ДлинаЭтойПодстроки = ПоложениеКоммента - 1 - СчДл;
				ЭтаПодстрока = Лев(ЭтаПодстрока, ДлинаЭтойПодстроки);
				КолвоЗапросовВСтроке = СчЗапросов; //Завершение цикла
			КонецЕсли;
			ПрошлаяСтрокаЗакончиласьПСПослеУничтожить = УсловноеНачало <> "";
			//Похоже, ЭтоНачалоЗапроса пытались убирать из этого условия. Это нельзя делать, иначе все ; пропадут
			//ВзятьЭтуПодстроку нужно, чтобы после УНИЧТОЖИТЬ не брались строки до конца запроса, когда будет СчЗапросов > 1.
			Если ВзятьЭтуПодстроку ИЛИ (СчЗапросов > 1) ИЛИ ПрошлаяСтрокаЗакончиласьПСПослеУничтожить ИЛИ ЭтоНачалоЗапроса Тогда
				ВзятьЭтуПодстроку = Истина;
				Если ПустаяСтрока(ЭтаПодстрока) Тогда
					Если КолвоЗапросовВСтроке = 1 Тогда
						Если ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
							УсловноеНачало = УсловноеНачало + ЭтаПодстрока + Символы.ПС;
						КонецЕсли;
					Иначе
						ЭтоНачалоЗапроса = Истина;
						Если ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
							РезультатПоСтроке = РезультатПоСтроке + УсловноеНачало;
							УсловноеНачало = "";
						КонецЕсли;
					КонецЕсли;
				Иначе
					ДоУничтожитьЧисто = Ложь;
					Если ЭтоНачалоЗапроса Тогда
						ЕстьОтступПослеУничтожить = Ложь;//Скорректируется позже, это инициализация
						ПолУн = Найти(ЭтаПодстрока, "УНИЧТОЖИТЬ");
						ДоУничтожитьЧисто = ПустаяСтрока(Лев(ЭтаПодстрока, ПолУн - 1));
					ИначеЕсли ПрошлаяСтрокаЗакончиласьПСПослеУничтожить Тогда
						ДоУничтожитьЧисто = Истина;
						ЕстьОтступПослеУничтожить = Истина;
						ПолУн = - 9;
					КонецЕсли;
					Если ДоУничтожитьЧисто Тогда
						ТекСимвол = "";
						Для Ё = ПолУн + 10 По ДлинаЭтойПодстроки Цикл
							ТекСимвол = Сред(ЭтаПодстрока, Ё, 1);
							Если НЕ ПустаяСтрока(ТекСимвол) Тогда
								Прервать;
							КонецЕсли;
							ЕстьОтступПослеУничтожить = Истина;
						КонецЦикла;
						Если ЕстьОтступПослеУничтожить Тогда
							Если (Ё > ДлинаЭтойПодстроки) И (КолвоЗапросовВСтроке = СчЗапросов) Тогда
								УсловноеНачало = УсловноеНачало + ЭтаПодстрока + Символы.ПС;
								ВзятьЭтуПодстроку = Ложь;
							ИначеЕсли Найти(ДопустимыйПервый, ТекСимвол) > 0 Тогда
								ПозНачалаИмени = Ё;
								Пока Истина Цикл
									Ё = Ё + 1;
									ТекСимвол = Сред(ЭтаПодстрока, Ё, 1);
									Если (ТекСимвол = "") ИЛИ (Найти(ДопустимыеСимволыИмени, ТекСимвол) = 0) Тогда
										Прервать;
									КонецЕсли;
								КонецЦикла;
								Если ПустаяСтрока(Сред(ЭтаПодстрока, Ё, ДлинаЭтойПодстроки - Ё + 1)) Тогда
									ИмяВТ = Сред(ЭтаПодстрока, ПозНачалаИмени, Ё - ПозНачалаИмени);
									Если НайтиПодСтроку(Исключения, ИмяВТ) = 0 Тогда
										ВзятьЭтуПодстроку = Ложь;
										УсловноеНачало = "";
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					ЭтоНачалоЗапроса = КолвоЗапросовВСтроке > СчЗапросов;
				КонецЕсли;
			КонецЕсли;
			Если ВзятьЭтуПодстроку Тогда
				РезультатПоСтроке = РезультатПоСтроке + ";" + УсловноеНачало + Сред(ТекСтрокаЗапроса, СчДл, ДлинаЭтойПодстроки);// + ";"
			КонецЕсли;
			СчДл = СчДл + ДлинаЭтойПодстроки + 1;
		КонецЦикла;
		Результат = Результат + Символы.ПС + Сред(РезультатПоСтроке, 2) + Сред(ТекСтрокаЗапроса, ПоложениеКоммента, ДлинаТекСтроки);//после ПоложениеКоммента было -1 - убрал, должен же браться коммент
	КонецЦикла;
	Возврат Сред(Результат, 2)
КонецФункции // ОтменитьУничтожения
 
//Генерит ошибку для запуска конфигуратора
Процедура ПерейтиВКонфигуратор() Экспорт
	Ы = 1/0
КонецПроцедуры

#Конецобласти

#Область МЕНЕДЖЕРЫ_РАСПОЗНАВАНИЕ_И_РАСЧЁТ
	
// Запускает менеджер (обработчик) реквизита или события. При этом нераспознаваемые значения не будут приводить к вызову сервера.
// Параметры:
//  Менеджер  - Строка, Дополнительная обработка УФ, Внешняя обработка ОФ, ПереопределяемаяПроцедура, Путь к файлу обработки или иное значение - Путь к менеджеру, код менеджера или иное.
//			В ПП стандартный возврат Результата, в ВО - запуск метода обработки "ЗапуститьМенеджер(ПараметрыМенеджера)",
//			в ДО - запуск серверного метода "ВыполнитьКоманду" с заданным в параметрах именем команды или командой "ЗапуститьМенеджер" по умолчанию.
//			Все параметры (АдресВременногоХранилища, ПолучитьСКД, ПолучитьНастройкиСКД, ПолучитьПараметры) передаются в ПараметрахМенеджера.
//			СТРОКА обрабатывается в таком порядке:
//					1.Проверка на Префикс "Результат =" - такая строка считается исполняемым кодом;
//					2.Проверка на служебные префиксы:
//						*"F:" - путь к файлу обработки для исполнения,
//						*"Т:" (рус) - строка,
//						*"В:" (рус) - вычисление,
//						*"Р:" (рус) - распознавание,
//					3.Попытка вычислить;
//					4.Попытка распознать по строке с применением типов из массива ТипыДляРаспознавания; Если массив пустой, распознавание идёт по всем типам, если Неопределено, шаг пропускается.
//					5.Возврат самой строки.
//  ПараметрыМенеджера  - Структура - Параметры, передаваемые для применения в менеджере. В формуле обозначаются Прм.
//  ТипыДляРаспознавания  - Массив типов или менеджеров прикладного типа или менеджер прикладного типа или тип - допустимые типы результата при распознавании.
//  ОбработкаИсключения  - Код выполнения распознавания. Выполняется, если менеджер - не строка и не выполняемая обработка.
//  ПоРеквизиту  - Имя реквизита, по которому вести распознавание.
//  Родитель  - Родитель, внутри которого вести распознавание.
//  Владелец  - Владелец, внутри которого вести распознавание.
//	СообщатьСюда - Строка или Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
// Возвращаемое значение:
//   Произвольное   - Результат, возвращаемый менеджером
Функция ЗапуститьМенеджер(
		Менеджер,
		ПараметрыМенеджера = Неопределено,
		ТипыДляРаспознавания = Неопределено,
		ОбработкаИсключения = "",
		ПоРеквизиту = "",
		Родитель = Неопределено,
		Владелец = Неопределено,
		СообщатьСюда = Неопределено) Экспорт
	Хрюква = "Специальная@#Хрюква_КоТоРоЙ:$ЯвноНе()Будет";
	Результат = Хрюква;
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		ТекТип = ТипЗнч(Менеджер);
		Если ТекТип <> Тип("Строка") И Найти("Переопределяемые процедуры,Внешние обработки,Дополнительные отчеты и обработки", ТекТип) = 0 Тогда
			Результат = Менеджер;
			//Сюда надо добавить проверки других вариантов, чтоб не прыгать с клиента на сервер
		КонецЕсли;
	#КонецЕсли
	Если Результат = Хрюква Тогда
		Результат = ВОЛНА_ОбщегоНазначенияВС.ЗапуститьМенеджер(
				Менеджер,
				ПараметрыМенеджера,
				ТипыДляРаспознавания,
				ОбработкаИсключения,
				ПоРеквизиту,
				Родитель,
				Владелец,
				СообщатьСюда)
	КонецЕсли;
	Возврат Результат
КонецФункции
#КонецОбласти

#Область КОЛЛЕКЦИИ

#Область ПРОИЗВОЛЬНАЯ_КОЛЛЕКЦИЯ
	
//Возвращает количество элементов коллекции-параметра, а если параметр - не коллекция, то
//	* -2, если значение - пустая ссылка
//	* -1 - иначе
//Параметры:
//	Коллекция - Произвольная коллекция - Кого посчитают :)
Функция КоличествоКоллекции(Коллекция) Экспорт
	Попытка
		КолвоПараметров = Коллекция.Количество();
	Исключение
		КолвоПараметров = -1;
		Попытка
			Если Коллекция.Пустая() Тогда КолвоПараметров = -2 КонецЕсли
		Исключение
		КонецПопытки;
	КонецПопытки;
	Возврат КолвоПараметров
КонецФункции

// Выгружает колонку коллекции (не обязательно ТЗ!) в строку с разделителями. Можно использовать, например, для получения строки для Свернуть.
// Параметры:
//  Коллекция		- любая коллекция с колонками (реквизитами строк) - источник данных
//  ИмяРеквизита	- строка - имя реквизита, из которого будет сформирована строка
//  Разделитель		- любое значение, преобразуемое в строку - разделитель для строки-результата
// Возвращаемое значение:
//   Строка   - строка с разделителями, содержащая представления заданного реквизита строк
Функция КолонкуКоллекцииВСтрокуСРазделителями(Коллекция, ИмяРеквизита, Разделитель = ",") Экспорт
	Результат = "";
	Для каждого Строчка Из Коллекция Цикл
		Результат = Результат + Разделитель + Строчка[ИмяРеквизита];
	КонецЦикла;
	Возврат Сред(Результат, СтрДлина(Разделитель) + 1);
КонецФункции // КолонкуКоллекцииВСтрокуСРазделителями()
 
//Удаляет заданные элементы из коллекции
//Параметры:
//	пКоллекция - Произвольная коллекция - откуда удалить элементы
//	пмЛишниеСтроки - Массив - Удаляемые элементы
Процедура УдалитьЛишниеСтроки(пКоллекция, пмЛишниеСтроки) Экспорт
	Для каждого ТекСтрока Из пмЛишниеСтроки Цикл
		пКоллекция.Удалить(ТекСтрока);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти 

#Область МАССИВЫ

// Добавляет значение в массив, если его там нет
// Параметры:
//  Приёмник  - Массив - куда добавляется значение
//  Значение  - Произвольное - что добавляется в массив
//  Индекс  - Число - куда вставлять, -1 (по умолчанию) - в конец
// Возвращаемое значение:
//   Значение было добавлено   - Булево
Функция ДобавитьВМассивЕслиЕщёНет(Приёмник, Значение, Индекс = -1) Экспорт
	Результат = Приёмник.Найти(Значение) = Неопределено;
	Если Результат Тогда
		Если Индекс = -1 Тогда
			Приёмник.Добавить(Значение);
		Иначе
			Приёмник.Вставить(Индекс, Значение);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // ДобавитьВМассивЕслиЕщёНет

//Аналог ВыгрузитьКолонку для коллекций, не поддерживающих ВыгрузитьКолонку
//Параметры:
//	  Коллекция - Произвольная коллекция, имеющая колонки у элементов - источник данных
//	  ИмяВыгружаемойКолонки - Строка - Имя выгружаемой колонки
//Возвращаемое значение:
//	  Массив - Значения из выгружаемой колонки
Функция КолонкуКоллекцииВМассив(Коллекция, ИмяВыгружаемойКолонки) Экспорт
	Результат = Новый Массив;
	Для каждого Элемент из Коллекция Цикл
		Результат.Добавить(Элемент[ИмяВыгружаемойКолонки])
	КонецЦикла;
	Возврат Результат
КонецФункции

//Проверяет, является ли параметр массивом, и если не является преобразует его в массив с единственным значением
//Параметры:
//	Что - Произвольное значение - источник данных
//	ПеределатьВМассивЕслиКоллекция - Булево - Если Истина, элементы коллекции из параметра Что будут добавлены в результат.
//		Д.б. установлена, если надо сложить два массива. При Ложь значение Что будет добавлено в конец массива. По умолчанию Ложь.
//	ПеременнаяДляПолученияРезультата - Произвольный - Переменная, в которую будет передано возвращаемое значение,
//		если невозможно исползовать как функцию. Сюда же передаётся начальный массив, к которому будут добавлены значения.
//		Если в эту переменную передать не массив, значение будет потеряно.
//	БратьЗначение - Булево - При Ложь (по умолчанию) в массив загружается весь элемент коллекции, при Истина - его значение
//Возвращаемое значение:
//	Массив - Массив из ПеременнаяДляПолученияРезультата, или новый массив
Функция ПреобразоватьВМассив(Что, ПеределатьВМассивЕслиКоллекция = Ложь, ПеременнаяДляПолученияРезультата = Неопределено, БратьЗначение = Ложь) Экспорт
	ТипМассив = Тип("Массив");
	Если ТипЗнч(ПеременнаяДляПолученияРезультата) <> ТипМассив Тогда
		ПеременнаяДляПолученияРезультата = Новый Массив;
	КонецЕсли;
	Результат = ПеременнаяДляПолученияРезультата;
	Если ПеределатьВМассивЕслиКоллекция Тогда
		Попытка
			Для каждого Элемент_ Из Что Цикл
				Результат.Добавить(?(БратьЗначение, Элемент_.Значение, Элемент_));
			КонецЦикла;
		Исключение
			Результат = Новый Массив;
			Результат.Добавить(Что);
		КонецПопытки;
	ИначеЕсли ТипЗнч(Что) = ТипМассив Тогда
		Результат = Что;
		ПеременнаяДляПолученияРезультата = Что;
	Иначе
		Результат.Добавить(Что);
	КонецЕсли;
	Возврат Результат
КонецФункции

// Разность Массивов
// Параметры:
//  Уменьшаемое  - Массив - Массив, значения из которого будут в разности, за исключением вычитаемого
//  Вычитаемое  - Массив - Массив, значения из которого будут исключены из результата
//  Разность  - Массив - Массив, то же самое, что и Результат. По умолчанию Неопределено (пустой). Для использования вызова без возвращаемого значения. Если непустой, значения будут добавлены к нему.
//  Свернуть  - Булево - Истина (по умолчанию) - из результата будут удалены дубли.
// Возвращаемое значение:
//   Массив   - Значения из Уменьшаемого, кроме значений из Вычитаемого
Функция РазностьМассивов(Уменьшаемое, Вычитаемое, Разность = Неопределено, Свернуть = Истина) Экспорт
	Если Разность = Неопределено Тогда
		Разность = Новый Массив;
	КонецЕсли;
	Если Разность = Уменьшаемое Тогда
		Свернуть = Истина;
	КонецЕсли;
	Для каждого ЭлементМ Из Уменьшаемое Цикл
		Если (Вычитаемое.Найти(ЭлементМ) = Неопределено) И ((НЕ Свернуть) ИЛИ (Разность.Найти(ЭлементМ) = Неопределено)) Тогда
			Разность.Добавить(ЭлементМ);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Разность
КонецФункции // РазностьМассивов

//Удаляет дубли из массива. ВНИМАНИЕ! Новый массив не создаётся, для создания нового надо использовать СложитьМассивы.
//Параметры:
//	Массив - Массив - Исходный массив
//Возвращаемое значение - массив без дублей. Он же в параметре Массив, что позволяет использовать функцию как процедуру.
Функция СвернутьМассив(Массив) Экспорт
	Размер = Массив.Количество();
	Для Ё = 1 По Размер Цикл
		ТекИндекс = Размер - Ё;
		Если Массив.Найти(Массив[ТекИндекс]) <> ТекИндекс Тогда
			Массив.Удалить(ТекИндекс)
		КонецЕсли;
	КонецЦикла;
	Возврат Массив
КонецФункции

//Складывает два массива (добавляет в новый массив элементы сначала первого, потом втогрого), при необходимости - со свёрткой
//Параметры:
//	Массив1 - массив - первое слагаемое
//	Массив2 - массив - второе слагаемое
//	Свернуть - Булево - Удалить дубли
//	УдалитьПустые - Булево - Удалить из результата пустые значения (по умолчанию Ложь)
//	РезультатВПервый - Булево - Не создавать новый массив, а всё сложить в первый
//Возвращаемое значение:
//	Массив - Элементы первого, за ними элементы второго массива. При свёртке из дублей попадает только первый.
Функция СложитьМассивы(Массив1, Массив2, Свернуть = Истина, УдалитьПустые = Ложь, РезультатВПервый = Ложь) Экспорт
	Если РезультатВПервый Тогда
		Результат = ?(Свернуть, СвернутьМассив(Массив1), Массив1);
		Если УдалитьПустые Тогда
			УдалитьПустыеИзМассива(Результат); 
		КонецЕсли; 
	Иначе
		Результат = СложитьМассивы(Новый Массив, Массив1, Свернуть, УдалитьПустые, Истина);
	КонецЕсли; 
	Для Каждого Элемент Из Массив2 Цикл
		Если ?(?(УдалитьПустые, ЗначениеЗаполнено(Элемент), Истина), ?(Свернуть, Результат.Найти(Элемент) = Неопределено, Истина), Ложь) Тогда
			Результат.Добавить(Элемент);
		Конецесли
	КонецЦикла;
	Возврат Результат
КонецФункции

//Преобразует массив в список значений.
//Параметры:
//	Массив - Массив - источник данных
//	Свернуть - Булево - при Истина будет взято только первое из повторяющихся значений.
//	ПометкаПоУмолчанию - Булево - Пометка для установки в элементы списка. По умолчанию Ложь.
//	КартинкаПоУмолчанию - Картинка или Неопределено - Картинка для установки в элементы списка. Если Неопределено (по умолчанию) - картинка не устанавливается.
//	Результат - Список значений или Неопределено (по умолчанию) - переменная для возврата результата для работы 
//			в режиме процедуры, когда список надо не присвоить, а разместить в существующий. При неопределено будет создан новый список.
//Результат - для работы  в режиме процедуры, когда список надо не присвоить, а разместить в существующий.
//Возвращаемое значение:
//	Список значений - где значение - элемент массива, представление - строковое представление элемента, картинка и пометка из параметров.
Функция СписокИзМассива(Массив, Свернуть = Истина, ПометкаПоУмолчанию = Ложь, КартинкаПоУмолчанию = Неопределено, Результат = Неопределено) Экспорт
	Если Результат = Неопределено Тогда
		Результат = Новый СписокЗначений;
	КонецЕсли; 
	Если КартинкаПоУмолчанию = Неопределено Тогда
		КартинкаПоУмолчанию = Новый Картинка
	КонецЕсли;
	Для каждого Элемент из Массив Цикл
		Если ?(Свернуть, Результат.НайтиПоЗначению(Элемент) = Неопределено, Истина) Тогда
			Результат.Добавить(Элемент, СокрЛП(Элемент), ПометкаПоУмолчанию, КартинкаПоУмолчанию)
		КонецЕсли
	КонецЦикла;
	Возврат Результат
КонецФункции

// Сравнивает массивы более корректно, чем БСП, где два массива с разными задвоями будут равными и нет вызова с клиента
// Параметры:
//  м1  - Массив - Один из сравниваемых
//  м2  - Массив - Второй из сравниваемых
// Возвращаемое значение:
//   Булево   - Массивы равны
Функция МассивыРавны(м1, м2) Экспорт
	Результат = Истина;
	Тестер = Новый Соответствие;
	Для каждого элМ Из М1 Цикл
		Если Тестер[элМ] = Неопределено Тогда
			Тестер.Вставить(элМ, 1);
		Иначе
			Тестер[элМ] = Тестер[элМ] + 1;
		КонецЕсли;Тестер.Вставить(элМ, 1);
	КонецЦикла;
	Для каждого элМ Из М1 Цикл
		Если Тестер[элМ] = Неопределено Тогда
			Результат = Ложь;
			Прервать;
		Иначе
			Тестер[элМ] = Тестер[элМ] - 1;
			Если Тестер[элМ] < 0 Тогда
				Результат = Ложь;
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если Результат Тогда
		Для каждого КиЗ Из Тестер Цикл
			Если КиЗ.Значение <> 0 Тогда
				Результат = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции // МассивыРавны

// Удаляет незаполненные элементы из массива. ВНИМАНИЕ! Новый массив не создаётся, для создания нового надо использовать СложитьМассивы.
// Параметры:
//  Массив_  - Массив - Проверяемый массив
// Возвращаемое значение:
//   Массив   - Тот же массив, что и был передан, но без пустых значений.
Функция УдалитьПустыеИзМассива(Массив_) Экспорт
	ВГр = Массив_.ВГраница();
	Для Ё = 1 По ВГр Цикл
		Если НЕ ЗначениеЗаполнено(Массив_[ВГр - Ё]) Тогда
			Массив_.Удалить(ВГр - Ё)
		КонецЕсли; 
	КонецЦикла; 
	Возврат Массив_
КонецФункции // УдалитьПустыеИзМассива
 
#КонецОбласти

#Область СПИСОК_ЗНАЧЕНИЙ
	
//Возвращает табличный документ, в который выведен список значений
//Параметры:
//	  Список - Список значений - Выводимый в таблицу
//Возвращаемое значение:
//	  Табличный документ - Значения из выгружаемой колонки
Функция ВывестиСписокВТабличныйДокумент(Список) Экспорт
	Результат = Новый ТабличныйДокумент;
	РазмерСписка = Список.Количество();
	Результат.Область(1, 1, РазмерСписка, 4).СодержитЗначение = Истина;
	Результат.Область(1, 1, РазмерСписка, 4).ШиринаКолонки = 70;
	Для Ё = 1 По РазмерСписка Цикл
		Элемент = Список[Ё - 1];
		Результат.Область(Ё, 1, Ё, 1).Значение = Элемент.Представление;
		Результат.Область(Ё, 1, Ё, 1).Расшифровка = Элемент.Значение;
		Результат.Область(Ё, 2, Ё, 2).Значение = Элемент.Пометка;
		Результат.Область(Ё, 3, Ё, 3).Значение = Элемент.Картинка
	КонецЦикла;
	Результат.ТолькоПросмотр = Истина;
	Результат.Защита = Истина;
	Возврат Результат
КонецФункции

// Перемешивает строки списка значений
// Параметры:
//  Список_  - Список значений - строки которого надо перемешать
Процедура ПеремешатьСписок(Список_) Экспорт
	СлуГен = Новый ГенераторСлучайныхЧисел(Секунда(ТекущаяДата()));
	Колво = Список_.Количество() - 1;
	Для Ё = 0 По Колво Цикл
		Список_.Сдвинуть(Список_[Ё], СлуГен.СлучайноеЧисло(0, Колво) - Ё);
	КонецЦикла; 
КонецПроцедуры // ПеремешатьСписок()

// Возвращает помеченные элементы списка значений
// Параметры:
//  Список  - Список значений - Источник данных. Допустимо = ТЗ с колонками Пометка, Значение, Представление, Картинка (какие востребованы).
//  Пометка  - Булево - Искомое значение пометок. Неопределено - все пометки. По умолчанию Истина.
//  Контент  - Строка - Вид возвращаемых данных:
//			*Значения - Массив значений (по умолчанию)
//			*Наоборот - Соответствие, где ключ - значение, а значение - представление
//			*Представления - Массив представлений
//			*Соответствие - Соответствие, где ключ - представление, а значение - значение
//			*Список - Список значений
//			*Структура - Структура, где ключ - представление, а значение - значение
//			*ТЗ - таблица значений
//			*Картинка - Массив картинок
//			*Элементы - Массив элементов
// Возвращаемое значение:
//   Массив/Соответствие/Структура/Список значений/ТаблицаЗначений   - Отобранные по пометке значения
Функция Помеченные(Список, Пометка = Истина, Контент = "Значения") Экспорт
	#Область ВАРИАНТЫ_КОНТЕНТА
		Если Контент = "Наоборот" Тогда
			ТипР = "Структура";
			Результат = Новый Соответствие;
			Ключ = "Значение";
			Значение = "Представление";
		ИначеЕсли Контент = "Представления" Тогда
			ТипР = "Массив";
			Результат = Новый Массив;
			Ключ = "";
			Значение = "Представление";
		ИначеЕсли Контент = "Соответствие" Тогда
			ТипР = "Структура";
			Результат = Новый Соответствие;
			Ключ = "Представление";
			Значение = "Значение";
		ИначеЕсли Контент = "Список" Тогда
			ТипР = "СЗ_ТЗ";
			Результат = Новый СписокЗначений;
			Ключ = "Значение";
			Значение = "Представление";
		ИначеЕсли Контент = "Структура" Тогда
			ТипР = "Структура";
			Результат = Новый Структура;
			Ключ = "Представление";
			Значение = "Значение";
		ИначеЕсли Контент = "ТЗ" Тогда
			#Если Сервер Тогда
				ТипР = "СЗ_ТЗ";
				Результат = Новый ТаблицаЗначений;
				Результат.Колонки.Добавить("Значение");
				Результат.Колонки.Добавить("Представление");
				Результат.Колонки.Добавить("Картинка");
				Результат.Колонки.Добавить("Пометка");
			#КонецЕсли
			#Если Клиент Тогда
				ТипР = "Массив";
				Результат = Новый Массив;
			#КонецЕсли
			Ключ = "Элемент";
			Значение = "";
		ИначеЕсли Контент = "Картинка" Тогда
			ТипР = "Массив";
			Результат = Новый Массив;
			Ключ = "";
			Значение = "Картинка";
		ИначеЕсли Контент = "Элементы" Тогда
			ТипР = "Массив";
			Результат = Новый Массив;
			Ключ = "Элемент";
			Значение = "Элемент";
		Иначе
			ТипР = "Массив";
			Результат = Новый Массив;
			Ключ = "";
			Значение = "Значение";
		КонецЕсли;
	#КонецОбласти 
	Для каждого ЭлементС Из Список Цикл
		Если Пометка = Неопределено ИЛИ ЭлементС.Пометка = Пометка Тогда
			Если ТипР = "Массив" Тогда
				Результат.Добавить(?(Значение = "Элемент", ЭлементС, ЭлементС[Значение]));
			ИначеЕсли ТипР = "Структура" Тогда
				Результат.Вставить(ЭлементС[Ключ], ЭлементС[Значение]);
			ИначеЕсли ТипР = "СЗ_ТЗ" Тогда
				ЗаполнитьЗначенияСвойств(Результат.Добавить(), ЭлементС);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // Помеченные

// Дополняет список значений по структуре/соответствию
// Параметры:
//  Источник  - Структура/Соответстивие - Источник данных
//  Приёмник  - Список значений - Список-получатель
//  Пометка  - Булево - Значение пометки новых элементов
//  Режим  - Строка -
//		*ДобавитьСУчётомКлючей (по умолчанию) - добавить к существующим, заменив существующие ключи
//		*ДобавитьВсё - добавить к существующим без проверок
//		*ДобавитьНовые - добавить к существующим только новые ключи
//		*Очистить - предварительно очистить
//		*НеДобавлять - только заменить существующие ключи
//	Сортировать_ - Булево - Сортировка по представлению: Неопределено (По умолчанию) = по необходимости, Истина/Ложь - всега сортировать/нет
// Возвращаемое значение:
//   Список значений   - Дополненный из источника
Функция СписокИзСтруктуры(Источник, Приёмник = Неопределено, Пометка = Ложь, Режим = "ДобавитьСУчётомКлючей", Сортировать_ = Неопределено) Экспорт
	Если Источник = Неопределено Тогда
		Источник = Новый Структура;
	КонецЕсли;
	Если Приёмник = Неопределено Тогда
		Результат = Новый СписокЗначений;
		Вариант = "ДобавитьВсё";
	Иначе
		Результат = Приёмник;
		Вариант = Режим;
	КонецЕсли;
	Если Вариант = "Очистить" Тогда
		Результат.Очистить();
	КонецЕсли;
	РежимВсе = Режим = "Очистить" ИЛИ Режим = "ДобавитьВсё";
	Если ?(Сортировать_ = Неопределено, НЕ РежимВсе, Сортировать_) Тогда
		Результат.СортироватьПоПредставлению(НаправлениеСортировки.Возр);
	КонецЕсли; 
	Для каждого КиЗ Из Источник Цикл
		Если РежимВсе Тогда
			НовЭл = Результат.Добавить();
		Иначе
			НовИндекс = ИндексПоловиннымДелением(КиЗ.Ключ, Приёмник, "Представление");
			НовЭл = Результат[НовИндекс];
			Если НовЭл.Представление = КиЗ.Ключ Тогда
				Если Режим = "ДобавитьНовые" Тогда
					НовЭл = "";
				КонецЕсли;
			Иначе
				Если Режим = "НеДобавлять" Тогда
					НовЭл = "";
				Иначе
					НовЭл = Результат.Добавить();
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
		Если НовЭл <> "" Тогда
			НовЭл.Значение = КиЗ.Значение;
			НовЭл.Представление = КиЗ.Ключ;
			НовЭл.Пометка = Пометка;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // СписокИзСтруктуры

// Дополняет структуру (или сздаёт её) / соответствие значениями из списка
// Параметры:
//  Список  - Список значений - Источник данных
//  Исходная  - Структура/Соответствие - Приёмник данных
//  ВСоответствие  - Булево - Преобразовать в соответствие. Если ложь (по умолчанию) = будет тип как у Исходной, а при создании = Структура.
//  Скопировать  - Булево - Вернуть копию (аналог Знач). По умолчанию Ложь.
//  ВставлятьНеПомеченные  - Булево - Вставлять в структуру непомеченные элементы. По умолчанию Ложь.
// Возвращаемое значение:
//   Структура/Соответствие   - Исходная + данные списка
Функция СтруктураИзСпискаЗначений(Список, Исходная = Неопределено, ВСоответствие = Ложь, Скопировать = Ложь, ВставлятьНеПомеченные = Истина) Экспорт
	Если Исходная = Неопределено Тогда
		Исходная = Новый Структура;
	КонецЕсли;
	Результат = ?(Скопировать, ?(ВСоответствие, Новый Соответствие, Новый Структура), Исходная);
	Особый = ВСоответствие И ТипЗнч(Исходная) <> Тип("Соответствие") И НЕ Скопировать;
	Если Особый Тогда
		Результат = Новый Соответствие;
	КонецЕсли;
	Если Особый ИЛИ Скопировать Тогда
		Для каждого КиЗ Из Исходная Цикл
			Результат.Вставить(?(ВСоответствие, КиЗ.Ключ, СтрокуВИмяПеременной(СокрЛП(КиЗ.Ключ))), КиЗ.Значение);
		КонецЦикла;
	КонецЕсли;
	Для каждого ЭлементСЗ Из Список Цикл
		Если ВставлятьНеПомеченные ИЛИ ЭлементСЗ.Пометка Тогда
			Результат.Вставить(?(ВСоответствие, ЭлементСЗ.Представление, СтрокуВИмяПеременной(СокрЛП(ЭлементСЗ.Представление))), ЭлементСЗ.Значение);
		КонецЕсли;
	КонецЦикла;
	Если Особый Тогда
		Исходная = Результат
	КонецЕсли;
	Возврат Результат
КонецФункции // СтруктураИзСпискаЗначений

#КонецОбласти 

#Область СТРУКТУРА
	
//Читает значение заданного ключа из структуры с проверками на наличие структуры и ключа.
//Параметры:
//	Структура_ - Структура - из которой будет прочитано значение.
//	ИмяСвойства - Строка - искомый ключ
//	ЗначениеЕслиНет - Произвольный -  Значение, возвращаемое, если прочитать не вышло
//	ПроверитьЧтоЭтоСтруктура - Булево - Если ложь, без проверки принимается, что тип параметра "Структура_" - структура.
//Возвращаемое значение -  Произвольный -  значение ключа
Функция ЧтСтрукт(Структура_, ИмяСвойства, ЗначениеЕслиНет = Неопределено, ПроверитьЧтоЭтоСтруктура = Ложь) Экспорт
	ТекТип = ТипЗнч(Структура_);
	Возврат ?(?(ПроверитьЧтоЭтоСтруктура, ТекТип = Тип("Структура") ИЛИ ТекТип = Тип("ФиксированнаяСтруктура"), Истина),
			?(Структура_.Свойство(ИмяСвойства), Структура_[ИмяСвойства], ЗначениеЕслиНет), ЗначениеЕслиНет)
КонецФункции

// Добавляет КиЗы источника в приёмник
// Параметры:
//  Приёмник - Структура или Неопределено - Одно из слагаемых. Если Неопределено, то возвращается копия источника независимо от РежимПроцедуры.
//  Источник  - Структура - Второе слагаемое
//	РежимПроцедуры - Булево - Если Истина, результат сложения окажется в Приёмнике, а вернётся Истина.
//		Если Ложь (по умолчанию), то Приёмник и Источник не изменятся, а результат будет возвращён.
// Возвращаемое значение:
//   Структура или Булево   - описание выше
Функция ДополнитьСтруктуру(Приёмник = Неопределено, Источник, РежимПроцедуры = Ложь) Экспорт
	Результат = ?(Приёмник = Неопределено, Новый Структура, ?(РежимПроцедуры, Приёмник, ДополнитьСтруктуру(Неопределено, Приёмник)));
	Для каждого КиЗ Из Источник Цикл
		Результат.Вставить(КиЗ.Ключ, КиЗ.Значение);
	КонецЦикла; 
	Возврат ?(РежимПроцедуры, Истина, Результат)
КонецФункции // ДополнитьСтруктуру()

#КонецОбласти 

//Загружает содержимое табличного документа в таблицу значений. Может возвращать массив структур.
//Параметры:
//	ТабДокИлиExcel - Табличный документ/Строка - Источник. Колонки с пустыми заголовками не читаются. Строка рассматривается как путь к Excel, из которого считывается файл
//	СтрокаТипов - Число/Массив - Номер строки, где расположены типы. 0 - типы не загружаются. По умолчанию - 1. Строка типов должна содержать имя менеджера (например, Справочники.Номенклатура).
//					или массив типов, менеджеров ссылочных значений или строк или массивов таких значений - типы колонок в порядке их следования (исключаемые колонки с пустыми заголовками не исключаются из массива (и других параметров далее)).
//	СтрокаЗаголовков - Число - Номер строки, содержащей заголовки колонок. По умолчанию - 2
//	СтрокаДанных - Число - Номер строки, с которой начинаются данные. По умолчанию = 3
//	Типизировать - Булево - Если Истина, то колонки будут типизированы, что необходимо для использования ТЗ в параметре запроса и удобно для ручного выбора значения. По умолчанию = Ложь
//	Ширина - Число - Ширина таблицы в ТД. По умолчанию = 0, в этом случае определяется автоматически.
//	Высота - Число - Номер последней строки от начала ТД, используемой загрузки данных. По умолчанию 0. В этом случае загружается вся таблица.
//	Распознавание - Число -
//			* 0 - не распознавать
//			* 1 - распознавание только при заданном типе
//			* 2 - распознавание всегда (по умолчанию)
//			Распознавание простых типов - на общих основаниях.
//	СтрокаРеквизита - Число - Номер строки, в которой содержится имя реквизита, по которому распознаётся значение. По умолчанию = 0, реквизит определяется автоматически.
//	СтрокаРодитель - Число - Номер строки, в которой содержится имя колонки родителя, с учётом которого должен вестись поиск. По умолчанию = 0, родитель не учитывается.
//	СтрокаВладелец - Число - Номер строки, в которой содержится имя колонки владельца, с учётом которого должен вестись поиск. По умолчанию = 0, владелец не учитывается.
//	Подстановки - ТаблицаЗначений - С колонками "КолонкаФайла,ЗначениеИзФайла,НовоеЗначение". Если КолонкаФайла = "", то замена по всем колонкам.
//			По умолчанию = Неопределено, и замен нет. Первые колонки содержат строковые значения, третья - произвольное. После замены распознавание не производится.
//	ПослеРаспознавания - Строка, Массив - Обработчик(и (для каждой колонки)) после распознавания значения. В Результат передаётся распознанное значение. Параметры Прм имеют ключи:
//			ИсходноеЗначение, Типы, ИмяКолонки, Таблица, ПодстановкаПоКолонке, ОбщаяПодстановка, Родитель, Владелец. По умолчанию "" - обработчика нет.
//	Прм - Структура - параметры, передаваемые в обработчики ПослеРаспознавания
//	ТипизацияКолонок - Массив - Карта предварительной типизации колонок. Размерность строго по количеству колонок. Элементами м.б.:
//          *Описание типов - присвоится колонке при её создании
//          *"ПоТипу" - Тип будет определён по строке типов
//			Остальные значения игнорируются и тип не присваивается.
//			По умолчанию Неопределено - типизации нет.
//	ЗначенияНераспознанных - Любое значение - Если массив по числу колонок - значения для каждой колонки берутся из элемента.
//			Любое другое значение подставляется, если не распознано. По умолчанию "!_НЕ_НУЖНЫ_!" - берётся распознаваемая строка.
//	НеРаспознаватьУИДБезТипа - Булево - По умолчанию Ложь. Отключает распознавание нетипизированных УИДов, что в некоторых случаях сильно ускорит выполнение.
//	СообщатьОКолонках - Булево - По умолчанию Ложь. Включает вывод сообщения после загрузки колонки.
//	СообщатьСюда - Строка или Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
//	ВернутьМассивСтруктур - Булево - Всегда Истина на тонком и мобильном клиенте, в остальных случаях по умолчанию - ложь
//	СпособЧтения - СпособЧтенияЗначенийТабличногоДокумента - параметр чтения таблицы из Excel. По умолчанию Значение.
//	ОбластьЧтения - Строка - Имя области, из которой надо прочитать данные/листа Excel. По умолчанию пустая строка - чтение из всего ТД.
//Возвращаемое значение
//	Таблица значений - загруженная из ТД с распознаванием значений
Функция ЗагрузитьТаблицуЗначенийИзТабличногоДокумента(
		ТабДокИлиExcel,
		СтрокаТипов = 1,
		СтрокаЗаголовков = 2,
		СтрокаДанных = 3,
		Типизировать = Ложь,
		Ширина = 0,
		Высота = 0,
		Распознавание = 2,
		СтрокаРеквизита = 0,
		СтрокаРодитель = 0,
		СтрокаВладелец = 0,
		Подстановки = Неопределено,
		ПослеРаспознавания = "",
		Прм = Неопределено,
		ТипизацияКолонок = Неопределено,
		ЗначенияНераспознанных = "!_НЕ_НУЖНЫ_!",
		НеРаспознаватьУИДБезТипа = Ложь,
		СообщатьОКолонках = Ложь,
		СообщатьСюда = Неопределено,
		ВернутьМассивСтруктур = Ложь,
		СпособЧтения = Неопределено,
		ОбластьЧтения = "") Экспорт
	#Если ТонкийКлиент ИЛИ МобильныйКлиент ИЛИ МобильноеПриложениеКлиент Тогда
		ВернутьМассивСтруктур = Истина;
	#КонецЕсли
	ТипСтрока = Тип("Строка");
	ТипМассив = Тип("Массив");
	ТипТип = Тип("Тип");
	Если СпособЧтения = Неопределено Тогда
		СпособЧтения = СпособЧтенияЗначенийТабличногоДокумента.Значение;
	КонецЕсли;
	Если ТипЗнч(ТабДокИлиExcel) = ТипСтрока Тогда
		ТаблДокумент = Новый ТабличныйДокумент;
		ТаблДокумент.ИспользуемоеИмяФайла = ТабДокИлиExcel;
		ТаблДокумент.Прочитать(ТабДокИлиExcel, СпособЧтения);
	Иначе
		ТаблДокумент = ТабДокИлиExcel;
	КонецЕсли;
	Если ЗначениеЗаполнено(ОбластьЧтения) Тогда
		ТаблДокумент = ТаблДокумент.ПолучитьОбласть(ОбластьЧтения);
	КонецЕсли;
	ТекШирина_ = ?(Ширина = 0, ТаблДокумент.ШиринаТаблицы, Ширина);
	ТекВысота_ = ?(Высота = 0, ТаблДокумент.ВысотаТаблицы, Высота);
	Если ВернутьМассивСтруктур Тогда
		Результат = Новый Массив;
		Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
			НоваяСтрока_ = Новый Структура;
			Результат.Добавить(НоваяСтрока_);
		КонецЦикла;
	Иначе
		Результат = Вычислить("Новый ТаблицаЗначений");
		Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
			НоваяСтрока_ = Результат.Добавить();
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(СтрокаТипов) = ТипМассив Тогда
		МассивТиповГотов = Истина;
	Иначе
		МассивТиповГотов = Ложь;
	КонецЕсли;
	ЕстьОбработчик = ПослеРаспознавания <> "";
	ЕстьУмолчаниЕ = ЗначенияНераспознанных <> "!_НЕ_НУЖНЫ_!";
	ЕстьУмолчаниЯ = ?(ТипЗнч(ЗначенияНераспознанных) = Тип("Массив"), ЗначенияНераспознанных.Количество() = ТекШирина_, Ложь);
	ЕстьСтрокаТабло = СообщатьСюда <> Неопределено;
	
	ОбщаяПодстановка = ?(Подстановки = Неопределено, Новый Соответствие,
			ВОЛНА_ОбщегоНазначенияВС.СтруктураИзКолонокТаблицы(
			Подстановки.НайтиСтроки(Новый Структура("КолонкаФайла", "")),
			"ЗначениеИзФайла", "НовоеЗначение", Истина, Подстановки.Колонки)); 
	Если СообщатьОКолонках Тогда
		ТекстСообщения = "Старт загрузки: " + ТекущаяДата();
		Если ЕстьСтрокаТабло Тогда
			СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
		Иначе
			Сообщить(ТекстСообщения);
		КонецЕсли;		
	КонецЕсли;
	Для СчКол = 0 По ТекШирина_ - 1 Цикл
		Сч1 = СчКол + 1;
		ТекИмяК = ТаблДокумент.Область(СтрокаЗаголовков, Сч1).Текст;
		Если ТекИмяК <> "" Тогда
			Если НЕ ВернутьМассивСтруктур Тогда
				#Область ТИПЫ_КОЛОНКИ
					ЕстьТипы = Истина;
					ТекТипМ = Новый Массив; //Массив менеджеров
					ТекТипТ = Новый Массив; //Массив типов для типизации колонки
					Если МассивТиповГотов Тогда
						КОбработке = СтрокаТипов[СчКол];
						Если КОбработке = "" Тогда
							КОбработке = Новый Массив;
							ЕстьТипы = Ложь;
						ИначеЕсли ТипЗнч(КОбработке) = ТипСтрока Тогда
							КОбработке = СтрРазделить(КОбработке, ",", Истина);
						ИначеЕсли ТипЗнч(КОбработке) = ТипМассив Тогда
						ИначеЕсли ТипЗнч(КОбработке) = ТипТип Тогда
							ТекМенеджер = ВОЛНА_ОбщегоНазначения_КлиентСервер.ЕслиПервоеВтороеРавныТоТретьеИначеПервое(ВОЛНА_ОбщегоНазначенияВС.ИмяТаблицыОбъектаПоТипу(КОбработке, "Менеджер"), Неопределено, КОбработке);
							ТекТипТ.Добавить(КОбработке);
							ТекТипМ.Добавить(ТекМенеджер);
							КОбработке = Новый Массив;
						Иначе
							//Считаем, что это менеджер ссылки
							ТекТипМ.Добавить(КОбработке);
							ТекТипТ.Добавить(ТипЗнч(КОбработке.ПустаяСсылка()));
							КОбработке = Новый Массив;
						КонецЕсли;
					ИначеЕсли СтрокаТипов = 0 Тогда
						КОбработке = Новый Массив;
						ЕстьТипы = Ложь;
					Иначе
						//Тип представлен строкой. Возможно перечисление через запятую.
						СтрокиМенеджеров = ТаблДокумент.Область(СтрокаТипов, Сч1).Текст;
						Если СтрокиМенеджеров = "" Тогда
							КОбработке = Новый Массив;
							ЕстьТипы = Ложь;
						Иначе
							КОбработке = СтрРазделить(СтрокиМенеджеров, ",", Истина);
						КонецЕсли;
					КонецЕсли;
					Если ЕстьТипы Тогда
						Для каждого СтрочкаДляОпределенияТипа Из КОбработке Цикл
							Попытка
								ТекМенеджер = Вычислить(СтрочкаДляОпределенияТипа);
								ТекТип = ТипЗнч(ТекМенеджер.ПустаяСсылка());
							Исключение
								ТекТип = Тип(СтрочкаДляОпределенияТипа);
								ТекМенеджер = ВОЛНА_ОбщегоНазначения_КлиентСервер.ЕслиПервоеВтороеРавныТоТретьеИначеПервое(ВОЛНА_ОбщегоНазначенияВС.ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер"), Неопределено, ТекТип);
							КонецПопытки;
							ТекТипМ.Добавить(ТекМенеджер);
							ТекТипТ.Добавить(ТекТип);
						КонецЦикла; 
					КонецЕсли; 
					Если ТипизацияКолонок <> Неопределено Тогда
						ТекОТКолонки = ТипизацияКолонок[СчКол];
						ТекТипОТ = ТипЗнч(ТекОТКолонки);
						ТекОТКолонки = ?(ТекОТКолонки = "ПоТипу", ?(ЕстьТипы, Новый ОписаниеТипов(ТекТипТ), Неопределено),
								?(ТекТипОТ = Тип("ОписаниеТипов"), ТекОТКолонки,
								?(ТекТипОТ = ТипМассив, Новый ОписаниеТипов(ТекОТКолонки),
								?(ТекТипОТ = ТипТип, Новый ОписаниеТипов(ВОЛНА_ОбщегоНазначения_КлиентСервер.ПреобразоватьВМассив(ТекОТКолонки)), Неопределено))));
					Иначе
						ТекОТКолонки = Неопределено;
					КонецЕсли;
					ТекТип = ?(ЕстьТипы, ТекТипМ, "");
				#КонецОбласти 
				#Область ДОБАВЛЕНИЕ_КОЛОНКИ
					Если ТекОТКолонки = Неопределено Тогда
						Результат.Колонки.Добавить(ТекИмяК);
					Иначе
						Результат.Колонки.Добавить(ТекИмяК, ТекОТКолонки);
					КонецЕсли;
				#КонецОбласти 
			КонецЕсли; 
			Если СтрокаРеквизита = 0 Тогда
				ТекИмяРеквизита = "";
			Иначе
				ТекИмяРеквизита = ТаблДокумент.Область(СтрокаРеквизита, Сч1).Текст;
			КонецЕсли;
			Если СтрокаРодитель = 0 Тогда
				ТекРодитель = "";
			Иначе
				ТекРодитель = ТаблДокумент.Область(СтрокаРодитель, Сч1).Текст;
			КонецЕсли;
			Если СтрокаВладелец = 0 Тогда
				ТекВладелец = "";
			Иначе
				ТекВладелец = ТаблДокумент.Область(СтрокаВладелец, Сч1).Текст;
			КонецЕсли;
			Если Подстановки = Неопределено Тогда
				ТекПодстановка = Новый Соответствие;
			Иначе
				ТекПодстановка = ВОЛНА_ОбщегоНазначенияВС.СтруктураИзКолонокТаблицы(
						Подстановки.НайтиСтроки(Новый Структура("КолонкаФайла", ТекИмяК)),
						"ЗначениеИзФайла", "НовоеЗначение", Истина, Подстановки.Колонки);
			КонецЕсли; 
			
			ТекУмолчание = ?(ЕстьУмолчаниЯ, ЗначенияНераспознанных[СчКол], ЗначенияНераспознанных);
			ЕстьТекУмолчание = ТекУмолчание <> "!_НЕ_НУЖНЫ_!";
			
			Для СчСтр = СтрокаДанных По ТекВысота_ Цикл
				ТекЗнч = ТаблДокумент.Область(СчСтр, Сч1).Текст;
				НоваяСтрока_ = Результат[СчСтр - СтрокаДанных];
				РезультатРаспознавания = ТекПодстановка[ТекЗнч];
				Если РезультатРаспознавания = Неопределено Тогда
					РезультатРаспознавания = ОбщаяПодстановка[ТекЗнч];
					Если РезультатРаспознавания = Неопределено Тогда
						Если (Распознавание = 0) ИЛИ ((ТекТип = "") И (Распознавание = 1)) Тогда
							РезультатРаспознавания = ТекЗнч;
						Иначе
							РезультатРаспознавания = ВОЛНА_ОбщегоНазначенияВС.РаспознатьЗначение(ТекЗнч, ТекТип,
									?(СтрокаРеквизита = 0, "", ТекИмяРеквизита),
									?(ТекРодитель = "", Неопределено, НоваяСтрока_[ТекРодитель]),
									?(ТекВладелец = "", Неопределено, НоваяСтрока_[ТекВладелец]),, Истина);
							Если (РезультатРаспознавания = ТекЗнч) И ЕстьТекУмолчание Тогда
								РезультатРаспознавания = ТекУмолчание;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если ЕстьОбработчик Тогда
					ПараметрыОбработчика =
							ВОЛНА_ОбщегоНазначения_КлиентСервер.ДополнитьСтруктуру(
								Новый Структура("ИсходноеЗначение,Типы,ИмяКолонки,Таблица,ПодстановкаПоКолонке,ОбщаяПодстановка,Родитель,Владелец",
									ТекЗнч, ТекТип, ТекИмяК, Результат, ТекПодстановка, ОбщаяПодстановка, ТекРодитель, ТекВладелец),
								Прм);
					ВыполнитьКод(ПослеРаспознавания, ПараметрыОбработчика, РезультатРаспознавания);
				КонецЕсли; 
				Если ВернутьМассивСтруктур Тогда
					НоваяСтрока_.Вставить(ТекИмяК, РезультатРаспознавания);
				Иначе
					НоваяСтрока_[ТекИмяК] = РезультатРаспознавания;
				КонецЕсли;
			КонецЦикла	
		КонецЕсли;
		Если СообщатьОКолонках Тогда
			ТекстСообщения = "Загружено " + ТекИмяК + ": " + ТекущаяДата();
			Если ЕстьСтрокаТабло Тогда
				СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
			Иначе
				Сообщить(ТекстСообщения);
			КонецЕсли;		
		КонецЕсли;
	КонецЦикла;	
	Если Типизировать И НЕ ВернутьМассивСтруктур Тогда
		ВОЛНА_ОбщегоНазначенияВС.ТипизироватьТаблицу(Результат);
		Если СообщатьОКолонках Тогда
			ТекстСообщения = "Таблица типизирована: " + ТекущаяДата();
			Если ЕстьСтрокаТабло Тогда
				СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
			Иначе
				Сообщить(ТекстСообщения);
			КонецЕсли;		
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции //ЗагрузитьТаблицуЗначенийИзТабличногоДокумента

// Возвращает иерархию соответствий - фактически аналог индекса
// Параметры:
//  Источник - Коллекция с именованными свойствами элемента (ТЗ, массив структур, ДанныеФормыКоллекция , и т.д. - Источник данных
//  Ключи - Массив структур - Ключи:
//			*Колонка = Имя реквизита элемента источника, откуда берутся ключи,
//			*ЭтоСтруктура = Булево: Истина - создавать структуру, Ложь - соответствие.
//			Иерархия строится в порядке элементов массива.
//  ИсточникЭлементаРезультата - Строка - Имя реквизита, из которого будет назначаться элемент результата (значение низа иерархии).
//			По умолчанию "#ВесьЭлемент" = берётся весь элемент источника
//  ТипЭлементаРезультата - Строка - возможные значения:
//			*Массив - (по умолчанию) - массив, все новые значения заносятся туда
//			*Значение - значение элемента источника. Последующие значения перезаписываются поверх предыдущих
//			*Любое прочее значение - это значение
//  ВзятьЭлементИсточникаИзРеквизита - Строка - Если надо брать элемент источника не из элемента коллекции, а из его реквизита (например, из значения КиЗ),
//			то указывается имя реквизита-источника. По умолчанию пустая строка = ключи берутся из реквизитов самого элемента.
//  ВзятьЭлементРезультатаИзРеквизита - Строка - аналогично ВзятьЭлементИсточникаИзРеквизита, но для ИсточникЭлементаРезультата.
// Возвращаемое значение:
//   Структура/Соответствие - Корень иерархии структур/соответствий
Функция СоответствияИзКоллекции(
		Источник,
		Ключи,
		ИсточникЭлементаРезультата = "#ВесьЭлемент",
		ТипЭлементаРезультата = "Массив",
		ВзятьЭлементИсточникаИзРеквизита = "",
		ВзятьЭлементРезультатаИзРеквизита = "") Экспорт
	Результат  = Новый Структура("Результат");
	Если Ключи.Количество() <> 0 Тогда
		Если Источник.Количество() Тогда
			Для каждого ЭлементИсточника Из Источник Цикл
				Корень = Результат;
				ТекКлюч = "Результат";
				ТекЭтаж = Корень.Результат;
				ТекДанные = ?(ВзятьЭлементИсточникаИзРеквизита = "", ЭлементИсточника, ЭлементИсточника[ВзятьЭлементИсточникаИзРеквизита]);
				//ИЕРАРХИЯ
				Для каждого ОписаниеКлюча Из Ключи Цикл
					Если ТекЭтаж = Неопределено Тогда
						ТекЭтаж = ?(ОписаниеКлюча.ЭтоСтруктура, Новый Структура, Новый Соответствие);
						Корень.Вставить(ТекКлюч, ТекЭтаж);
					КонецЕсли;
					ТекКлюч = ТекДанные[ОписаниеКлюча.Колонка];
					Корень = ТекЭтаж;
					Если ?(ОписаниеКлюча.ЭтоСтруктура, НЕ ТекЭтаж.Свойство(ТекКлюч), ТекЭтаж[ТекКлюч] = Неопределено) Тогда
						ТекЭтаж = Неопределено;
					Иначе
						ТекЭтаж = ТекЭтаж[ТекКлюч];
					КонецЕсли;
				КонецЦикла;
				#Область ЗАПИХНУТЬ_НИЖНИЙ_УРОВЕНЬ
					#Область РАСЧЁТ_ЗНАЧЕНИЯ
						ТекДанные = ?(ВзятьЭлементРезультатаИзРеквизита = "", ЭлементИсточника, ЭлементИсточника[ВзятьЭлементРезультатаИзРеквизита]);
						ТекЗначение = ?(ИсточникЭлементаРезультата = "#ВесьЭлемент", ТекДанные, ТекДанные[ИсточникЭлементаРезультата]);
					#КонецОбласти
					Если ТипЭлементаРезультата = "Массив" Тогда
						Если ТекЭтаж = Неопределено Тогда
							ТекЭтаж = Новый Массив;
						КонецЕсли;
						ТекЭтаж.Добавить(ТекЗначение);
					ИначеЕсли ТипЭлементаРезультата = "Значение" Тогда
						ТекЭтаж = ТекЗначение;
					Иначе
						ТекЭтаж = ТипЭлементаРезультата;
					КонецЕсли;
					Корень.Вставить(ТекКлюч, ТекЭтаж);
				#КонецОбласти
			КонецЦикла;
		Иначе
			Для каждого ОписаниеКлюча Из Ключи Цикл
				Результат.Вставить("Результат", ?(ОписаниеКлюча.ЭтоСтруктура, Новый Структура, Новый Соответствие));
				Прервать;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат.Результат
КонецФункции // СоответствияИзКоллекции

// Получает КиЗ соответствия по индексу
// Параметры:
//  Откуда  - [Фиксированнное ]Соответствие - Откуда получить КИЗ
//  Индекс  - Число, начиная с нуля - Индекс элемента
// Возвращаемое значение:
//   КлючИЗначение   - КиЗ с заданным индексом. Неопределено, если такого нет.
Функция ЭлементСоответствияПоИндексу(Откуда, Индекс) Экспорт
	Результат = Неопределено;
	ЕЙЦ = 0;
	Найден = Ложь;
	Для каждого КиЗ Из Откуда Цикл
		Если ЕЙЦ = Индекс Тогда
			Найден = Истина;
			Прервать;
		Иначе
			ЕЙЦ = ЕЙЦ + 1;
		КонецЕсли; 
	КонецЦикла;
	Если Найден Тогда
		Результат = КиЗ;
	КонецЕсли; 
	Возврат Результат
КонецФункции // ЭлементСоответствияПоИндексу

#КонецОбласти

#Область СТРОКОВЫЕ

// Преобразует строку в дату
// Параметры:
//  Строчка  - Строка - Строка, из которой надо попытаться сделать дату
//  ВПериодеВзятьКонец  - Булево - Если строка - период, то вернуть его конец. Иначе (по умолчанию - ложь) - начало.
// Возвращаемое значение:
//   Дата   - Дата, вычисленная из строки. Неопределено, если не получается.
Функция ДатаИзСтроки(Строчка, ВПериодеВзятьКонец = Ложь) Экспорт
	Результат = Неопределено;
	СтрокаРаспознания = СтрЗаменить(СтрЗаменить(СтрЗаменить(Строчка, "/", Символы.ПС), ".", Символы.ПС), " ", Символы.ПС);
	Сброс = Истина;
	Для Сч = 1 По СтрЧислоСтрок(СтрокаРаспознания) Цикл
		Если Сброс Тогда
			ГодДаты = 0;
			МесяцДаты = 0;
			ДеньДаты = 0;
			Сброс = Ложь;
		КонецЕсли;
		ТекСтр = ВРег(СтрПолучитьСтроку(СтрокаРаспознания, Сч));
		Если НЕ ПустаяСтрока(ТекСтр) Тогда
			Если ДеньДаты = 0 Тогда
				Если СтрДлина(ТекСтр) < 3 Тогда
					Попытка
						ДеньДаты = Число(ТекСтр);
					Исключение
					КонецПопытки;
				КонецЕсли;
				Если ДеньДаты = 0 Тогда
					Если ТекСтр = "ЯНВАРЬ" Тогда
						МесяцДаты = 1;
					ИначеЕсли ТекСтр = "ФЕВРАЛЬ" Тогда
						МесяцДаты = 2;
					ИначеЕсли ТекСтр = "МАРТ" Тогда
						МесяцДаты = 3;
					ИначеЕсли ТекСтр = "АПРЕЛЬ" Тогда
						МесяцДаты = 4;
					ИначеЕсли ТекСтр = "МАЙ" Тогда
						МесяцДаты = 5;
					ИначеЕсли ТекСтр = "ИЮНЬ" Тогда
						МесяцДаты = 6;
					ИначеЕсли ТекСтр = "ИЮЛЬ" Тогда
						МесяцДаты = 7;
					ИначеЕсли ТекСтр = "АВГУСТ" Тогда
						МесяцДаты = 8;
					ИначеЕсли ТекСтр = "СЕНТЯБРЬ" Тогда
						МесяцДаты = 9;
					ИначеЕсли ТекСтр = "ОКТЯБРЬ" Тогда
						МесяцДаты = 10;
					ИначеЕсли ТекСтр = "НОЯБРЬ" Тогда
						МесяцДаты = 11;
					ИначеЕсли ТекСтр = "ДЕКАБРЬ" Тогда
						МесяцДаты = 12;
					КонецЕсли;
					Если МесяцДаты > 0 Тогда
						ДеньДаты = ?(ВПериодеВзятьКонец, -1, 1)
					КонецЕсли;
				КонецЕсли; 
			ИначеЕсли МесяцДаты = 0 Тогда
				Попытка
					МесяцДаты = Число(ТекСтр);
				Исключение
					ТекСтр = ВРег(ТекСтр);
					Если ТекСтр = "ЯНВАРЯ" Тогда
						МесяцДаты = 1;
					ИначеЕсли ТекСтр = "ФЕВРАЛЯ" Тогда
						МесяцДаты = 2;
					ИначеЕсли ТекСтр = "МАРТА" Тогда
						МесяцДаты = 3;
					ИначеЕсли ТекСтр = "АПРЕЛЯ" Тогда
						МесяцДаты = 4;
					ИначеЕсли ТекСтр = "МАЯ" Тогда
						МесяцДаты = 5;
					ИначеЕсли ТекСтр = "ИЮНЯ" Тогда
						МесяцДаты = 6;
					ИначеЕсли ТекСтр = "ИЮЛЯ" Тогда
						МесяцДаты = 7;
					ИначеЕсли ТекСтр = "АВГУСТА" Тогда
						МесяцДаты = 8;
					ИначеЕсли ТекСтр = "СЕНТЯБРЯ" Тогда
						МесяцДаты = 9;
					ИначеЕсли ТекСтр = "ОКТЯБРЯ" Тогда
						МесяцДаты = 10;
					ИначеЕсли ТекСтр = "НОЯБРЯ" Тогда
						МесяцДаты = 11;
					ИначеЕсли ТекСтр = "ДЕКАБРЯ" Тогда
						МесяцДаты = 12;
					Иначе
						Сброс = Истина;
					КонецЕсли;
				КонецПопытки;
			Иначе
				Попытка
					ТекСтр = СтрЗаменить(СтрЗаменить(СтрЗаменить(ТекСтр, "ГОДА", ""), "ГОД", ""), "Г", "");
					ГодДаты = Число(ТекСтр);
					Если ГодДаты < 100 Тогда
						ТекГод = Год(ТекущаяДата());
						ГодДаты = ГодДаты + ТекГод - ТекГод % 100;
					КонецЕсли; 
					Если (ГодДаты < 100) ИЛИ (ГодДаты > 3999) Тогда
						Сброс = Истина;
					Иначе
						Прервать;
					КонецЕсли; 
				Исключение
					Сброс = Истина;
				КонецПопытки;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Попытка
		Результат = Дата(ГодДаты, МесяцДаты, ?(ДеньДаты = -1, 1, ДеньДаты));
		Если ДеньДаты = -1 Тогда
			Результат = КонецМесяца(Результат);
		КонецЕсли; 
	Исключение
	КонецПопытки;
	Возврат Результат
КонецФункции // ДатаИзСтроки
 
// Заменяет наименования подразделения на наименовния для печати
// Параметры:
//  Текст  - Строка - Где менять
//  Замены  - Соответствие - Что менять (ключ) и на что менять (значение)
Функция ЗаменитьВТексте(Текст, Замены) Экспорт
	Результат = Текст;
	Для каждого КиЗ Из Замены Цикл
		Результат = СтрЗаменить(Результат, КиЗ.Ключ, КиЗ.Значение);
	КонецЦикла;
	Возврат Результат
КонецФункции // ЗаменитьВТексте
 
// Заменяет конец строки новым набором символов той же длины
// Параметры:
//  ГдеМенять  - Любое значение, преобразуемое в строку - Исходная строка;
//  НаЧтоМенять  - Любое значение, преобразуемое в строку - Новый конец строки;
Процедура ЗаменитьКонецСтроки(ГдеМенять, НаЧтоМенять)Экспорт
	ГдеМенять = Лев(ГдеМенять, СтрДлина(ГдеМенять) - СтрДлина(НаЧтоМенять)) + НаЧтоМенять
КонецПроцедуры

//Преобразует имя переменной в строку представления
//заменой заглавных букв на строчные с пробелом
// Параметры:
//  ИмяПеременной  - Любое значение, преобразуемое в строку - Исходная строка;
//  ПропуститьНедопустимые  - Булево - При Истина (по умолчанию) символы, недопустимые в имени переменной, будут заменены на пробел,
//			а следующий символ - на заглавный, при Ложь - будут обработаны как допустимый символ;
// Возвращаемое значение:
//   Строка   - Исходная строка с заменой:
//			* СтрочнаяЗаглавная ==> СтрочнаяПробелСтрочная
//			* Подчёркивания (Кроме краевых) ==> Пробел
//			* СтрочнаяЗаглавныеСтрочная ==> СтрочнаяПробелЗаглавныеКромеПоследнейПробелСтрочнаяСтрочная
//			* СтрочнаяЗаглавныеНеКраевоеПодчёркивание ==> СтрочнаяПробелЗаглавныеПробел и т.д.
Функция ИмяПеременнойВСтроку(ИмяПеременной, ПропуститьНедопустимые = Истина) Экспорт
	Заглавные = СимволыГруппы("БуквыЗагл");
	Строчные = СимволыГруппы("БуквыСтр");
	Допустимые = СимволыГруппы("СПиЦ");
	Цифры = СимволыГруппы("Цифры");
	ТекДлина = СтрДлина(ИмяПеременной) + 1;
	Результат = "";
	Буфер = "";
	ПрошлаяСерия = 0;
	Серия = 0; //1 - строчные, 2 - заглавные, 3 - символы
	Для Ё = 1 По ТекДлина Цикл
		ПрошлаяСерия = Серия;
		Если Ё = ТекДлина Тогда
			КВставке = "";
			Серия = 0;
		Иначе
			ТекСимвол = Сред(ИмяПеременной, Ё, 1);
			Если ТекСимвол = "_" Тогда
				КВставке = ?(ПустаяСтрока(Прав(Буфер, 1)), "", " ");
				Серия = 3;
			ИначеЕсли Найти(Цифры, ТекСимвол) > 0 Тогда
				КВставке = ТекСимвол;
				Серия = 3;
			ИначеЕсли Найти(Строчные, ТекСимвол) > 0 Тогда
				КВставке = ТекСимвол;
				Серия = 1;
			ИначеЕсли Найти(Заглавные, ТекСимвол) > 0 Тогда
				КВставке = ТекСимвол;
				Серия = 2;
			Иначе
				КВставке = ?(ПропуститьНедопустимые, ?(ПустаяСтрока(Прав(Буфер, 1)), "", " "), ТекСимвол);
				Серия = 3;
			КонецЕсли;
		КонецЕсли;
		Если ПрошлаяСерия <> Серия Тогда
			Если ПрошлаяСерия = 0 Тогда
			ИначеЕсли ПрошлаяСерия = 2 Тогда
				Если Серия = 1 Тогда
					ТекСлово = Лев(Буфер, СтрДлина(Буфер) - 1);
					Буфер = НРег(Прав(Буфер, 1)) + КВставке;
				Иначе
					ТекСлово = Буфер;
					Буфер = КВставке;
				КонецЕсли; 
				Если СтрДлина(ТекСлово) = 1 Тогда
					ТекСлово = НРег(ТекСлово);
				КонецЕсли;
				Результат = Результат + " " + ТекСлово;
			Иначе
				Результат = Результат + " " + СокрЛП(Буфер);
				Буфер = КВставке;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Возврат Сред(Результат, 2)
КонецФункции

// Заменяет в исходной строке все заданные значения на заданные значения замен с повторением,
// пока не исчезнут заменяемые значения. По умолчанию - для замены лишних пробелов.
// Параметры:
//  НачСтрока  - Любое значение, преобразуемое в строку - Исходная строка;
//  ПодстрокаЧтоМенять  - Любое значение, преобразуемое в строку - Строка, которую искоренить;
//  НаЧтоМенять  - Любое значение, преобразуемое в строку - Строка, на которую заменить;
// Возвращаемое значение:
//   Строка   - Строка без заменяемой подстроки (после всех замен)
Функция ИскоренитьПодстроку(НачСтрока, ПодстрокаЧтоМенять = "  ", НаЧтоМенять = " ") Экспорт
	Результат = Строка(НачСтрока);
	Пока Найти(Результат, ПодстрокаЧтоМенять) > 0 Цикл
		Результат = СтрЗаменить(Результат, ПодстрокаЧтоМенять, НаЧтоМенять);
	КонецЦикла;
	Возврат Результат
КонецФункции // ИскоренитьПодстроку()
 
// Преобразует строковый литерал в текст
// Параметры:
//  Текст_  - Строка - Произвольный текст
// Возвращаемое значение:
//   Строка   - Преобразованный текст: удалены символы переноса, раздвоены кавычки
Функция ЛитералВТекст(Текст_) Экспорт
	Возврат СтрЗаменить(СтрЗаменить(Текст_, "|",  ""), """""", """")
КонецФункции // ТекстВЛитерал

//Находит число символов до заданной подстроки. Если подстроки нет, берётся вся строка.
// Параметры:
//	ГдеИскать - Строка - в которой ищем
//	ИскомыйТекст - Строка - которую ищем
// Возвращаемое значение:
//	Число - колво символов до подстроки. СлужебнаяНайтиКолвоСимволовДоВхождения("12345", "234") = 1
Функция НайтиКолвоСимволовДоВхождения(ГдеИскать, ИскомыйТекст) Экспорт
	Результат = Найти(ГдеИскать, ИскомыйТекст) - 1;
	Возврат ?(Результат < 0, СтрДлина(ГдеИскать), Результат)
КонецФункции // СлужебнаяНайтиКолвоСимволовДоВхождения()

//Ищет строку в составе другой строки, но только как подстроку между разделителями без краевых пробелов
//Возвращает позицию найденной подстроки или 0
// Параметры:
//  ГдеИскать  - Любое значение, преобразуемое в строку - В которой будет поиск
//  ЧтоИскать  - Строка - Искомая строка
//  Разделитель  - Строка - Разделитель частей в ГдеИскать
// Возвращаемое значение:
//   Число   - Позиция начала подстроки
Функция НайтиПодСтроку(ГдеИскать, ЧтоИскать, Разделитель = ",") Экспорт
	Возврат Найти(Разделитель + ГдеИскать + Разделитель, Разделитель + ЧтоИскать + Разделитель)
КонецФункции

// Возвращает типовой разделитель запросов
// Возвращаемое значение:
//   Строка   - Типовой разделитель запросов
Функция РазделительЗапросов() Экспорт
	Результат =
			"
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|";
	Возврат Результат
КонецФункции // РазделительЗапросов

//Проверяет строку на соответствие маске
//источник - инфостарт
//Параметры:
//	Строчка - строка/Массив - проверяемые строки
//	Тестер - значение XDTO - Тестер строки по маске. Если Неопределено - создаётся.
//	Маска - строка - шаблон, на соответствие которому проверяется
//		. - любой символ
//		+ - один или более раз, пример ".+" - один или более любой символ. Суффикс "ревнивого" квантификатора (аа в ааа найдёт только одно вхождение, т.к. вторая а уже участвовала в первом и не может быть использована повторно).
//		* - ноль или более раз, пример ".*" - любое количество любых символов (даже ни одного).
//		[n-m] - символ от m до n, пример: "[0-9]+" - одна или более цифр(а).
//		\b - граница слова (первый или последний символ).
//		\B - не граница слова.
//		\d - цифра, пример \d+ - одна или более цифр(а).
//		\D - не цифра.
//		\G - Предыдущий успешный поиск (\Ga - первая позиция не с буквой а).
//		\s - пробельный символ - ТАБ, пробел, перенос строки, возврат каретки и т.п.
//		\S - непробельный символ.
//		\w, [[:word:]] - буква, цифра, подчеркивание.
//		\W - не буква, не цифра и не подчеркивание соответственно.
//		^ - начало текста, например "^\d+" - строка начинается с цифры.
//		$ - конец текста, например "\D+$" - строка заканчивается НЕ цифрой.
//		{m,n} - шаблон для от m до n символов, например "\d{2,4}" - от двух до четырех цифр. Можно указать одну цифру для строгого соответвия или цифру с запятой для только одной границы (от/до бесконечности).
//		\ - экранирует спецсимволы. Например, "\." - символ точки.
//		| - ИЛИ.
//		^ - НЕ, конец текста.
//		$ - начало текста.
//		\ - экранирует спецсимволы. Например, "\." - символ точки.
//		() - границы, приоритет - как в выражениях.
//		? - префикс - 0 или 1 повтор, суффикс - ленивого квантификатора (0*х найдёт в 0ААхх только 0ААх, но не 0ААхх).
//		?>ШАБЛОН - ищет шаблон "жадно". ?>(2*)5 не найдёт 2225, т.к. найдёт 2225 по шаблону 2*, после чего 5 уже занято. Работает быстрее.
//	По умолчанию - маска проверки даты "\d{2}\.\d{2}\.\d{4}"
//Возвращаемое значение - Булево - Строка соответствует шаблону или массив, если передан массив.
Функция ПроверитьСтроку(Строчка, Маска = "\d{2}\.\d{2}\.\d{4}", Тестер = Неопределено) Экспорт
	Если Тестер = Неопределено Тогда
		Тестер = ВОЛНА_ОбщегоНазначенияВС.ЗначениеXDTOдляПроВеркиСтроки(Маска)
	КонецЕсли;

	Результат = Новый Массив;
	Для каждого ТекЗначение Из ПреобразоватьВМассив(Строчка) Цикл
	    Попытка
	        Тестер.TestItem = Строчка;
	        Результат.Добавить(Истина);
	    Исключение
	        Результат.Добавить(Ложь);
	    КонецПопытки;
	КонецЦикла; 
	Возврат ?(Результат.Количество() = 1, Результат[0], Результат)
КонецФункции

// Возвращает строку всех символов заданной группы
// Параметры:
//  Группа  - Строка - вид символов:
//		*Цифры
//		*БуквыРЛ
//		*БуквыРус
//		*БуквыЛат
//		*БуквыЗагл
//		*БуквыСтр
//		*БуквыРЗагл
//		*БуквыРСтр
//		*БуквыЛЗагл
//		*БуквыЛСтр
//		*ДляПеременной1
//		*ДляПеременнойВсе
//		*СПиЦ - символ подчёркивания и цифры
//		*АрифметикаДействия
// Возвращаемое значение:
//   Строка   - Все символы группы
Функция СимволыГруппы(Группа) Экспорт
	Результат = "";
	Если Группа = "АрифметикаДействия" Тогда
		Результат = "+-*/:^%";
	Иначе
		Цифры = "0123456789";
		БРЗ = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
		БЛЗ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		БРС = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
		БЛС = "abcdefghijklmnopqrstuvwxyz";
		СимП = "_";
		Если Группа = "БуквыЗагл" Тогда
			Результат = БЛЗ + БРЗ;
		ИначеЕсли Группа = "БуквыЛат" Тогда
			Результат = БЛЗ + БЛС;
		ИначеЕсли Группа = "БуквыЛЗагл" Тогда
			Результат = БЛЗ;
		ИначеЕсли Группа = "БуквыЛСтр" Тогда
			Результат = БЛС;
		ИначеЕсли Группа = "БуквыРЗагл" Тогда
			Результат = БРЗ;
		ИначеЕсли Группа = "БуквыРЛ" Тогда
			Результат = БЛЗ + БЛС + БРЗ + БРС;
		ИначеЕсли Группа = "БуквыРСтр" Тогда
			Результат = БРС;
		ИначеЕсли Группа = "БуквыРус" Тогда
			Результат = БРЗ + БРС;
		ИначеЕсли Группа = "БуквыСтр" Тогда
			Результат = БЛС + БРС;
		ИначеЕсли Группа = "ДляПерем1Загл" Тогда
			Результат = СимП + БЛЗ + БРЗ;
		ИначеЕсли Группа = "ДляПерем1Стр" Тогда
			Результат = СимП + БЛС + БРС;
		ИначеЕсли Группа = "ДляПеременной1" Тогда
			Результат = СимП + БЛЗ + БЛС + БРЗ + БРС;
		ИначеЕсли Группа = "ДляПеремВсеЗагл" Тогда
			Результат = СимП + Цифры + БЛЗ + БРЗ;
		ИначеЕсли Группа = "ДляПеремВсеСтр" Тогда
			Результат = СимП + Цифры + БЛС + БРС;
		ИначеЕсли Группа = "ДляПеременнойВсе" Тогда
			Результат = СимП + Цифры + БЛЗ + БЛС + БРЗ + БРС;
		ИначеЕсли Группа = "СПиЦ" Тогда
			Результат = СимП + Цифры;
		ИначеЕсли Группа = "Цифры" Тогда
			Результат = Цифры;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // СимволыГруппы

// СтрЗаменить, но без учёта регистра
// Параметры:
//  ГдеМенять  - Строка - в котрой надо сделать замены, например, аБабА
//  ЧтоМенять  - Строка - которую надо найти и обезвредить, например, АБА
//  НаЧтоМенять  - Строка - Которая появится вместо искомой, например, АА
// Возвращаемое значение:
//   Строка   - с заменами, в примере - ААБА
Функция СтрЗаменитьБезУчётаРегистра(ГдеМенять, ЧтоМенять, НаЧтоМенять) Экспорт
	НачСтрока = ГдеМенять;
	Результат = "";
	ДлинаЧтоЗаменять = СтрДлина(ЧтоМенять);
	Пока Истина Цикл
		ПозВхождения = Найти(ВРег(НачСтрока), ВРег(ЧтоМенять));
		Если ПозВхождения = 0 Тогда
			Результат = Результат + НачСтрока;
			Прервать;
		КонецЕсли;
		Результат = Результат + Лев(НачСтрока, ПозВхождения - 1) + НаЧтоМенять;
		НачСтрока = Сред(НачСтрока, ПозВхождения + ДлинаЧтоЗаменять);
	КонецЦикла; 
	Возврат Результат;
КонецФункции // СтрЗаменитьБезУчётаРегистра()

//Преобразует строку представления в имя переменной
//заменой строчных букв с пробелом на заглавные
// Параметры:
//  Строка_  - Любое значение, преобразуемое в строку - Исходная строка;
// Возвращаемое значение:
//   Строка   - Строка без запретных символов и с заменой " символ" на ВРег(символ)
Функция СтрокуВИмяПеременной(Строка_) Экспорт
	Результат = "";
	Источник = Строка_;
	СтарДл = - 1;
	Пока Истина Цикл
		ТекДл = СтрДлина(Источник);
		Если ТекДл = СтарДл Тогда
			Прервать
		КонецЕсли;
		СтарДл = ТекДл;
		Источник = СтрЗаменить(Источник, "  ", " ");
	КонецЦикла; 
	Допустимые = СимволыГруппы("ДляПеременной1");
	ДопустимыеВсе = СимволыГруппы("ДляПеременнойВсе");
	ФлВРег = Истина;
	Для Ё = 1 По СтрДлина(Источник) Цикл
		ТекСимв = Сред(Источник, Ё, 1);
		Если Найти(?(Ё = 1, Допустимые, ДопустимыеВсе), ТекСимв) > 0 Тогда
			Результат = Результат + ?(ФлВРег, ВРег(ТекСимв), ТекСимв);
			ФлВРег = Ложь;
		Иначе
			ФлВРег = Истина;
		КонецЕсли;
	КонецЦикла; 
	Возврат Результат
КонецФункции

//Эта функция добавлена для совместимости. В новых версиях платформы без совместимости со старохламом есть одноимённая встроенная, тогда отсюда надо убрать
Функция СтрРазделить_(ЧтоДелим, Разделитель = ",", ВключатьПустые = Истина) Экспорт
	Хрюква = "/°|°\";
	ХрюкваР = "/°-|-°\";
	ИзувеченнаяСтрока = СтрЗаменить(СтрЗаменить(СтрЗаменить(ЧтоДелим, Разделитель, ХрюкваР), Символы.ПС, Хрюква), ХрюкваР, Символы.ПС);
	Результат = Новый Массив;
	Для Ё = 1 По СтрЧислоСтрок(ИзувеченнаяСтрока) Цикл
		ТекЗнч = СтрЗаменить(СтрПолучитьСтроку(ИзувеченнаяСтрока, Ё), Хрюква, Символы.ПС);
		Если ВключатьПустые ИЛИ НЕ ПустаяСтрока(ТекЗнч) Тогда
			Результат.Добавить(ТекЗнч);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // СтрРазделить()

//Эта функция добавлена для совместимости. В новых версиях платформы без совместимости со старохламом есть одноимённая встроенная, тогда отсюда надо убрать
Функция СтрСоединить_(ЧтоСоединяем, Разделитель = ",") Экспорт
	Результат = "";
	Для Ё = 0 По ЧтоСоединяем.ВГраница() Цикл
		Результат = Результат + Разделитель + ЧтоСоединяем[Ё]; 
	КонецЦикла; 
	Возврат Сред(Результат, СтрДлина(Разделитель) + 1)
КонецФункции // СтрРазделить()

// Преобразует текст в строковый литерал
// Параметры:
//  Текст_  - Строка - Произвольный текст
// Возвращаемое значение:
//   Строка   - Преобразованный текст: добавлены символы переноса, удвоены кавычки
Функция ТекстВЛитерал(Текст_) Экспорт
	Возврат СтрЗаменить(СтрЗаменить(Текст_, Символы.ПС, Символы.ПС + "|"), """", """""")
КонецФункции // ТекстВЛитерал
 
// Возвращает строку с разделителями без заданных элементов, например "Коля ,Вася , Галя", " Вася" = > "Коля,Галя"
// Лишние пробелы будут устранены.
// Параметры:
//	СтрокаСРазделителями- Любое значение, преобразуемое в строку - Исходная строка
//	УдаляемыеЭлементы	- Любое значение, преобразуемое в строку - удаляемые элементы с разделителями
//	Разделитель			- Любое значение, преобразуемое в строку - Разделитель, общий для СтрокаСРазделителями и УдаляемыеЭлементы
// Возвращаемое значение:
//	Строка   - строка с разделителями без указанных элементов
Функция УдалитьЭлементыИзСтрокиСРазделителями(СтрокаСРазделителями, УдаляемыеЭлементы, Разделитель = ",") Экспорт
	ЧтоУдалять = СтрЗаменить(УдаляемыеЭлементы, Разделитель, Символы.ПС);
	Результат = ИскоренитьПодстроку(ИскоренитьПодстроку(СтрокаСРазделителями,
			" " + Разделитель, Разделитель), Разделитель + " ", Разделитель);
	Для Ё = 1 По СтрЧислоСтрок(ЧтоУдалять) Цикл
		ЧтоМенять = СтрПолучитьСтроку(ЧтоУдалять, Ё);
		Результат = СтрЗаменить(Результат, ЧтоМенять + Разделитель, "");
		Результат = СтрЗаменить(Результат, Разделитель + ЧтоМенять, "");
		Если Результат = ЧтоМенять Тогда
			Результат = "";
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // УдалитьЭлементыИзСтрокиСРазделителями()

//Проверяет, подойдёт ли строчка для преобразования в УИД
// Параметры:
//  Строчка  - Любое значение, преобразуемое в строку - Проверяемая строка.
// Возвращаемое значение:
//   Булево   - Истина, если подходит для УИД. Считаются подходящими символами "-", 0-9, a-f, A-F.
Функция ЭтоУИД(Строчка) Экспорт
	Возврат ПроверитьСтроку(НРег(Строчка), "[0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f]-[0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f][0-f]");
КонецФункции // ЭтоУИД()
 
#КонецОбласти

#Область ФАЙЛОВАЯ_СИСТЕМА

//Выделяет расширение из полного имени файла
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - расширение файла (подстрока после последней точки)
Функция ПолучитьРасширение(Путь) Экспорт
	СпецСтрока = СтрЗаменить(Путь, ".", Символы.ПС);
	Возврат СтрПолучитьСтроку(СпецСтрока, СтрЧислоСтрок(СпецСтрока))
КонецФункции

//Получает из полного имени файла имя собственно файла (с расширением)
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - имя файла (подстрока после последнего разделителя пути)
Функция ИмяФайла(Путь) Экспорт
	#Если Клиент Тогда
		РП = ПолучитьРазделительПутиКлиента();
	#Иначе
		РП = ПолучитьРазделительПутиСервера();
	#КонецЕсли 
	СпецСтрока = СтрЗаменить(Путь, РП, Символы.ПС);
	Возврат СтрПолучитьСтроку(СпецСтрока, СтрЧислоСтрок(СпецСтрока))
КонецФункции

//Получает из полного имени файла имя каталога без завершающего слэша
//Параметры:
//	Путь - Строка - Полное имя файла
//Возвращаемое значение:
//	Строка - имя каталога (подстрока до последнего разделитля пути исключительно)
Функция ИмяКаталога(Путь) Экспорт
	Возврат Лев(Путь, СтрДлина(Путь) - СтрДлина(ИмяФайла(Путь)) - 1)
КонецФункции

//Переименовывает файл, добавляя к его старому имени префикс
//Параметры:
//	Имя - Строка - полное имя файла. Возвращается новое полное имя.
//	Префикс - Строка - добавляется к имени файла после пути к каталогу и разделителя пути.
Процедура ДобавитьПрефиксИмениФайла(Имя, Префикс)
	СтароеИмяФайла = ИмяФайла(Имя);
	НовоеИмя = Лев(Имя, СтрДлина(Имя) - СтрДлина(СтароеИмяФайла)) + Префикс + СтароеИмяФайла;
	ПереместитьФайл(Имя, НовоеИмя);
	Имя = НовоеИмя
КонецПроцедуры

//Получает файл из заданного пути, проверяет, зашифрован ли он, если нет - зашифровывает,
//Затем помещает в заданный каталог
//!!! Использует синхронные вызовы, ТРЕБУЕТ РЕФАКТОРИНГА
//Параметры:
//	ПутьОткудаВзять - Строка - Полный путь к исходному файлу
//	ПутьКудаСохранить - Строка - Имя каталога, куда будет сохранён под тем же именем зашифрованный файл.
//Возвращаемое значение:
//	Строка - при успешной зашифровке - новое имя файла, при неуспешной - пустая
Функция ЗашифроватьФайл(ПутьОткудаВзять, ПутьКудаСохранить) Экспорт
	ИмяФайла_ = "";
	КШифровке = Новый Файл(ПутьОткудаВзять);
	Если КШифровке.Существует() Тогда
		РазмерФайла = КШифровке.Размер();
		Если РазмерФайла > 9 Тогда
			Каталог = ПутьКудаСохранить;
			ИмяФайла_ = Каталог + ИмяФайла(ПутьОткудаВзять);
			Если ПутьОткудаВзять <> ИмяФайла_ Тогда
				Перезаписать = Ложь;
				КопироватьФайл(ПутьОткудаВзять, ИмяФайла_)
			КонецЕсли;
			РазмерЧасти = РазмерФайла - 9;
			МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
			ТекстСлава = Новый ТекстовыйДокумент;
			ТекстСлава.Прочитать(МассивФайлов[1], КодировкаТекста.ANSI);
			Строка_ = ТекстСлава.ПолучитьТекст();
			Зашифрован = Строка_ = "ВОЛНА2015";
			Если НЕ Зашифрован Тогда
				УдалитьФайлы(МассивФайлов[1]);
				УдалитьФайлы(МассивФайлов[0]);
				РазмерЧасти = Цел(РазмерФайла/2);
				МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
				//МассивФайлов.Добавить(ПолучитьИмяВременногоФайла());
				МассивФайлов.Добавить(МассивФайлов[0]);
				Колво = МассивФайлов.ВГраница();
				ЗаменитьКонецСтроки(МассивФайлов[Колво], "." + (Колво + 1));
				ТекстСлава = Новый ТекстовыйДокумент;
				ТекстСлава.УстановитьТекст("ВОЛНА2015");
				ТекстСлава.Записать(МассивФайлов[Колво], КодировкаТекста.ANSI);
				//Надо расставить файлы по именам 2-3-1-4
				ЗаменитьКонецСтроки(МассивФайлов[0], ".2");
				ЗаменитьКонецСтроки(МассивФайлов[1], ".3");
				ЗаменитьКонецСтроки(МассивФайлов[Колво - 1], ".1");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[0], "_");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[1], "___");
				//ДобавитьПрефиксИмениФайла(МассивФайлов[МассивФайлов.ВГраница() - 1], "__");
				ОбъединитьФайлы(МассивФайлов, ИмяФайла_);
			КонецЕсли;
			Для каждого Ё из МассивФайлов Цикл
				УдалитьФайлы(Ё)
			КонецЦикла
		КонецЕсли
	КонецЕсли;
	Возврат ИмяФайла_
КонецФункции

//Читает файл, расшифровывает его во временный, открывает
//!!! Использует синхронные вызовы, ТРЕБУЕТ РЕФАКТОРИНГА
//Параметры:
//	Путь - Строка - Путь к расщифровываемому файлу
//Возвращаемое значение:
//	Булево - Удалось открыть файл
Функция РасшифроватьФайл(Путь) Экспорт
	Результат = Ложь;
	КРасшифровке = Новый Файл(Путь);
	Если КРасшифровке.Существует() Тогда
		РазмерФайла = КРасшифровке.Размер();
		Если РазмерФайла > 11 Тогда
			ИмяФайла_ = ПолучитьИмяВременногоФайла(ПолучитьРасширение(Путь));
			КопироватьФайл(Путь,ИмяФайла_);
			РазмерЧасти = Окр((РазмерФайла - 9)/2);
			МассивФайлов = РазделитьФайл(ИмяФайла_, РазмерЧасти);
			ТекстСлава = Новый ТекстовыйДокумент;
			ТекстСлава.Прочитать(МассивФайлов[2], КодировкаТекста.ANSI);
			Строка_ = ТекстСлава.ПолучитьТекст();
			Зашифрован = Ложь;
			Если Строка_ = "ОЛНА2015" Тогда
				//нечёт
				ДопМассивФайлов = РазделитьФайл(МассивФайлов[1], РазмерЧасти - 1);
				ПереместитьФайл(ДопМассивФайлов[0], МассивФайлов[1]);
				УдалитьФайлы(ДопМассивФайлов[1]);
				УдалитьФайлы(ДопМассивФайлов[0]);
				//МассивФайлов[1] = ДопМассивФайлов[0];
				Зашифрован = Истина
			КонецЕсли;
			Зашифрован = Зашифрован ИЛИ (Строка_ = "ВОЛНА2015");
			УдалитьФайлы(МассивФайлов[2]);
			МассивФайлов.Удалить(2);
			//Файлы объединяются в порядке имён - имя второго надо "уменьшить"
			//ДобавитьПрефиксИмениФайла(МассивФайлов[1], "_");
			ЗаменитьКонецСтроки(МассивФайлов[1], ".1");
			ЗаменитьКонецСтроки(МассивФайлов[0], ".2");
			Если Зашифрован Тогда
				ОбъединитьФайлы(МассивФайлов, ИмяФайла_);
			КонецЕсли;
			УдалитьФайлы(МассивФайлов[1]);
			УдалитьФайлы(МассивФайлов[0]);
			ЗапуститьПриложение(ИмяФайла_);
			Результат = Истина;
		КонецЕсли
	КонецЕсли;
	Возврат Результат;
КонецФункции
 
//Передаёт файл из сетевого каталога на ФТП.
//Параметры:
//	ПолноеИмяФайлаИсточника - Строка - путь к файлу с каталогом
//	ИмяПроцесса - Строка - Имя события для записи в ЖР об ошибке
//	УдалитьИсточник - Булево - при Истина исходный файл удаляется.
//	ИмяФайлаПриёмника - Строка - Имя файла на ФТП относительно каталога, к которому идё т подключение (см.Сервер)
//	УстановленноеСоединение - соединение с ФТП - если Неопределено (по умолчанию) - будет создано новое.
//	FTPСервер - строка - адрес ФТП без ftp:\\. Этот и последующие параметры не нужны, если соединение установлено.
//	Порт - число - порт для подключения
//	Логин - Строка - Логин для подключения
//	Пароль - Строка - порт для подключения
//	ПассивноеСоединение - Булево - для подключения
Процедура ЗаписатьФайлНаFTP(ПолноеИмяФайлаИсточника, ИмяПроцесса = "Выгрузка на FTP", УдалитьИсточник, ИмяФайлаПриёмника,
		УстановленноеСоединение = Неопределено, FTPСервер = "", Порт = 21, Логин = "Guest", Пароль = "",
		Прокси = Неопределено, ПассивноеСоединение = Ложь) Экспорт
	FTPСоединение = ?(УстановленноеСоединение = Неопределено,
			Новый FTPСоединение(FTPСервер, Порт, Логин, Пароль, Прокси, ПассивноеСоединение), УстановленноеСоединение);
	Попытка 
		FTPСоединение.Записать(ПолноеИмяФайлаИсточника, ИмяФайлаПриёмника);	
		Если УдалитьИсточник Тогда
			УдалитьФайлы(ПолноеИмяФайлаИсточника);
		КонецЕсли; 
	Исключение
		ОО = ОписаниеОшибки();
		#Если Сервер Тогда
			ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ОО);
		#Иначе
			Сообщить("Ошибка записи файла  на ФТП:" + ОО);
		#КонецЕсли
	КонецПопытки;
КонецПроцедуры

//Передаёт файл с ФТП в сетевой каталог
//Параметры:
//	ПолноеИмяФайлаПриёмника - Строка - путь к файлу с каталогом
//	ИмяПроцесса - Строка - Имя события для записи в ЖР об ошибке
//	УдалитьИсточник - Булево - при Истина исходный файл удаляется.
//	ИмяФайлаИсточника - Строка - Имя файла на ФТП относительно каталога, к которому идё т подключение (см.Сервер)
//	УстановленноеСоединение - соединение с ФТП - если Неопределено (по умолчанию) - будет создано новое.
//	FTPСервер - строка - адрес ФТП без ftp:\\. Этот и последующие параметры не нужны, если соединение установлено.
//	Порт - число - порт для подключения
//	Логин - Строка - Логин для подключения
//	Пароль - Строка - порт для подключения
//	ПассивноеСоединение - Булево - для подключения
Процедура ПолучитьФайлСFTP(ПолноеИмяФайлаПриёмника, ИмяПроцесса = "Выгрузка на FTP", УдалитьИсточник, ИмяФайлаИсточника,
		УстановленноеСоединение = Неопределено, FTPСервер = "", Порт = 21, Логин = "Guest", Пароль = "",
		Прокси = Неопределено, ПассивноеСоединение = Ложь) Экспорт
	FTPСоединение = ?(УстановленноеСоединение = Неопределено,
			Новый FTPСоединение(FTPСервер, Порт, Логин, Пароль, Прокси, ПассивноеСоединение), УстановленноеСоединение);
	Попытка 	
		FTPСоединение.Получить(ИмяФайлаИсточника, ПолноеИмяФайлаПриёмника);
		Если УдалитьИсточник Тогда
			FTPСоединение.Удалить(ИмяФайлаИсточника);
		КонецЕсли; 
	Исключение
		ОО = ОписаниеОшибки();
		#Если Сервер Тогда
			ЗаписьЖурналаРегистрации(ИмяПроцесса, УровеньЖурналаРегистрации.Ошибка,,, ОО);
		#Иначе
			Сообщить("Ошибка записи файла  на ФТП:" + ОО);
		#КонецЕсли
	КонецПопытки;
КонецПроцедуры

// Возвращает существование файла по пути
// Параметры:
//  Путь  - Строка - Путь к предполагаемому файлу
// Возвращаемое значение:
//   Булево   - Существование файла
Функция ФайлСуществует(Путь) Экспорт
	Файл = Новый Файл(Путь);
	Результат = Файл.Существует();
	Возврат Результат
КонецФункции // ФайлСуществует

#КонецОбласти

#Область ТИПЫ

//Возвращает описание типов "любая ссылка"
//Параметры:
//	ВключитьСписокЗначений - Булево - При Истина (по умолчанию) результат включает список значений
//Возвращаемое значение:
//	Описание типов - любая ссылка + Булево + Дата + Число + Строка + (Опционально) Список значений
Функция ВсеСсылочныеИПростыеТипы(ВключитьСписокЗначений = Истина) Экспорт
	МассивТипов = Новый Массив();
	МассивТипов.Добавить(Тип("Строка"));
	МассивТипов.Добавить(Тип("Число"));
	МассивТипов.Добавить(Тип("Дата"));
	МассивТипов.Добавить(Тип("Булево"));
	Если ВключитьСписокЗначений Тогда
		МассивТипов.Добавить(Тип("СписокЗначений"));
	КонецЕсли; 
	Возврат Новый ОписаниеТипов(ВОЛНА_ОбщегоНазначения_ВСПовтИспСеанс.ВсеСсылочныеТипы(), МассивТипов,, Новый КвалификаторыЧисла(31, 7, ДопустимыйЗнак.Любой),
			Новый КвалификаторыСтроки(2000, ДопустимаяДлина.Переменная), Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя),
			Новый КвалификаторыДвоичныхДанных(2000, ДопустимаяДлина.Переменная));
КонецФункции // ВсеСсылочныеТипы()

//Создаёт "суммарное" описание типов из двух
//Параметры:
//	ОТ1 - Описание типов - слагаемое
//	ОТ2 - Описание типов - слагаемое
//Возвращаемое значение:
//	Описание типов - сумма
Функция ОбъединитьОписанияТипов(ОТ1, ОТ2) Экспорт
	ТипОТ = Тип("ОписаниеТипов");
	ОТ_Итог = Новый ОписаниеТипов;
	Если ТипЗнч(ОТ1) = ТипОТ Тогда
		Если ТипЗнч(ОТ2) = ТипОТ Тогда
			//ОТ2 = Новый ОписаниеТипов;
			//ОТ1 = Новый ОписаниеТипов;
			Менять = Ложь;
			Если ОТ1.КвалификаторыДаты.ЧастиДаты <> ОТ2.КвалификаторыДаты.ЧастиДаты Тогда
				КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
				Менять = Истина
			Иначе
				КвалификаторДаты = ОТ1.КвалификаторыДаты
			КонецЕсли;
			МенятьПрм1 = ОТ2.КвалификаторыДвоичныхДанных.Длина > ОТ1.КвалификаторыДвоичныхДанных.Длина;
			Размер = ?(МенятьПрм1, ОТ2.КвалификаторыДвоичныхДанных.Длина, ОТ1.КвалификаторыДвоичныхДанных.Длина);
			МенятьПрм2 = ((ОТ2.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная) И НЕ (ОТ1.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная));
			МенятьКвалификатор = МенятьПрм1 или МенятьПрм2;
			Менять = Менять Или МенятьКвалификатор;
			Если МенятьКвалификатор Тогда
				КвалификаторДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(Размер, ?(МенятьПрм2 или (ОТ2.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Переменная), ДопустимаяДлина.Переменная, ДопустимаяДлина.Фиксированная))
			Иначе
				КвалификаторДвоичныхДанных = ОТ1.КвалификаторыДвоичныхДанных
			КонецЕсли;
			МенятьПрм1 = ОТ2.КвалификаторыСтроки.Длина > ОТ1.КвалификаторыСтроки.Длина;
			Размер = ?(МенятьПрм1, ОТ2.КвалификаторыСтроки.Длина, ОТ1.КвалификаторыСтроки.Длина);
			МенятьПрм2 = ((ОТ2.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная)
					И НЕ (ОТ1.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная))
					ИЛИ (ОТ2.КвалификаторыСтроки.Длина <> ОТ1.КвалификаторыСтроки.Длина);
			МенятьКвалификатор = МенятьПрм1 или МенятьПрм2;
			Менять = Менять Или МенятьКвалификатор;
			Если МенятьКвалификатор Тогда
				КвалификаторСтроки = Новый КвалификаторыСтроки(Размер,
						?(МенятьПрм2 или (ОТ2.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная),
							ДопустимаяДлина.Переменная,
							ДопустимаяДлина.Фиксированная))
			Иначе
				КвалификаторСтроки = ОТ1.КвалификаторыСтроки
			КонецЕсли;
			МенятьПрм1 = ОТ1.КвалификаторыЧисла.Разрядность - ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти < ОТ2.КвалификаторыЧисла.Разрядность - ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			МенятьПрм2 = ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти < ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			ЗнакОТ2аЛюбой = (ОТ2.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой);
			ЗнакОТ1аЛюбой = (ОТ1.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой);
			МенятьКвалификатор = МенятьПрм1 или МенятьПрм2 или (ЗнакОТ2аЛюбой и НЕ ЗнакОТ1аЛюбой);
			Менять = Менять Или МенятьКвалификатор;
			Если МенятьКвалификатор Тогда
				РДЧ =?(МенятьПрм2, ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти, ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти); 
				КвалификаторЧисла = Новый КвалификаторыЧисла(
						?(МенятьПрм1, ОТ2.КвалификаторыЧисла.Разрядность - ОТ2.КвалификаторыЧисла.РазрядностьДробнойЧасти,
							ОТ1.КвалификаторыЧисла.Разрядность - ОТ1.КвалификаторыЧисла.РазрядностьДробнойЧасти) + РДЧ,
						РДЧ,
						?(ЗнакОТ2аЛюбой Или ЗнакОТ1аЛюбой, ДопустимыйЗнак.Любой, ДопустимыйЗнак.Неотрицательный))
			Иначе
				КвалификаторЧисла = ОТ1.КвалификаторыЧисла
			КонецЕсли;
			Типы = ОТ1.Типы();
			Для каждого Тип из ОТ2.Типы() Цикл
				Если Типы.Найти(Тип) = Неопределено Тогда
					Менять = Истина;
					Типы.Добавить(Тип)
				КонецЕсли
			КонецЦикла;
			Если Менять Тогда
				ОТ_Итог = Новый ОписаниеТипов(Типы, КвалификаторЧисла, КвалификаторСтроки, КвалификаторДаты, КвалификаторДвоичныхДанных)
			Иначе
				ОТ_Итог = ОТ1
			КонецЕсли
		Иначе
			ОТ_Итог = ОТ1;
		КонецЕсли;
	ИначеЕсли ТипЗнч(ОТ2) = ТипОТ Тогда
		ОТ_Итог = ОТ2;
	КонецЕсли;
	Возврат ОТ_Итог
КонецФункции //ОбъединитьОписанияТипов (ПодключитьОписаниеТипов)

//Возвращает объединённое описание типов всех значений коллекции
//Параметры:
//	Коллекция - Произвольная коллекция - по элементам которой будет формироваться описание типов
//Возвращаемое значение:
//	Описание типов - сумма
Функция ОписаниеТиповКоллекции(Коллекция) Экспорт
	Если Коллекция.Количество() = 0 Тогда
		Возврат ПолучитьОписаниеТипаЗначения(Неопределено)
	Иначе
		Результат = Неопределено;
		Для каждого Единица из Коллекция Цикл
			Результат = ОбъединитьОписанияТипов(Результат, ПолучитьОписаниеТипаЗначения(Единица))
		КонецЦикла;
		Возврат Результат
	КонецЕсли
КонецФункции

//Определяет ширину колонки для отображения типа. Для типов неопределённой длины берётся ширина 50.
//Параметры:
//	ОписаниеТипов - Описание типов - для которого требуется определить ширину колонки
//Первый параметр - описание типов, для этого описания определяется ширина.
//Возвращаемое значение:
//	Число - Ширина колонки
Функция ОпределитьШиринуКолонкиПоТипу(ОписаниеТипов) Экспорт
	Если ОписаниеТипов.КвалификаторыДаты = Неопределено	Тогда
		Ширина = 0
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда
		Ширина = 8
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
		Ширина = 10
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.ДатаВремя Тогда
		Ширина = 19
	Иначе
		Ширина = 0
	КонецЕсли;
	Если ОписаниеТипов.КвалификаторыДвоичныхДанных = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыДвоичныхДанных.Длина;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Если ОписаниеТипов.КвалификаторыСтроки = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыСтроки.Длина;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Если ОписаниеТипов.КвалификаторыЧисла = Неопределено	Тогда
		Ширина_ = 0
	Иначе
		Ширина_ = ОписаниеТипов.КвалификаторыЧисла.Разрядность;
		Если (Ширина_ = Неопределено) или (Ширина_ = 0) Тогда
			Ширина_ = 50
		КонецЕсли
	КонецЕсли;
	Ширина = ?(Ширина < Ширина_, Ширина_, Ширина);
	Для каждого Тип из ОписаниеТипов.Типы() Цикл
		Если Строка(Тип) = "Булево" Тогда
			Ширина_ = 2
		ИначеЕсли Строка(Тип) = "Null" Тогда
			Ширина_ = 4
		ИначеЕсли Строка(Тип) = "Неопределено" Тогда
			Ширина_ = 1
		ИначеЕсли Строка(Тип) = "Число" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Строка" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Дата" Тогда
			Ширина_ = 10
		ИначеЕсли Строка(Тип) = "Тип" Тогда
			Ширина_ = 24
		Иначе
			Ширина_ = СтрДлина(Строка(Новый(Тип)))
		КонецЕсли;
		Ширина = ?(Ширина < Ширина_, Ширина_, Ширина)
	КонецЦикла;
КонецФункции //ОпределитьШиринуКолонкиПоТипу

//Определяет тип значения и формирует описание типа по нему.
//Параметры:
//	Значение_ - Произвольный - по которому надо сформировать ОписаниеТипа
//Возвращаемое значение:
//	ОписаниеТипа - которому принадлежит заданное значение
Функция ПолучитьОписаниеТипаЗначения(Значение_) Экспорт
	Тип_ = ТипЗнч(Значение_);
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип_);
	Если Тип_ = Тип("Число") Тогда
		//Определить квалификатор числа
		ДоЗапятой = Макс(1, 1 + Цел(Log10(?(Значение_ > 0, Значение_, ?(Значение_ < 0, -Значение_, 1)))));
		ПослеЗапятой = СтрДлина(Значение_ - Цел(Значение_)) - 2;
		//Квалификатор_ = Новый КвалификаторыЧисла(ДоЗапятой, ПослеЗапятой, ?(Значение_ >= 0, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой));
		Квалификатор_ = Новый КвалификаторыЧисла(ДоЗапятой + ПослеЗапятой + 1, ПослеЗапятой, ?(Значение_ >= 0, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой));
		Возврат Новый ОписаниеТипов(МассивТипов, Квалификатор_)
	ИначеЕсли Тип_ = Тип("Строка") Тогда
		//Определить квалификатор строки
		//Квалификатор_ = Новый КвалификаторыСтроки(СтрДлина(Значение_), ДопустимаяДлина.Фиксированная);
		ТекДлина = СтрДлина(Значение_);
		Квалификатор_ = Новый КвалификаторыСтроки(?(ТекДлина = 0, 1, ТекДлина), ДопустимаяДлина.Фиксированная); //Чтобы нулевая длина не стала неограниченной
		Возврат Новый ОписаниеТипов(МассивТипов, , Квалификатор_)
	ИначеЕсли Тип_ = Тип("Дата") Тогда
		//Определить квалификатор даты
		Квалификатор_ = Новый КвалификаторыДаты(?((Час(Значение_) = 0) И (Минута(Значение_) = 0) И (Секунда(Значение_) = 0), ЧастиДаты.Дата,
				?((Год(Значение_) = 0) И (Месяц(Значение_) = 0) И (День(Значение_) = 0), ЧастиДаты.Время, ЧастиДаты.ДатаВремя)));
		Возврат Новый ОписаниеТипов(МассивТипов, , , Квалификатор_)
	ИначеЕсли Тип_ = Тип("ДвоичныеДанные") Тогда
		//Определить квалификатор двоичных данных
		Квалификатор_ = Новый КвалификаторыДвоичныхДанных(Значение_.Размер(), ДопустимаяДлина.Переменная);
		Возврат Новый ОписаниеТипов(МассивТипов, , , , Квалификатор_)
	Иначе
		Возврат Новый ОписаниеТипов(МассивТипов)
	КонецЕсли
КонецФункции

//Получает пустую ссылку по строке типа (результату метода ПолноеИмя)
//Параметры:
//	  ТипОбъекта - Строка - полное имя метаданных
//Возвращаемое значение:
//	  Ссылка - Пустая ссылка метаданных
Функция ПолучитьПустуюСсылкуТипа(ТипОбъекта) Экспорт
	СтрокаСсылки = СтрЗаменить(ТипОбъекта, ".", "Ссылка.");
	Возврат Новый(Тип(СтрокаСсылки)) 
КонецФункции //ПолучитьПустуюСсылкуТипа

// Возвращает примерное значение указанного типа. Для строки, даты  и числа это будет значение указанной квалификации, состоящее из единиц,
//		для ссылки - пустая ссылка, для остальных = приведение единицы к описанию типа.
// Параметры:
//	Источник  - Тип - Значение которого надо получить
//	КвалификаторЧисла  - КвалификаторыЧисла - Квалификатор типа
//	КвалификаторСтроки  - КвалификаторыСтроки - Квалификатор типа
//	КвалификаторДаты  - КвалификаторыДаты - Квалификатор типа
//	Строкой  - Булево - Представить значение в виде строки для текста запроса
// Возвращаемое значение:
//	Произвольный   - Примерное значение указанного типа
Функция ПримерноеЗначение(Источник, КвалификаторЧисла = "", КвалификаторСтроки = "", КвалификаторДаты = "", Строкой = Истина) Экспорт
	Результат = Новый Соответствие;
	Если Источник = Тип("Число") Тогда
		Если КвалификаторЧисла = "" ИЛИ КвалификаторЧисла.Разрядность = 0 Тогда
			Результат = 1;
		Иначе
			Результат = 0;
			Исходная = 1;
			Для ЁХ = 1 По КвалификаторЧисла.РазрядностьДробнойЧасти Цикл
				Исходная = Исходная / 10;
				Результат = Результат + Исходная;
			КонецЦикла;
			Исходная = 1;
			Для ЁХ = 1 По КвалификаторЧисла.Разрядность - КвалификаторЧисла.РазрядностьДробнойЧасти Цикл
				Результат = Результат + Исходная;
				Исходная = Исходная * 10;
			КонецЦикла;
			Если КвалификаторЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой Тогда
				Результат = - Результат;
			КонецЕсли;
		КонецЕсли;
		Если Строкой Тогда
			Результат = СтрЗаменить(ФОРМАТ(Результат, "ЧГ=0"), ",", ".");
		КонецЕсли;
	ИначеЕсли Источник = Тип("Булево") Тогда
		Если Строкой Тогда
			Результат = "ИСТИНА";
		Иначе
			Результат = Истина;
		КонецЕсли;
	ИначеЕсли Источник = Тип("Строка") Тогда
		Результат = "";
		Если КвалификаторСтроки <> "" Тогда
			Для ЁХ = 1 По КвалификаторСтроки.Длина Цикл
				Результат = Результат + "1";
			КонецЦикла;
		КонецЕсли;
		Если Строкой Тогда
			Результат = """" + Результат + """";
		КонецЕсли;
	ИначеЕсли Источник = Тип("Дата") ИЛИ Источник = Тип("СтандартнаяДатаНачала") ИЛИ Источник = Тип("СтандартныйПериод") Тогда
		Результат = '11111111111111';
		мТипов = Новый Массив;
		мТипов.Добавить(Тип("Дата"));
		ТекОТ = ?(КвалификаторСтроки = "", Новый ОписаниеТипов(мТипов), Новый ОписаниеТипов(мТипов,,, КвалификаторДаты));
		ИсхДата = ТекОТ.ПривестиЗначение(Результат);
		Если Источник = Тип("СтандартнаяДатаНачала") Тогда
			Результат = Новый СтандартнаяДатаНачала;
			Результат.Дата = ИсхДата;
			Если Строкой Тогда
				Результат = Неопределено;
			КонецЕсли;
		ИначеЕсли Источник = Тип("СтандартныйПериод") Тогда
			Результат = Новый СтандартныйПериод;
			Результат.ДатаНачала = ИсхДата;
			Результат.ДатаОкончания = ИсхДата;
			Если Строкой Тогда
				Результат = Неопределено;
			КонецЕсли;
		Иначе
			Результат = ИсхДата;
			Если Строкой Тогда
				ТекГод = Год(Результат);
				ТекМес = Месяц(Результат);
				ТекДень = День(Результат);
				ТекЧас = Час(Результат);
				ТекМин = Минута(Результат);
				ТекСек = Секунда(Результат);
				Результат = "ДАТАВРЕМЯ("
						+ ?(ТекГод = 0, 1, Формат(ТекГод, "ЧГ=0")) + "," +
						+ ?(ТекМес = 0, 1, ТекМес) + "," +
						+ ?(ТекДень = 0, 1, ТекДень) + "," +
						+ ?(ТекЧас = 0, 1, ТекЧас) + "," +
						+ ?(ТекМин = 0, 1, ТекМин) + "," +
						+ ?(ТекСек = 0, 1, ТекСек) + ")";
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если Строкой Тогда
			Результат = ВОЛНА_ОбщегоНазначенияВС.ИмяТаблицыОбъектаПоТипу(Источник);
			Если Результат = Неопределено Тогда
				Результат = "НЕОПРЕДЕЛЕНО";
			Иначе
				Результат = "ЗНАЧЕНИЕ(" + Результат + ".ПустаяСсылка)"
			КонецЕсли;
		Иначе
			мТипов = Новый Массив;
			мТипов.Добавить(Источник);
			ТекОТ = Новый ОписаниеТипов(мТипов);
			Результат = ТекОТ.ПривестиЗначение(1);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // ПримерноеЗначение

// Разбивает массив на несколько массивов однотипных значений, помещаемых в Соответствие
// Параметры:
//  ИсходныйМассив  - Массив - Массив разнотипных объектов
// Возвращаемое значение:
//   Соответствие   - ключи - типы, значения - массивы однотипных значений
Функция РазбитьПоТипам(ИсходныйМассив) Экспорт
	СоответствиеТипов = Новый Соответствие;
	Если ТипЗнч(ИсходныйМассив) = Тип("Массив") Тогда
		Для каждого Док Из ИсходныйМассив Цикл
			ТекТип = ТипЗнч(Док);
			Если СоответствиеТипов[ТекТип] = Неопределено Тогда
				СоответствиеТипов.Вставить(ТекТип, Новый Массив);
			КонецЕсли;
			СоответствиеТипов[ТекТип].Добавить(Док);
		КонецЦикла;
	Иначе
		СоответствиеТипов.Вставить(ТипЗнч(ИсходныйМассив), ПреобразоватьВМассив(ИсходныйМассив));
	КонецЕсли;
	Возврат СоответствиеТипов;
КонецФункции // РазбитьПоТипам()

//Возвращает булево, равен ли тип значения обозначенному строкой.
//Параметры:
//	 Значение - произвольный - проверяемое значение
//	 СтрокаОбозначенияТипа - Строка - строковое обозначение типа, например, СправочникСсылка.Банки
//Возвращаемое значение:
//	 Истина - тип значения совпадает с типом, полученным по строке
Функция ТипРавен(Значение, СтрокаОбозначенияТипа) Экспорт
	Результат = Ложь;
	Попытка
		Результат = ТипЗнч(Значение) = Тип(СтрокаОбозначенияТипа)
	Исключение
	КонецПопытки;
	Возврат Результат
КонецФункции //ТипРавен

#КонецОбласти

#Область ССЫЛКИ_УИДЫ
	
//Переводит строку ГУИД в УИД
//Параметры:
//	GUID_ - Строка - 32 значный ГУИД
//Возвращаемое значение:
//	Строка - в формате УникальныйИдентификатор (36 символов)
Функция GUIDToUUID(GUID_) Экспорт
 
 Возврат Прав(GUID_, 8) + "-" + Сред(GUID_, 21, 4) + "-" + Сред(GUID_, 17, 4) + "-" + Лев(GUID_, 4) + "-" + Сред(GUID_, 5, 12);
 
КонецФункции

//Переводит строку УИД в ГУИД
//Параметры:
//	UUID_ - Строка - в формате УникальныйИдентификатор (36 символов)
//Возвращаемое значение:
//	Строка - 32 значный ГУИД
Функция UUIDToGUID(UUID_) Экспорт
 
 Возврат Сред(UUID_, 20, 4) + Прав(UUID_, 12) + Сред(UUID_, 15, 4) + Сред(UUID_, 10, 4) + Лев(UUID_, 8);
 
КонецФункции

#КонецОбласти 

#Область РЕКВИЗИТЫ_ОБЪЕКТОВ
	
// Возращает, есть ли реквизит у объекта. При массивных данных в реквизите может притормозить выполнение.
// Параметры:
//  Реквизит  - Строка - Имя проверяемого реквизита
//  Объект  - Любое значение - Любое значение, имеющее реквизиты
// Возвращаемое значение:
//   Булево   - Истина, если реквизит есть.
Функция ЕстьРеквизитОбъекта(Реквизит, УКого) Экспорт
	ЛюбоеНедопустимоеЗначение = Новый УникальныйИдентификатор;
	Проверятель = Новый Структура(Реквизит, ЛюбоеНедопустимоеЗначение);
	ЗаполнитьЗначенияСвойств(Проверятель, УКого);
	Возврат Проверятель[Реквизит] <> ЛюбоеНедопустимоеЗначение
КонецФункции // ЕстьРеквизитОбъекта()

// Возращает структуру с информацией, есть ли реквизиты у объекта. При массивных данных в реквизитах может притормозить выполнение.
// Параметры:
//  Реквизиты  - Строка с разделеителем - Имена проверяемоых реквизитов
//  Объект  - Любое значение - Любое значение, имеющее реквизиты
// Возвращаемое значение:
//   Булево   - Истина, если реквизит есть.
Функция ЕстьРеквизитыОбъекта(Реквизиты, УКого) Экспорт
	ЛюбоеНедопустимоеЗначение = Новый УникальныйИдентификатор;
	Проверятель = Новый Структура(Реквизиты);
	Для каждого КиЗ Из Проверятель Цикл
		Проверятель.Вставить(КиЗ.Ключ, ЛюбоеНедопустимоеЗначение);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Проверятель, УКого);
	Для каждого КиЗ Из Проверятель Цикл
		Проверятель.Вставить(КиЗ.Ключ, КиЗ.Значение <> ЛюбоеНедопустимоеЗначение);
	КонецЦикла;
	Возврат Проверятель
КонецФункции // ЕстьРеквизитОбъекта()

// Получает значение реквизита объекта без ошибки, если реквизита нет.
// Параметры:
//  Источник  - Произвольный - Любой объект, который может быть источником для ЗаполнитьЗначенияСвойств
//  ИмяРеквизита  - Строка - Имя читаемого реквизита
//	ЕслиНеНайден - Произвольный - возвращаемое значение, если реквизит не найден. По умолчанию NULL.
//	ПолученноеЗначение - Произвольный - Переменная, куда будет возвращено значение (для запуска как процедуры). По умолчанию NULL.
// Возвращаемое значение:
//   Произвольный   - Значение указанного реквизита
Функция Получить(Источник, ИмяРеквизита, ЕслиНеНайден = NULL, ПолученноеЗначение = NULL) Экспорт
	Результат = Новый Структура(ИмяРеквизита, ЕслиНеНайден);
	ЗаполнитьЗначенияСвойств(Результат, Источник);
	Возврат Результат[ИмяРеквизита]
КонецФункции // Получить

// Сравнивает объекты пореквизитно (Истина - равны)
// Параметры:
//  Значение1  - Произвольное значение с реквизитами - Первый объект сравнения
//  Значение2  - Произвольное значение с реквизитами - Второй объект сравнения
//  МассивСвойств  - Массив строк - Имена реквизитов. Если не указан, предполагается, что первый объект - структура или соответствие, и сравнение идёт по его ключам
// Возвращаемое значение:
//   Булево   - Истина, если пореквизитное равенство
Функция ПореквизитноРавны(Значение1, Значение2, МассивСвойств = Неопределено) Экспорт
	Если МассивСвойств = Неопределено Тогда
		МассивСвойств = Новый Массив;
		Для каждого КиЗ Из Значение1 Цикл
			МассивСвойств.Добавить(КиЗ.Ключ);
		КонецЦикла; 
	КонецЕсли;
	Результат = Истина;
	Для каждого Имя Из МассивСвойств Цикл
		Если Значение1[Имя] <> Значение2[Имя] Тогда
			Результат = Ложь;
			Прервать
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // ПореквизитноРавны

#КонецОбласти 

#Область ТАБЛИЧНЫЙ_ДОКУМЕНТ
	
// Выводит картинку в табличный документ
// Параметры:
//  Приёмник  - Табличный документ - куда помещается картинка
//  Картинка_	- картинка или двоичные данные - источник картинки
//  Верх_  - Число - Координата размещения картинки. По умолчанию 0
//  Лево_  - Число - Координата размещения картинки. По умолчанию 0
//  Высота_  - Число - Размер картинки. По умолчанию 20
//  Ширина_  - Число - Размер картинки. По умолчанию 20
//  Узор  - ТипУзораТабличногоДокумента - Узор картинки. По умолчанию без узора.
//  Линия  - Линия - Линия картинки. По умолчанию НетЛинии
//  Прозрачность  - Булево - Прозрачность картинки. По умолчанию Истина
Процедура ВывестиКартинкуВТД(Приёмник, Картинка_ = Неопределено, Верх_ = 0, Лево_ = 0, Высота_ = 20, Ширина_ = 20, Узор = Неопределено, Линия = Неопределено, Прозрачность = Истина) Экспорт
	ТипКартинка = Тип("Картинка");
	ТипДД = Тип("ДвоичныеДанные");
	НовыйРисунок = Приёмник.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
	НовыйРисунок.Верх = Верх_;
	НовыйРисунок.Лево = Лево_;
	НовыйРисунок.Высота = Высота_;
	НовыйРисунок.Ширина = Ширина_;
	НовыйРисунок.Линия = ?(Линия = Неопределено, Новый Линия(ТипЛинииРисункаТабличногоДокумента.НетЛинии), Линия);
	НовыйРисунок.Узор = ?(Узор = Неопределено, ТипУзораТабличногоДокумента.БезУзора, Узор);
	ТекКартинка = ?(Картинка_ = Неопределено, Новый Картинка, Картинка_);
	ТипТК = ТипЗнч(ТекКартинка);
	Если ТипТК = ТипДД Тогда
		НовыйРисунок.Картинка = Новый Картинка(ТекКартинка, Прозрачность);
	ИначеЕсли ТипТК = ТипКартинка Тогда
		НовыйРисунок.Картинка = ТекКартинка;
	КонецЕсли;
КонецПроцедуры // ВывестиКартинкуВТД

// Устанавливает границу и заливку области табличного документа
// Параметры:
//  Область  - Область табличного документа - Редактируемые ячейки
//  Заливка  - Цвет - устанавливаемый цвет фона. По умолчанию Наопределено - не устанавливается
//  ЦветРамки  - Цвет - устанавливаемый цвет рамки. По умолчанию Наопределено - не устанавливается
//  ЛинииРамки  - Линия, структура - Линия уставнавливается для всех границ, Структура может содержать поля "Лево", "Право", "Верх", "Низ" и/или "ГраницаСверху", "ГраницаСлева", "ГраницаСнизу" или "ГраницаСправа"
Процедура ГраницыИЗаливка(Область, Заливка = Неопределено, ЦветРамки = Неопределено, ЛинииРамки = Неопределено) Экспорт
				Если Заливка <> Неопределено Тогда
					Область.ЦветФона = Заливка;
				КонецЕсли;
				Если ЦветРамки <> Неопределено Тогда
					Область.ЦветРамки = ЦветРамки;
				КонецЕсли;
				Если ЛинииРамки = Неопределено Тогда
				ИначеЕсли ТипЗнч(ЛинииРамки) = Тип("Линия") Тогда
					Область.ГраницаСверху = ЛинииРамки;
					Область.ГраницаСлева = ЛинииРамки;
					Область.ГраницаСнизу = ЛинииРамки;
					Область.ГраницаСправа = ЛинииРамки;
				Иначе
					ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСверху", ЧтСтрукт(ЛинииРамки, "Верх"));
					Если ТекЦвет <> Неопределено Тогда
						Область.ГраницаСверху = ТекЦвет;
					КонецЕсли;
					ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСправа", ЧтСтрукт(ЛинииРамки, "Право"));
					Если ТекЦвет <> Неопределено Тогда
						Область.ГраницаСправа = ТекЦвет;
					КонецЕсли;
					ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСнизу", ЧтСтрукт(ЛинииРамки, "Низ"));
					Если ТекЦвет <> Неопределено Тогда
						Область.ГраницаСнизу = ТекЦвет;
					КонецЕсли;
					ТекЦвет = ЧтСтрукт(ЛинииРамки, "ГраницаСлева", ЧтСтрукт(ЛинииРамки, "Лево"));
					Если ТекЦвет <> Неопределено Тогда
						Область.ГраницаСлева = ТекЦвет;
					КонецЕсли;
				КонецЕсли;
КонецПроцедуры // ГраницыИЗаливка

// Ищет в составе табличного документа дату и возвращает её
// Параметры:
//  ТабДок  - Табличный документ - в котором ищется дата
//  НомерВхождения  - Число - Номер вхождения даты от начала документа. Чтение идёт построчно слева направо.
//  ВернутьСтрокой  - Булево - Тип возвращаемого значения. Ложь (по умолчанию) - дата, иначе - строка.
//  ВЗначениях  - Булево - Необходимость поиска в значениях ячеек.
//  ВТексте  - Булево - Необходимость поиска в текстах ячеек.
//  Форматы  - Массив тестеров, сформированных функцией ЗначениеXDTOдляПроВеркиСтроки - Формат даты, только в этом формате будет искаться дата в тексте. По умолчанию - неопределено - в форматах dd.mm.yyyy, dd month yyyy и month yyyy.
//  Верх  - Число - Верх области поиска, по умолчанию - 1
//  Низ  - Число - Низ области поиска, по умолчанию - нижняя строка ТД
//  Право  - Число - Номер крайней левой колонки области поиска, по умолчанию - 1
//  Лево  - Число - Номер крайней правой колонки области поиска, по умолчанию - правая колонка ТД
// Возвращаемое значение:
//   Дата, Строка   - Найденная в документе дата. Пустая, если ничего не найдено. Если найдена строка, которую невозможно преобразовать в дату, вернётся строка, даже если указано вернуть дату.
Функция ДатаИзТД(ТабДок, ВернутьСтрокой = Ложь, НомерВхождения = 1, ВЗначениях = Истина, ВТексте = Истина, Форматы = Неопределено, Знач Верх = 1, Знач Низ = 0, Знач Лево = 1, Знач Право = 0) Экспорт
	Результат = ?(ВернутьСтрокой, "", '00000000');
	СчётчикВхождений = НомерВхождения;
	Если Низ = 0 Тогда
		Низ = ТабДок.ВысотаТаблицы;
	КонецЕсли; 
	Если Право = 0 Тогда
		Право = ТабДок.ШиринаТаблицы;
	КонецЕсли; 
	Если Верх = 0 Тогда //Бесконечные области!!!
		Верх = 1;
	КонецЕсли; 
	Если Лево = 0 Тогда
		Лево = 1;
	КонецЕсли; 
	ЭтоТиповыеФорматы = Ложь;
	Если Форматы = Неопределено Тогда
		СтрокиФорматов = Новый Массив;
		СтрокиФорматов.Добавить(".*\d{2}\.\d{2}\.\d{4}.*");
		СтрокиФорматов.Добавить(".*\d{1,2}\s+((Я|я)нваря|(Ф|ф)евраля|(М|м)арта|(М|м)ая|(А|а)преля|(И|и)ю(н|л)я|(А|а)вгуста|(С|с)ентября|(О|о)ктября|(Н|н)оября|(Д|д)екабря)\s+\d{4}.*");
		СтрокиФорматов.Добавить(".*\s+((Я|я)нварь|(Ф|ф)евраль|(М|м)арт|(М|м)ай|(А|а)прель|(И|и)ю(н|л)ь|(А|а)вгуст|(С|с)ентябрь|(О|о)ктябрь|(Н|н)оябрь|(Д|д)екабрь)\s+\d{4}.*");
		Форматы = Новый Массив;
		Для каждого СтрочкаФ Из СтрокиФорматов Цикл
			Форматы.Добавить(ВОЛНА_ОбщегоНазначенияВС.ЗначениеXDTOдляПроВеркиСтроки(СтрочкаФ));
		КонецЦикла; 
		ЭтоТиповыеФорматы = Истина;
	КонецЕсли;
	#Область ПОИСК
		Для СчСтр = Верх По Низ Цикл
			Найдена = Неопределено;
			Для СчКол = Лево По Право Цикл
				Ячейка = ТабДок.Область(СчСтр, СчКол);
				Если ВЗначениях И Ячейка.СодержитЗначение Тогда
					Если ТипЗнч(Ячейка.Значение) = Тип("Дата") Тогда
						Найдена = Ячейка.Значение;
					КонецЕсли; 
				КонецЕсли;
				Если (Найдена = Неопределено) И ВТексте И НЕ Ячейка.СодержитЗначение Тогда
					ТекТекст = Ячейка.Текст;
					Для СчМ = 0 По Форматы.ВГраница() Цикл
						Если ПроверитьСтроку(ТекТекст,, Форматы[СчМ]) Тогда
							Найдена = СчМ;
						КонецЕсли; 
					КонецЦикла; 
				КонецЕсли; 
				Если Найдена <> Неопределено Тогда
					СчётчикВхождений = СчётчикВхождений - 1;
				КонецЕсли; 
				Если СчётчикВхождений = 0 Тогда
					СчСтр = Низ;
					Прервать;
				КонецЕсли; 
			КонецЦикла; 
		КонецЦикла;
	#КонецОбласти 
	//Теперь в Найдена либо сама дата, либо номер формата, по которому найдена строка
	#Область ВЫДЕЛЕНИЕ_ДАТЫ_ИЗ_ДЛИННОЙ_СТРОКИ_И_ПРЕОБРАЗОВАНИЕ_ФОРМАТА
		Если Найдена <> Неопределено Тогда
			ЭтоЧисло = ТипЗнч(Найдена) = Тип("Число");
			Если ЭтоТиповыеФорматы и ЭтоЧисло Тогда
				//Попытка вытащить дату из текста.
				ФорматНачало = ВОЛНА_ОбщегоНазначенияВС.ЗначениеXDTOдляПроВеркиСтроки(Сред(СтрокиФорматов[Найдена], 3));
				ФорматОк = ВОЛНА_ОбщегоНазначенияВС.ЗначениеXDTOдляПроВеркиСтроки(Сред(СтрокиФорматов[Найдена], 3, СтрДлина(СтрочкаФ) - 4));
				ДлТхт = СтрДлина(ТекТекст);
				Ок = Ложь;
				Для СчНач = 1 По ДлТхт Цикл
					Если ПроверитьСтроку(Сред(ТекТекст, СчНач),, ФорматНачало) Тогда
						Ок = Истина;
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				Если Ок Тогда
					Ок = Ложь;
					Для СчДл = 1 По ДлТхт - СчНач + 1 Цикл
						ТекстВЦикле = Сред(ТекТекст, СчНач, СчДл);
						Если ПроверитьСтроку(ТекстВЦикле,, ФорматОк) Тогда
							Ок = Истина;
							Прервать;
						КонецЕсли; 
					КонецЦикла; 
					Если Ок Тогда
						ТекТекст = ТекстВЦикле;
					КонецЕсли; 
				КонецЕсли; 
				Если НЕ ВернутьСтрокой Тогда
					//Попытка преобразовать в дату
					ДатаХ = ДатаИзСтроки(ТекТекст, Истина);
					Если ДатаХ <> Неопределено Тогда
						Найдена = ДатаХ;
						ЭтоЧисло = Ложь;
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли;
			Если ВернутьСтрокой И НЕ ЭтоЧисло Тогда
				//Преобразование даты в строку
				ТекТекст = Формат(Найдена, "ДФ=dd.MM.yyyy");
				ЭтоЧисло = Истина;
			КонецЕсли;
			Если ЭтоЧисло Тогда
				Результат = ТекТекст;
			Иначе
				Результат = Найдена;
			КонецЕсли; 
		КонецЕсли;
	#КонецОбласти 
	Возврат Результат
КонецФункции // ДатаИзТД

// Выполняет замены текста в табличном документе
// Параметры:
//  ТабДок  - Табличный документ - в котором будут замены текста
//  Замены  - Таблица значений или массив структур - с колонками ЧтоМенять и НаЧтоМенять
//  Верх  - Число - Верх изменяемой области, по умолчанию - 1
//  Низ  - Число - Низ изменяемой области, по умолчанию - нижняя строка ТД
//  Право  - Число - Номер крайней левой колонки изменяемой области, по умолчанию - 1
//  Лево  - Число - Номер крайней правой колонки изменяемой области, по умолчанию - правая колонка ТД
Процедура ЗаменитьТекстыВТД(ТабДок, Замены, Знач Верх = 1, Знач Низ = 0, Знач Лево = 1, Знач Право = 0, ИскатьПоСтрокам = Истина, ЯчейкаЦеликом = Ложь, ИскатьВперед = Истина, ИгнорироватьРегистр = Ложь) Экспорт
	Если Низ = 0 Тогда
		Низ = ТабДок.ВысотаТаблицы;
	КонецЕсли; 
	Если Право = 0 Тогда
		Право = ТабДок.ШиринаТаблицы;
	КонецЕсли; 
	Если Верх = 0 Тогда //Бесконечные области!!!
		Верх = 1;
	КонецЕсли; 
	Если Лево = 0 Тогда
		Лево = 1;
	КонецЕсли; 
	#Область НОВЫЙ_ВАРИАНТ
		Обыскиваемая = ТабДок.Область(Верх, Лево, Низ, Право);
		Начало = Неопределено;//ТабДок.Область(Верх, Лево);
		БылТП = ТабДок.ТолькоПросмотр;
		Для каждого СтрЗамен Из Замены Цикл
			НачалоПоЗамене = Начало;
			Пока Истина Цикл
				НачалоПоЗамене = ТабДок.НайтиТекст(СтрЗамен.ЧтоМенять, НачалоПоЗамене, Обыскиваемая, ИскатьПоСтрокам, ЯчейкаЦеликом, ИскатьВперед, ИгнорироватьРегистр);
				Если НачалоПоЗамене = Неопределено Тогда
					Прервать
				КонецЕсли;
				НачалоПоЗамене.Текст = СтрЗаменить(НачалоПоЗамене.Текст, СтрЗамен.ЧтоМенять, СтрЗамен.НаЧтоМенять);
			КонецЦикла;
		КонецЦикла;
		Если БылТП Тогда
			ТабДок.ТолькоПросмотр = Истина;
		КонецЕсли; 
	#КонецОбласти 
	#Область СТАРЫЙ_ВАРИАНТ
		//Для СчСтр = Верх По Низ Цикл
		//	Для СчКол = Лево По Право Цикл
		//		ТекТекст = Строка(ТабДок.Область(СчСтр, СчКол).Текст);
		//		СтарыйТекст = ТекТекст;
		//		Для каждого СтрЗамен Из Замены Цикл
		//			ТекТекст = СтрЗаменить(ТекТекст, СтрЗамен.ЧтоМенять, СтрЗамен.НаЧтоМенять);
		//		КонецЦикла;
		//		Если СтарыйТекст <> ТекТекст Тогда
		//			БылТП = ТабДок.ТолькоПросмотр;
		//			ТабДок.ТолькоПросмотр = Ложь;
		//			ТабДок.Область(СчСтр, СчКол).Текст = ТекТекст;
		//			Если БылТП Тогда
		//				ТабДок.ТолькоПросмотр = Истина;
		//			КонецЕсли; 
		//		КонецЕсли; 
		//	КонецЦикла; 
		//КонецЦикла; 
	#КонецОбласти
КонецПроцедуры // ЗаменитьТекстыВТД

//Возвращает реквизиты табличного документа, доступные для записи
Функция ИзменяемыеРеквизитыТД() Экспорт
	//В УП было:
	//АвтоМасштаб,Вывод,ДвусторонняяПечать,Защита,ИмяПараметровПечати,ИмяПринтера,ИспользуемоеИмяФайла,КоличествоЭкземпляров,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,ОтображатьСетку,
	//ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ЧерноБелаяПечать,ЧерноБелыйПросмотр,
	//ЭкземпляровНаСтранице,РазмерКолонтитулаСнизу,РазмерКолонтитулаСверху
	//Копируются:
	//АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,ИмяПараметровПечати,КлючПараметровПечати,КлючСохраненияПоложенияОкна,
	//	КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,
	//	ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,
	//	ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы.
	//НЕ копируются:
	//ВерхнийКолонтитул,ВстроенныеТаблицы,ВыделенныеОбласти,ВысотаТаблицы,НижнийКолонтитул,Области,Параметры,Рисунки,ЧередованиеРасположенияСтраниц,ШиринаТаблицы.
	//Преднамеренно НЕ копируются:
	//ИмяПринтера,ИспользуемоеИмяФайла,ОбластьПечати,ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ТекущаяОбласть.
	Копируемые = "ИмяПараметровПечати,АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,КлючПараметровПечати,КлючСохраненияПоложенияОкна,";
	Копируемые = Копируемые + "КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,";
	Копируемые = Копируемые + "ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,";
	Копируемые = Копируемые + "ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы";
	//ИмяПараметровПечати (оно же КлючПараметровПечати) обязательно первым!
	Возврат Копируемые
КонецФункции // РеквизитыНастроекТД()

// Возвращает строку и столбец первой ячейки со значением или текстом
// Параметры:
//  ТаблДокумент  - Табличный документ - В котором ищем
//  МетодПоиска  - Строка - "ПоКолнкам" (по умолчанию), "ПоСтрокам" или "Радиально"
//  Строк  - Число - Сколько строк проверять. По умолчанию 10.
//  Колонок  - Число - Сколько колонок проверять. По умолчанию 10.
//  НачСтрока  - Число - С какой строки табдокумента проверять. По умолчанию 1.
//  НачКолонка  - Число - С какой колонки табдокумента проверять. По умолчанию 1.
// Возвращаемое значение:
//   Структура   - Ключи Строка, Столбец, Значение, Текст
Функция ПерваяЯчейка(ТаблДокумент, МетодПоиска = "ПоКолонкам", Строк = 10, Колонок = 10, НачСтрока = 1, НачКолонка = 1) Экспорт
	Результат = Новый Структура("Строка,Колонка,Текст,Значение", 0);
	ЭтоРадиально = МетодПоиска = "Радиально";
	ЭтоНеПоКолонкам = МетодПоиска = "ПоСтрокам" ИЛИ ЭтоРадиально;
	Ширина = ?(Колонок = 0, ТаблДокумент.ШиринаСтраницы - НачКолонка + 1, Колонок);
	Высота = ?(Строк = 0, ТаблДокумент.ВысотаСтраницы - НачСтрока + 1, Строк);
	КонРадиус = Макс(Ширина, Высота); //если по строкам - высота
	НачРадиус = ?(ЭтоНеПоКолонкам, 1, КонРадиус);
	Для Радиус = НачРадиус По КонРадиус Цикл
		КонКол = ?(ЭтоРадиально, Мин(Ширина, Радиус), Ширина);
		Для НомКол = НачКолонка По КонКол + НачКолонка - 1 Цикл
			Если ЭтоНеПоКолонкам И НЕ (ЭтоРадиально И НомКол = Радиус) Тогда
				НачСтр = Радиус + НачСтрока - 1;
				КонСтр = НачСтр;
			Иначе
				НачСтр = НачСтрока;
				КонСтр = Высота + НачСтрока - 1;
			КонецЕсли;
			Для НомСтр = НачСтр По КонСтр Цикл
				ТекОбласть = ТаблДокумент.Область(НомСтр, НомКол);
				ТекТекст = ТекОбласть.Текст;
				ТекЗнч = ?(ТекОбласть.СодержитЗначение, ТекОбласть.Значение, Неопределено);
				Если ЗначениеЗаполнено(ТекТекст) ИЛИ ЗначениеЗаполнено(ТекЗнч) Тогда
					Результат.Вставить("Строка", НомСтр);
					Результат.Вставить("Колонка", НомКол);
					Результат.Вставить("Текст", ТекТекст);
					Результат.Вставить("Значение", ТекЗнч);
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	Возврат Результат
КонецФункции // ПерваяЯчейка

//Получает значение из области в структуру или иной аналогичный объект. Не распознаёт ссылки, из строк убирает одиночный апостроф.
//Параметры:
//	Приёмник 			- Структура - Объект-приёмник
//	РеквизитПриёмника	- Строка - Имя реквизита, куда будет помещено значение
//	Источник			- Табличный документ - Откуда будет считано значение
//	НомерСтроки			- Число - Номер строки ячейки, из которой будет считано значение
//	НомерКолонки		- Число - Номер колонки ячейки, из которой будет считано значение
//	ТипДанных			- Строка - Тип данных, к оторому будет приведено значение (Булево/Строка/Число)
Процедура ПолучитьИзОбласти(Приёмник, РеквизитПриёмника, Источник, НомерСтроки, НомерКолонки, ТипДанных = "Строка") Экспорт
	ТДата = ТекущаяДата();
	Если НомерКолонки = 0 Тогда
		Если ТипДанных = "Строка" Тогда
			Приёмник[РеквизитПриёмника] = "";
		ИначеЕсли ТипДанных = "Число" Тогда
			Приёмник[РеквизитПриёмника] = 0;
		ИначеЕсли ТипДанных = "Дата" Тогда
			Приёмник[РеквизитПриёмника] = ТДата;
		Иначе //Булево
			Приёмник[РеквизитПриёмника] = Ложь;
		КонецЕсли; 
	Иначе
		ТекОбласть = Источник.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		НадоПриводитьКФормату = НЕ ТекОбласть.СодержитЗначение;
		Если НадоПриводитьКФормату И (ТипДанных <> "Строка") Тогда
			ТекстОбласти = ТекОбласть.Текст;
			Если ТипДанных = "Дата" Тогда
				//Из форматов "1.3.75" и "750301"
				ТекСтрока = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(ТекстОбласти,
						".", Символы.ПС), "/", Символы.ПС), "-", Символы.ПС), "\", Символы.ПС), " ", Символы.ПС), ":", Символы.ПС);
				Если СтрЧислоСтрок(ТекСтрока) = 1 Тогда
					Век = Лев(ТекСтрока, 2);
					Если (Век <> "19") ИЛИ (Век <> "20") Тогда
						ТекСтрока = "20" + ТекСтрока;
					КонецЕсли; 
					Попытка
						НовоеЗначение = Дата(Число(Лев(ТекСтрока, 4)), Число(Сред(ТекСтрока, 5, 2)), Число(Сред(ТекСтрока, 7, 2)), Число(Сред(ТекСтрока, 9, 2)), Число(Сред(ТекСтрока, 11, 2)), Число(Прав(ТекСтрока, 2)));
					Исключение
						НовоеЗначение = ТДата;
					КонецПопытки;
				Иначе
					Попытка
						ТГод = СтрПолучитьСтроку(ТекСтрока, 3);
						Если ТГод = "" Тогда
							ТГод = "0"
						ИначеЕсли СтрДлина(ТГод) = 2 Тогда
							ТГод = "20" + ТГод;
						КонецЕсли; 
						НовоеЗначение = Дата(Число(ТГод),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 2), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 1), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 4), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 5), "", "0")),
								Число(ЕслиПервоеВтороеРавныТоТретьеИначеПервое(СтрПолучитьСтроку(ТекСтрока, 6), "", "0")));
					Исключение
						НовоеЗначение = ТДата;
					КонецПопытки;
				КонецЕсли; 
			ИначеЕсли ТипДанных = "Булево" Тогда
				ВРег_ = ВРЕГ(ТекстОбласти);
				НовоеЗначение = НЕ ((ВРег_ = "ЛОЖЬ") ИЛИ (ВРег_ = "НЕТ") ИЛИ ПустаяСтрока(ВРег_) ИЛИ (ВРег_ = "0"));
			Иначе //Число
				Попытка
					НовоеЗначение = Число(ТекстОбласти);
				Исключение
					НовоеЗначение = 0;
				КонецПопытки;
			КонецЕсли;
			Приёмник[РеквизитПриёмника] = НовоеЗначение;
		Иначе
			Приёмник[РеквизитПриёмника] = ?(НадоПриводитьКФормату, ТекОбласть.Текст, ТекОбласть.Значение);
		КонецЕсли; 
		Если ТипЗнч(Приёмник[РеквизитПриёмника]) = Тип("Строка") Тогда
			Приёмник[РеквизитПриёмника] = СокрЛП(Приёмник[РеквизитПриёмника]);
			Если Лев(Приёмник[РеквизитПриёмника], 1) = "'" Тогда
				Приёмник[РеквизитПриёмника] = Сред(Приёмник[РеквизитПриёмника], 2);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
КонецПроцедуры

// Копирует параметры документа - источника в документ-приёмник. При отсутствии приёмника создаётся новый документ.
// Параметры:
//  Приёмник  - Табличный документ - тот, в который будут скопированы параметры
//  Источник  - Табличный документ или иной объект - тот, из которого будут скопированы параметры
//  ИсключаемыеСвойства  - Строка - Список свойств через запятую, которые не будут копироваться
// Возвращаемое значение:
//   Табличный документ   - Приёмник с параметрами источника
Функция СкопироватьПараметрыТД(Приёмник = Неопределено, Источник, ИсключаемыеСвойства = "") Экспорт
	Результат = ?(Приёмник = Неопределено, Новый ТабличныйДокумент, Приёмник);
	//В УП было:
	//АвтоМасштаб,Вывод,ДвусторонняяПечать,Защита,ИмяПараметровПечати,ИмяПринтера,ИспользуемоеИмяФайла,КоличествоЭкземпляров,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,ОтображатьСетку,
	//ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ЧерноБелаяПечать,ЧерноБелыйПросмотр,
	//ЭкземпляровНаСтранице,РазмерКолонтитулаСнизу,РазмерКолонтитулаСверху
	//Копируются:
	//АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,ИмяПараметровПечати,КлючПараметровПечати,КлючСохраненияПоложенияОкна,
	//	КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,
	//	ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,
	//	ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы.
	//НЕ копируются:
	//ВерхнийКолонтитул,ВстроенныеТаблицы,ВыделенныеОбласти,ВысотаТаблицы,НижнийКолонтитул,Области,Параметры,Рисунки,ЧередованиеРасположенияСтраниц,ШиринаТаблицы.
	//Преднамеренно НЕ копируются:
	//ИмяПринтера,ИспользуемоеИмяФайла,ОбластьПечати,ПовторятьПриПечатиКолонки,ПовторятьПриПечатиСтроки,ТекущаяОбласть.
	Копируемые = "ИмяПараметровПечати,АвтоМасштаб,Вывод,ВысотаСтраницы,ДвусторонняяПечать,Защита,ИтогиСнизу,ИтогиСправа,КлючПараметровПечати,КлючСохраненияПоложенияОкна,";
	Копируемые = Копируемые + "КодЯзыка,КоличествоЭкземпляров,Макет,МасштабПечати,НаправлениеПерехода,НомерПервойСтраницы,ОриентацияСтраницы,ОтображатьГруппировки,ОтображатьЗаголовки,";
	Копируемые = Копируемые + "ОтображатьСетку,ПолеСверху,ПолеСлева,ПолеСнизу,ПолеСправа,РазборПоКопиям,РазмерКолонтитулаСверху,РазмерКолонтитулаСнизу,РазмерСтраницы,СохранятьСвойстваОтображения,";
	Копируемые = Копируемые + "ТолькоПросмотр,ТочностьПечати,ФиксацияСверху,ФиксацияСлева,ФиксированныйФон,ФоноваяКартинка,ЧерноБелаяПечать,ЧерноБелыйПросмотр,ШиринаСтраницы";
	ТМПСтр = Новый Структура(Копируемые);//Чтобы отсеять реквизиты, кроме указанных
	ЗаполнитьЗначенияСвойств(ТМПСтр, Результат);
	Если ИсключаемыеСвойства = "" Тогда
		ЗаполнитьЗначенияСвойств(ТМПСтр, Источник);
	Иначе
		ЗаполнитьЗначенияСвойств(ТМПСтр, Источник,, ИсключаемыеСвойства);
	КонецЕсли; 
	Копируемые = СтрЗаменить(Копируемые, ",", Символы.ПС);
	//А вот фиг бы я угадал, это не работает!!! ("Двусторонняя печать ваще не копируется, полный игнор"!) !ИмяПараметровПечати всё перезатирает!
	//ЗаполнитьЗначенияСвойств(Результат, Источник, Копируемые);
	Для Ё = 1 По СтрЧислоСтрок(Копируемые) Цикл
		ИмяРекв = СтрПолучитьСтроку(Копируемые, Ё);
		Результат[ИмяРекв] = ТМПСтр[ИмяРекв];
	КонецЦикла; 
	Возврат Результат
КонецФункции // СкопироватьПараметрыТД
 
// Возвращает список областей табличного документа
// Параметры:
//  ТабДок  - Табличный документ - имена областей которого будут выведены в список
//	СтрокаМассивСписок - Строка - "Строка", "Массив" или "Список" - тип возвращаемого значения
// Возвращаемое значение:
//   СписокЗначений, Массив или строка   - Список областей ТД
Функция СписокОбластейТД(ТабДок, СтрокаМассивСписок = "Строка") Экспорт
	Если СтрокаМассивСписок = "Массив" Тогда
		Результат = Новый Массив;
		Для каждого Область Из ТабДок.Области Цикл
			Результат.Добавить(Область.Имя);
		КонецЦикла; 
	ИначеЕсли СтрокаМассивСписок = "Список" Тогда
		Результат = Новый СписокЗначений;
		Для каждого Область Из ТабДок.Области Цикл
			Результат.Добавить(Область.Имя);
		КонецЦикла; 
	Иначе
		Результат = "";
		Для каждого Область Из ТабДок.Области Цикл
			Результат = Результат + "," + Область.Имя;
		КонецЦикла; 
		Результат = Сред(Результат, 2);
	КонецЕсли;
	Возврат Результат
КонецФункции // СписокОбластейТД

// Возвращает табличный документ с выведенной таблицей значений
// Параметры:
//  ТабЗначений		- Таблица значений - таблица для вывода
//  ПерваяКолонка	- Число >=1 - Номер первой колонки табличного документа для вывода данных. По умолчанию 1.
//  СтрокаЗаголовка	- Число - Номер строки табличного документа для вывода заголовков колонок. <= 1 - заголовок не выводится. По умолчанию 1.
//  СтрокаДанных	- Число - Номер первой строки табличного документа для вывода данных таблицы. 0 - переводится в СтрокаЗаголовка + 1 (по умолчанию). <= СтрокаЗаголовка - данные не выводятся.
//  СтрокаИтогов	- Число - Номер строки табличного документа для вывода итогов. 0 (по умолчанию) - итоги не выводятся. Отрицательные значения - отсчёт от конца данных (-1 - сразу после данных).
//  КолонкиИтогов	- Строка или массив - колонки, по которым подводятся итоги. По умолчанию Неопределено - итоги не выводятся.
//  СвойстваЯчеек	- Структура - ключи - имена колонок, значения - структуры, свойства которых копируются в ячейки колонки.
//			Ключи "ЯчейкаЗаголовок" и "ЯчейкаИтог" содержат такие же структуры для заголовков и  итогов. По умолчанию Неопределено - пустая структура.
//  Автовыравнивание- Булево - Истина - автовыравнивание: по верхнему краю, числа и даты - по правому краю, булево - по центру, остальное - по левому краю. В итогах и заголовках не действует.
//  ТолькоТекст		- Булево - Истина - вывод в свойство "Текст" ячейки, Ложь - в свойство "Значение". По умолчанию Ложь.
//  ЦветЗаголовка	- Цвет - Цвет фона заголовка по умолчанию (до применения свойств ячеек). По умолчанию Неопределено - без цвета.
//  ЦветРамки		- Цвет - Цвет границ. По умолчанию Неопределено - без цвета.
//  ЛинияГраниц		- Линия - Линия границ. По умолчанию Неопределено - без границ.
// Возвращаемое значение:
//   Табличный документ   - содержащий выведенную таблицу значений
Функция ТабличныйДокументИзТаблицыЗначений(ТабЗначений, ПерваяКолонка = 1, СтрокаЗаголовка = 1, СтрокаДанных = 0, СтрокаИтогов = 0, КолонкиИтогов = Неопределено,
		СвойстваЯчеек = Неопределено, Автовыравнивание = Истина, ТолькоТекст = Ложь, ЦветЗаголовка = Неопределено, ЦветРамки = Неопределено, ЛинияГраниц = Неопределено) Экспорт
	Результат = Новый ТабличныйДокумент;
	ПустаяСтруктура = Новый Структура;
	Если СвойстваЯчеек = Неопределено Тогда
		СвойстваЯчеек = ПустаяСтруктура;
	КонецЕсли;
	ПерваяСтрока = ?(СтрокаДанных = 0, СтрокаЗаголовка + 1, СтрокаДанных);
	КолвоСтрок = ТабЗначений.Количество();
	СтрокаВыводаИтогов = ?(СтрокаИтогов < 0, ПерваяСтрока + КолвоСтрок - 1 - СтрокаИтогов, СтрокаИтогов);
	МИтогов = ?(КолонкиИтогов = Неопределено, Новый Массив, ?(ТипЗнч(КолонкиИтогов) = Тип("Строка"), СтрРазделить(КолонкиИтогов,, Ложь), КолонкиИтогов));
	ВыводитьЗаголовки = СтрокаЗаголовка >= 0;
	ВыводитьДанные = ПерваяСтрока > СтрокаЗаголовка;
	ВыводитьИтоги = (СтрокаВыводаИтогов >= 0) И (МИтогов.Количество() > 0);
	СтрНачала = Мин(СтрокаЗаголовка, СтрокаВыводаИтогов);
	СтрОкончания = Макс(СтрокаВыводаИтогов, ПерваяСтрока + КолвоСтрок - 1);
	ТипЧисло = Тип("Число");
	ТипДата = Тип("Дата");
	ТипБулево = Тип("Булево");
	
    СчКол = ПерваяКолонка;
	Для каждого Колонка Из ТабЗначений.Колонки Цикл
		СвойстваЯчКол = ЧтСтрукт(СвойстваЯчеек, Колонка.Имя, ПустаяСтруктура);
		#Область ЗАГОЛОВКИ
			Если ВыводитьЗаголовки Тогда
				Ячейка_ = Результат.Область(СтрокаЗаголовка, СчКол);
				Ячейка_.Текст = Колонка.Имя;
				ГраницыИЗаливка(Ячейка_, ЦветЗаголовка, ЦветРамки, ЛинияГраниц);
				ЗаполнитьЗначенияСвойств(Ячейка_, ЧтСтрукт(СвойстваЯчКол, "ЯчейкаЗаголовок", ПустаяСтруктура));
				Результат.Область(СтрНачала, СчКол, СтрОкончания, СчКол).ШиринаКолонки = Колонка.Ширина;
			КонецЕсли;
		#КонецОбласти
	
		#Область ИТОГИ
			Если ВыводитьИтоги И (МИтогов.Найти(Колонка.Имя) <> Неопределено) Тогда
				Ячейка_ = Результат.Область(СтрокаЗаголовка, СчКол);
				Ячейка_.Текст = ТабЗначений.Итог(Колонка.Имя);
				Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
				ГраницыИЗаливка(Ячейка_,, ЦветРамки, ЛинияГраниц);
				Ячейка_.Шрифт = Новый Шрифт(Ячейка_.Шрифт,,, Истина);
				ЗаполнитьЗначенияСвойств(Ячейка_, ЧтСтрукт(СвойстваЯчКол, "ЯчейкаИтог", ПустаяСтруктура));
			КонецЕсли;
		#КонецОбласти
		#Область ДАННЫЕ
			 Если ВыводитьДанные Тогда
				Ячейка_ = Результат.Область(ПерваяСтрока, СчКол, ПерваяСтрока + КолвоСтрок - 1, СчКол);
				Если ТолькоТекст Тогда
					ИмяСвойства = "Текст";
					СодержитЗначение = Ложь;
				Иначе
					ИмяСвойства = "Значение";
					СодержитЗначение = Истина;
				КонецЕсли;
				СчСтр = 0;
				Для каждого СтрокаТЗ Из ТабЗначений Цикл
					Ячейка_ = Результат.Область(ПерваяСтрока + СчСтр, СчКол);
					Ячейка_.СодержитЗначение = СодержитЗначение;
					ТекЗнч = СтрокаТЗ[Колонка.Имя];
					Ячейка_[ИмяСвойства] = ТекЗнч;
					ГраницыИЗаливка(Ячейка_,, ЦветРамки, ЛинияГраниц);
					Если Автовыравнивание Тогда
						ТекТип = ТипЗнч(ТекЗнч);
						Ячейка_.ВертикальноеПоложение = ВертикальноеПоложение.Верх;
						Если (ТекТип = ТипЧисло) ИЛИ (ТекТип = ТипДата) Тогда
							Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
						ИначеЕсли ТекТип = ТипБулево Тогда
							Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр;
						Иначе
							Ячейка_.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Лево;
						КонецЕсли;
					КонецЕсли;
					ЗаполнитьЗначенияСвойств(Ячейка_, СвойстваЯчКол);
					СчСтр = СчСтр + 1;
				КонецЦикла;
		 	КонецЕсли;
		#КонецОбласти
	
		СчКол = СчКол + 1;
	КонецЦикла;
	
	Возврат Результат
КонецФункции // ТабличныйДокументИзТаблицыЗначений

// Проверяет, укладывается ли ТД в заданное колво страниц по ширине
// Параметры:
//  ТД  - ТабличныйДокумент - ПроверяемыйТД
//  Страниц  - Число - Количество страниц в ширину. По умолчанию 1
//  Масштаб  - Число - Проверяемый масштаб. По умолчанию  0 = Берётся масштаб документа
// Возвращаемое значение:
//   Булево   - Документ размещается в страницы по ширине
Функция ШиринаТДВСтраницахНеБолее(ТД, Страниц = 1, Масштаб = 0) Экспорт
	Если Страниц <= 0 Тогда
		Результат = Истина;
	Иначе
		ПроверяемыйМасштаб = ?(Масштаб = 0, ТД.МасштабПечати, Масштаб);
		ПустойТД = Новый ТабличныйДокумент;
		ПустойТД.Автомасштаб = Ложь;
		ПустойТД.МасштабПечати = ПроверяемыйМасштаб / Страниц;
		КПроверке = Новый Массив;
		КПроверке.Добавить(ТД);
		Результат = ПустойТД.ПроверитьПрисоединение(КПроверке);
	КонецЕсли;
	Возврат Результат
КонецФункции // ШиринаТДВСтраницахНеБолее

#Область РАСПОЛОЖИТЬ_НА_СТРАНИЦУ
	
// Вспомогательная для процедуры ТабДок_РасположитьВСтранице
Функция ПолучитьВременныйТД(ТабДок, Временный)
	Если Временный = Неопределено Тогда
		Временный = СкопироватьПараметрыТД(, ТабДок);
		Временный.Вывести(ТабДок);
		Временный.АвтоМасштаб = Ложь;
	КонецЕсли;
	Возврат Временный
КонецФункции

// Проверяет расположение документов для неразрывной печати "низа" с подписями
// Вспомогательная для ПроверитьРасположениеИОбновитьРезультат
// Параметры:
//  ТабДок  - Табличный документ - Проверяемый ТД
//  МассивОписанийДокументов  - Массив структур - Каждая структура = описание одного документа при печати нескольких документов в один ТД.
//				Возможные ключи: Числа (номера строк) Начало, НачалоНиза и Конец, табличные документы Верх и Полный.
//  АвтоМасштаб  - Булево - Значение для установки автомасштаба. По умолчанию Истина.
//  МасштабПечати  - Число/Неопределено (по умолчанию) - Значение для установки масштаба печати
//  ХранитьТД  - Булево - Хранить ТД в ключах Верх и Полный элементов МассивОписанийДокументов для последующих использований (Ложь - каждый раз рассчитывать по НачалоНиза и Конец)
//	ДопустимоПлохих  - Число - Процент "плохих" (неисправленных) документов, принимаемый как удовлетворительный
//	МасштабРешения  - Число - Переменная для установки найденного масштаба
//  РезультатРешения  - Число - Переменная для процента "плохих" документов (присвоится, если будет найдено удовлетворительное решение лучше найденных ранее).
//  КолвоПлохих  - Число - Переменная для возврата количества найденных "плохих" документов.
Процедура ПроверитьРасположениеДокументов(
		ТабДок,
		МассивОписанийДокументов,
		АвтоМасштаб = Истина,
		МасштабПечати = Неопределено,
		ХранитьТД,
		ДопустимоПлохих,
		КолвоВсего,
		МасштабРешения,
		РезультатРешения,
		КолвоПлохих = 0)
	КолвоПлохих = 0;
	Для каждого ОписаниеДока Из МассивОписанийДокументов Цикл
		Если ОписаниеДока.Свойство("Верх") Тогда
			ТДДляТестирования = ОписаниеДока.Верх;
			ТДДляТестированияПолный = ОписаниеДока.Полный;
			Если НЕ ХранитьТД Тогда
				ОписаниеДока.Удалить("Верх");
				ОписаниеДока.Удалить("Полный");
			КонецЕсли; 
		Иначе
			ТДДляТестирования = ТабДок.ПолучитьОбласть(1,, ОписаниеДока.НачалоНиза - 1,);
			СкопироватьПараметрыТД(ТДДляТестирования, ТабДок);
			ТДДляТестированияПолный = ТабДок.ПолучитьОбласть(1,, ОписаниеДока.Конец,);
			СкопироватьПараметрыТД(ТДДляТестированияПолный, ТДДляТестирования);
			Если ХранитьТД Тогда
				ОписаниеДока.Вставить("Верх", ТДДляТестирования);
				ОписаниеДока.Вставить("Полный", ТДДляТестированияПолный);
			КонецЕсли; 
		КонецЕсли; 
		ТДДляТестирования.Автомасштаб = Автомасштаб;
		ТДДляТестирования.МасштабПечати = МасштабПечати;
		ТДДляТестированияПолный.Автомасштаб = Автомасштаб;
		ТДДляТестированияПолный.МасштабПечати = МасштабПечати;
		КолвоСтраниц = ТДДляТестированияПолный.КоличествоСтраниц();
		Если ТДДляТестирования.КоличествоСтраниц() <> КолвоСтраниц Тогда
			КолвоПлохих = КолвоПлохих + 1;
		КонецЕсли;
	КонецЦикла;
	ТекРезультат = КолвоПлохих * 100 / КолвоВсего;
	Если ТекРезультат <= ДопустимоПлохих Тогда
		Если ТекРезультат < РезультатРешения Тогда
			МасштабРешения = ?(АвтоМасштаб, 0, МасштабПечати);
			РезультатРешения = ТекРезультат;
		ИначеЕсли ТекРезультат = РезультатРешения И МасштабРешения < МасштабПечати Тогда
			МасштабРешения = ?(АвтоМасштаб, 0, МасштабПечати);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры // ПроверитьРасположениеДокументов
 
// Вспомогательная для процедуры ТабДок_РасположитьВСтранице
//Параметры см.ПроверитьРасположениеДокументов; Временный ТД - копия Табдок для экспериментов
Процедура ПроверитьРасположениеИОбновитьРезультат(
		ТабДок,
		ВременныйТД,
		МассивОписанийДокументов,
		Автомасштаб,
		МасштабПечати,
		ХранитьТД,
		ДопустимоПлохих,
		КолвоВсего,
		МасштабРешения,
		РезультатРешения,
		КолвоПлохих = Неопределено,
		ПродолжитьПоискРешения
		)
    РезультатТекВарианта = 100;
	МасштабТекВарианта = 0;
	ПроверитьРасположениеДокументов(ВременныйТД, МассивОписанийДокументов, Автомасштаб, МасштабПечати, ХранитьТД, ДопустимоПлохих,
			КолвоВсего, МасштабТекВарианта, РезультатТекВарианта, КолвоПлохих); 
	Если РезультатТекВарианта = 0 Тогда
		ТабДок.АвтоМасштаб = Автомасштаб;
		ТабДок.МасштабПечати = МасштабТекВарианта;
		ПродолжитьПоискРешения = Ложь;
	ИначеЕсли РезультатТекВарианта < РезультатРешения Тогда
		Если АвтоМасштаб Тогда
			ВременныйТД.АвтоМасштаб = Ложь;
		КонецЕсли;
		МасштабРешения = МасштабТекВарианта;
		РезультатРешения = РезультатТекВарианта;
	КонецЕсли; 
КонецПроцедуры

// Располагает "низ" (условно - подписи) документа в пределах последней страницы неразрывно. Проверка идёт на то, что Низ и Верх должны заканчиваться на одной странице.
//	Алгоритм описан в начале функции
//	Рекомендация (но не обязательно) - делать макет единой ширины, т.к. иначе Получитьобласть() может работать некорректно.
// Параметры:
//  ТабДок  - Табличный документ - Преобразуемый табличный документ
//	ПроверятьРазмещениеСтраницВШирину - Число - По умолчанию 1. 0 = Не проверять.
//  НачальныйМасштаб  - Число - Масштаб табличного документа, с которого включительно начинаются попытки уменьшать масштаб.
//			По умолчанию 0 - МасштабПечати ТабДок, а если он не задан - 100%
//  КонечныйМасштаб  - Число - Масштаб табличного документа, до которого включительно проводятся попытки уменьшать масштаб.
//			По умолчанию 0 - НачальныйМасштаб - 30%
//	АвтоМасштаб  - Булево - Выполнять проверку с установленным автомасштабом. По умолчанию Истина.
//	УменьшениеМасштаба  - Булево - Выполнять проверку уменьшения масштаба. По умолчанию Истина.
//	ЕслиНеНашлосьБыстроИскатьПеребором  - Булево - Если "быстрый" способ не дал решения - поискать перебором масштабов (это долго). По умолчанию Истина.
//	ВставлятьРазрыв  - Булево - Вставлять разрыв, если масштаб подобрать не удалось. По умолчанию Истина.
//	ДопустимоПлохих  - Число - Процент допустимых "плохих" документов. По умолчанию 0.
//	ПолучилосьПлохих  - Число - Переменная, в которую будет возвращено число плохих документов в процентах от общего числа. По умолчанию 0.
//	мОписанияДокументов - Массив/Неопределено (по умолчанию) - массив структур с ключами Начало, НачалоНиза и Конец. Такой массив иногда проще составить при формировании ТД,
//			и, если он составлен, передать в эту процедуру готовый. Если массив задан, все параметры далее не используются. Если не задан - составляется в этой процедуре.
//  ВысотаВерха  - Число - Высота верха. В ТД выведено несколько документов (например, СФ и Актов).
//			Каждый документ состоит из низа (условно - блока подписей) и верха (документа до этого блока).
//			Для подбора масштаба надо найти эти документы и их верхи. Они могут быть фиксированными (заданы высота верха и/или высота документа) в строках.
//			По умолчанию 0, в этом случае производится поиск по контрольному значению в контрольной колонке.
//  КонтрольнаяКолонкаВерха  - Число - Колонка, в которой ищется контрольное значение при определении "верха".
//			Имеет смысл только при ВысотаВерха = 0. По умолчанию 1.
//			Если задано значение 0, то контрольное значение не считывается из колонки, а считается ИСТИНОЙ.
//			В этом случае имеет смысл использование в КонтрольноеЗначениеВерха только "менеджера" и РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз = Истина.
//			М.б. задано менеджером, тогда рассчитвывается перед стартом и после нахождения контрольного значения ДОКУМЕНТА.
//			В "МЕНЕДЖЕРАХ" используются имена Табдок, МассивОписанийДокументов (см. мОписанияДокументов) - только для уже найденных документов,
//				НомерТекущейСтрокиТД, КонтрольнаяКолонкаВерха, КонтрольнаяКолонкаДокумента, ВысотаВерха, НачалоТекущегоДокумента, НачалоТекущегоНиза.
//  КонтрольноеЗначениеВерха  - Строка - Искомое контрольное значение при определении верха. Найденная строка при нулевом отступе является последней строкой верха.
//			Ищется в контрольной колонке. Имеет смысл только при ВысотаВерха = 0. По умолчанию "ИТОГО:".
//			Может быть "менеджером" (т.е. рассчитываться). 
//	РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз	- Булево - Заставляет пересчитывать контрольное значение для каждой проверяемой строки ТД.
//			Имеет смысл только при ВысотаВерха = 0 и применении "менеджера" в КонтрольноеЗначениеВерха. По умолчанию Ложь.
//			Установка в Истина при работе на клиенте может привести к массовым вызовам сервера, что не айс.
//  ОтступВерха  - Число - Отступ последней строки верха от строки, в которой найдено контрольное значение. Имеет смысл только при ВысотаВерха = 0. По умолчанию 0.
//  ВысотаДокумента  - Число - Высота всего документа (см. ВысотаВерха). Если значение не найдено, весь остаток ТД считается документом к распечатке.
//			Если задано - 1 (по умолчанию) - считается, что в ТД документ один и искать документы не надо.
//  КонтрольнаяКолонкаДокумента  - Число - Номер колонки (см. ВысотаВерха и КонтрольнаяКолонкаВерха).
//  КонтрольноеЗначениеДокумента  - Строка - Искомое контрольное значение (см. ВысотаВерха и КонтрольноеЗначениеВерха). Найденная строка при нулевом отступе является последней строкой документа.
//	РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз	- Булево - Рсчёт КЗ в каждой строке (см. ВысотаВерха и РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз).
//  ОтступДокумента  - Число - Отступ последней строки документа (см. ВысотаВерха и ОтступВерха).
Процедура РасположитьПодвалТДНеразрывно(
		ТабДок,
		ПроверятьРазмещениеСтраницВШирину = 1,
		НачальныйМасштаб = 0,
		КонечныйМасштаб = 0,
		АвтоМасштаб = Истина,
		УменьшениеМасштаба = Истина,
		ЕслиНеНашлосьБыстроИскатьПеребором = Истина,
		ВставлятьРазрыв = Истина,
		ДопустимоПлохих = 0,
		ПолучилосьПлохих = 0,
		мОписанияДокументов = Неопределено,
		ВысотаВерха = 0,
		КонтрольнаяКолонкаВерха = 1,
		КонтрольноеЗначениеВерха = "ИТОГО:",
		РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз = Ложь,
		ОтступВерха = 0,
		ВысотаДокумента = -1,
		КонтрольнаяКолонкаДокумента = 1,
		КонтрольноеЗначениеДокумента = "ИТОГО:",
		РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз = Ложь,
		ОтступДокумента = -1
		) Экспорт
		
	//Алгоритм проверки
	//1.Проверка при автомасштабе - полная; Если по умолчанию не автомасштаб - выполняется после шага 2.
	//2.Проверка при заданном начальном масштабе - полная (после проверки по ширине).
	//3.Поиск 100% решения ускоренным методом (половинное деление масштабов, быстрый расчёт). Проводится этапами: 1 - поиск интервала масштабов с ок шириной; 2- поиск решения (попутно ищутся неполные решения)
	//4.Полная проверка результата п.3
	//5.Если результат не найден - последовательное, с шагом 1%, уменьшение масштаба от верхней границы
	//6.Вставка разрывов страниц
	
	#Область ИНИЦИАЛИЗАЦИЯ_ОБЩАЯ
		СтрокаНачалаДокумента = 1;
		МасштабРешения = - 1;
		РезультатРешения = 100; //Процент "плохих"
		МасштабТекВарианта = -1;
		РезультатТекВарианта = 100;
		ВременныйТД = Неопределено;
		МасштабироватьДалее = Истина;
		РезультатУхудшился = Ложь;
		МаксМасштабОкПоШирине = 0;
		
		ВысотаТД = ТабДок.ВысотаТаблицы;
		ВычисленныйНачальныйМасштаб = ?(НачальныйМасштаб = 0, ?(ТабДок.МасштабПечати = Неопределено, 100, ТабДок.МасштабПечати), НачальныйМасштаб);
		ВычисленныйКонечныйМасштаб = ?(КонечныйМасштаб = 0, НачальныйМасштаб - 30, КонечныйМасштаб);
	#КонецОбласти
		
	#Область ВЫЧИСЛЕНИЕ_ПАРАМЕТРОВ_ВЫСОТЫ_ДОКУМЕНТОВ
		Если мОписанияДокументов = Неопределено Тогда
			#Область ИНИЦИАЛИЗАЦИЯ_ВПВД
				МассивОписанийДокументов = Новый Массив;
				ВычисленнаяВысотаВерха = ВысотаВерха;
				ВычисленнаяВысотаДокумента = ВысотаДокумента;
				ВычисленныйОтступВерха = ОтступВерха;
				ВычисленныйОтступДокумента = ОтступДокумента;
				#Область ПАРАМЕТРЫ_МЕНЕДЖЕРОВ
					ПараметрыМенеджеров = Новый Структура;
					ПараметрыМенеджеров.Вставить("Табдок", Табдок);
					ПараметрыМенеджеров.Вставить("МассивОписанийДокументов", МассивОписанийДокументов);
					ПараметрыМенеджеров.Вставить("НомерТекущейСтрокиТД", 0);
					ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаВерха", КонтрольнаяКолонкаВерха);
					ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаДокумента", КонтрольнаяКолонкаДокумента);
					ПараметрыМенеджеров.Вставить("ВысотаВерха", ВычисленнаяВысотаВерха);
					ПараметрыМенеджеров.Вставить("ВысотаДокумента", ВычисленнаяВысотаДокумента);
					ПараметрыМенеджеров.Вставить("КонецТекущегоДокумента", 0);
					ПараметрыМенеджеров.Вставить("НачалоТекущегоДокумента", 1);
					ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", 0);
				#КонецОбласти
				#Область КОНТРОЛЬНАЯ_КОЛОНКА_ВЕРХА
					ВычисленнаяКонтрольнаяКолонкаВерха = ЗапуститьМенеджер(КонтрольнаяКолонкаВерха, ПараметрыМенеджеров);
					КолонкаВерхаЗаданаМенеджером = ВычисленнаяКонтрольнаяКолонкаВерха <> КонтрольнаяКолонкаВерха;
					Если КолонкаВерхаЗаданаМенеджером Тогда
						ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаВерха", ВычисленнаяКонтрольнаяКолонкаВерха);
					КонецЕсли;
				#КонецОбласти
				#Область КОНТРОЛЬНАЯ_КОЛОНКА_ВЕРХА
					ВычисленнаяКонтрольнаяКолонкаДокумента = ЗапуститьМенеджер(КонтрольнаяКолонкаДокумента, ПараметрыМенеджеров);
					КолонкаДокументаЗаданаМенеджером = ВычисленнаяКонтрольнаяКолонкаВерха <> КонтрольнаяКолонкаВерха;
					Если КолонкаДокументаЗаданаМенеджером Тогда
						ПараметрыМенеджеров.Вставить("КонтрольнаяКолонкаДокумента", ВычисленнаяКонтрольнаяКолонкаДокумента);
					КонецЕсли;
				#КонецОбласти
				Если (ВычисленнаяВысотаВерха = 0) И НЕ РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз Тогда
					ВычисленноеКонтрольноеЗначениеВерха = ЗапуститьМенеджер(КонтрольноеЗначениеВерха, ПараметрыМенеджеров);
				КонецЕсли; 
				Если (ВычисленнаяВысотаДокумента = 0) И НЕ РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз Тогда
					ВычисленноеКонтрольноеЗначениеДокумента = ЗапуститьМенеджер(КонтрольноеЗначениеДокумента, ПараметрыМенеджеров);
				КонецЕсли; 
			#КонецОбласти 
			Пока СтрокаНачалаДокумента <= ВысотаТД Цикл
				ОписаниеДока = Новый Структура("Начало,НачалоНиза,Конец", СтрокаНачалаДокумента, 0, 0);
				Если ВычисленнаяВысотаВерха <> 0 Тогда
					ОписаниеДока.НачалоНиза = ОписаниеДока.Начало + ВычисленнаяВысотаВерха;
				КонецЕсли; 
				Если ВычисленнаяВысотаДокумента > 0 Тогда
					ОписаниеДока.Конец = ОписаниеДока.Начало + ВычисленнаяВысотаДокумента - 1;
				ИначеЕсли ВычисленнаяВысотаДокумента = -1 Тогда
					ОписаниеДока.Конец = ВысотаТД;
				КонецЕсли; 
				Если (ОписаниеДока.НачалоНиза = 0) ИЛИ (ОписаниеДока.Конец = 0) Тогда
					СтартоваяКС = ОписаниеДока.Начало - Макс(Мин(0, ВычисленныйОтступВерха), Мин(0, ВычисленныйОтступДокумента));
					ФинишнаяКС = ТабДок.ВысотаТаблицы - Мин(Макс(0, ВычисленныйОтступВерха), Макс(0, ВычисленныйОтступДокумента));
					Для КонтрольнаяСтрока = СтартоваяКС По ФинишнаяКС Цикл
						ПараметрыМенеджеров.Вставить("НомерТекущейСтрокиТД", КонтрольнаяСтрока);
						Если РассчитыватьКЗвКаждойСтрокеДокументаАНеОдинРаз И (ОписаниеДока.Конец = 0) Тогда
							ВычисленноеКонтрольноеЗначениеДокумента = ЗапуститьМенеджер(КонтрольноеЗначениеДокумента, ПараметрыМенеджеров);
						КонецЕсли;
						ВозможныйКонецДокумента = КонтрольнаяСтрока + ВычисленныйОтступДокумента;
						Если ?((ОписаниеДока.Конец = 0) И (ВозможныйКонецДокумента > 0),
								ВычисленноеКонтрольноеЗначениеДокумента =
									?(ВычисленнаяКонтрольнаяКолонкаДокумента = 0,
										Истина,
										ТабДок.Область(КонтрольнаяСтрока, ВычисленнаяКонтрольнаяКолонкаДокумента).Текст),
								Ложь)
								Тогда
							#Область РАСЧЁТ_КОНЦА_ДОКУМЕНТА
								ОписаниеДока.Конец = ВозможныйКонецДокумента;
								Если ОписаниеДока.НачалоНиза = 0 Тогда
									ОписаниеДока.НачалоНиза = ОписаниеДока.Конец + 1;
								КонецЕсли;
								Прервать
							#КонецОбласти
						ИначеЕсли ОписаниеДока.НачалоНиза = 0 Тогда
							#Область РАСЧЁТ_НАЧАЛА_НИЗА
								Если РассчитыватьКЗвКаждойСтрокеВерхаАНеОдинРаз Тогда
									ВычисленноеКонтрольноеЗначениеВерха = ЗапуститьМенеджер(КонтрольноеЗначениеВерха, ПараметрыМенеджеров);
								КонецЕсли; 
								Если ?(ВычисленнаяКонтрольнаяКолонкаВерха = 0, Истина, ТабДок.Область(КонтрольнаяСтрока, ВычисленнаяКонтрольнаяКолонкаВерха).Текст) = ВычисленноеКонтрольноеЗначениеВерха Тогда
									ОписаниеДока.НачалоНиза = КонтрольнаяСтрока + ВычисленныйОтступВерха + 1;
									ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", ОписаниеДока.НачалоНиза);
									Если ОписаниеДока.Конец > 0 Тогда
										Прервать;
									КонецЕсли;
								КонецЕсли;
							#КонецОбласти
						КонецЕсли;
					КонецЦикла;
					Если ОписаниеДока.НачалоНиза = 0 Тогда
						ОписаниеДока.НачалоНиза = ФинишнаяКС + 1;
					КонецЕсли;
					Если ОписаниеДока.Конец = 0 Тогда
						ОписаниеДока.Конец = ФинишнаяКС;
					КонецЕсли;
				КонецЕсли;
				МассивОписанийДокументов.Добавить(ОписаниеДока);
				СтрокаНачалаДокумента = ОписаниеДока.Конец + 1;
				ПараметрыМенеджеров.Вставить("НачалоТекущегоДокумента", СтрокаНачалаДокумента);
				ПараметрыМенеджеров.Вставить("НачалоТекущегоНиза", 0);
				ПараметрыМенеджеров.Вставить("КонецТекущегоДокумента", 0);
			КонецЦикла; 
		Иначе
			МассивОписанийДокументов = мОписанияДокументов;
		КонецЕсли;
		КолвоВсего = МассивОписанийДокументов.Количество();
		ХранитьТД = КолвоВсего < 100;
	#КонецОбласти
	
	Если КолвоВсего < 1 Тогда
		МасштабироватьДалее = Ложь;
	КонецЕсли;
	
	#Область ПРОВЕРКА_АВТОМАСШТАБА_1
		ПроверитьАвтоМасштаб = АвтоМасштаб И (ПроверятьРазмещениеСтраницВШирину < 2);
		Если ПроверитьАвтоМасштаб И МасштабироватьДалее И ТабДок.АвтоМасштаб  Тогда
			ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
			ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Истина, Неопределено, ХранитьТД, ДопустимоПлохих,
					КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
		КонецЕсли;
	#КонецОбласти 
	
	#Область ПРОВЕРКА_НАЧАЛЬНОГО_МАСШТАБА
		Если МасштабироватьДалее Тогда
			ПлохихВНачальнойТочке = КолвоВсего;
			ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
			ШиринаВПределе = ШиринаТДВСтраницахНеБолее(ВременныйТД, ПроверятьРазмещениеСтраницВШирину, ВычисленныйНачальныйМасштаб);
			Если ШиринаВПределе Тогда
				МаксМасштабОкПоШирине = ВычисленныйНачальныйМасштаб;
				ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ВычисленныйНачальныйМасштаб, ХранитьТД, ДопустимоПлохих,
						КолвоВсего, МасштабРешения, РезультатРешения, ПлохихВНачальнойТочке, МасштабироватьДалее);
			Иначе
				РезультатРешения = 100;
			КонецЕсли;
		КонецЕсли; 
	#КонецОбласти 
	
	#Область ПРОВЕРКА_АВТОМАСШТАБА_2
		Если ПроверитьАвтоМасштаб И МасштабироватьДалее И НЕ ТабДок.АвтоМасштаб  Тогда
			ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
			ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Истина, Неопределено, ХранитьТД, ДопустимоПлохих,
					КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
		КонецЕсли;
	#КонецОбласти 
	
	#Область УМЕНЬШЕНИЕ_МАСШТАБА_ПОЛОВИННЫМ_ДЕЛЕНИЕМ
		Если УменьшениеМасштаба И МасштабироватьДалее Тогда
			//Допущение:
			//Предполагается, что при уменьшении масштаба сначала "плохие" перейдут в "хорошие", а уже потом начнут портиться "хорошие". Т.е. пока не ушли "плохие", "хорошие" будут ок.
			Для Этап = 1 По 2 Цикл
				Если МасштабироватьДалее
						И ((Этап = 2) И (ПроверятьРазмещениеСтраницВШирину > 0) ИЛИ НЕ ШиринаВПределе) Тогда 
					#Область ИНИЦИАЛИЗАЦИЯ_УМЕНЬШЕНИЯ
						ВерхнийПределМасштаба = ВычисленныйНачальныйМасштаб - 1; //ВНМ уже проверен
						НижнийПределМасштаба = ВычисленныйКонечныйМасштаб;
						Вектор = - 1; //Вероятность решения выше в верхнем краю масштабной сетки
						ВекторНазначен = Ложь;
					    Если Этап = 1 Тогда
							ВременныйТД = ПолучитьВременныйТД(ТабДок, ВременныйТД);
						Иначе
							ТекПлохих = ПлохихВНачальнойТочке;
							ВременныйТД.МасштабПечати = ВычисленныйНачальныйМасштаб;
							ИсходноеКолвоСтраниц = ВременныйТД.КоличествоСтраниц();
							РезультатТекВарианта = РезультатРешения;
							МасштабТекВарианта = ВерхнийПределМасштаба;
							ПлохиеМасштабы = Новый Массив;
						КонецЕсли;
						ТочкаПроверки = ВерхнийПределМасштаба;
					#КонецОбласти
					//ДопУсловие = Ложь;
					Пока (ВерхнийПределМасштаба >= НижнийПределМасштаба) Цикл 
						ДлинаОтрезкаМасштабов = ВерхнийПределМасштаба - НижнийПределМасштаба + 1;
						Шаг = ШагПоловинногоДеления(ДлинаОтрезкаМасштабов, Вектор);
						ТочкаПроВерки = ВерхнийПределМасштаба - Шаг + 1;
						Если Этап = 1 Тогда
							РезультатОк = ШиринаТДВСтраницахНеБолее(ВременныйТД, ПроверятьРазмещениеСтраницВШирину, ТочкаПроВерки);
						Иначе
							ВременныйТД.МасштабПечати = ТочкаПроВерки;
							Дельта = (ИсходноеКолвоСтраниц - ВременныйТД.КоличествоСтраниц()) / ПроверятьРазмещениеСтраницВШирину;
							ТекПлохих = Цел(ПлохихВНачальнойТочке - Дельта);
							ТекРезультат = ТекПлохих * 100 / КолвоВсего;
							Если ТекРезультат <= ДопустимоПлохих Тогда
								Если ТекРезультат < РезультатТекВарианта Тогда
									РезультатТекВарианта = ТекРезультат;
									МасштабТекВарианта = ТочкаПроВерки;
								ИначеЕсли ТекРезультат = РезультатТекВарианта И МасштабТекВарианта < ТочкаПроВерки Тогда
									МасштабТекВарианта = ТочкаПроВерки;
								КонецЕсли; 
							КонецЕсли; 
							Если ТекПлохих = 0 Тогда
								РезультатОк = Истина;
							Иначе
								РезультатОк = Ложь;
								ПлохиеМасштабы.Вставить(ТочкаПроВерки);
							КонецЕсли;
						КонецЕсли; 
						Если РезультатОк Тогда
							Если НЕ ВекторНазначен Тогда
								Вектор = 1;
								ВекторНазначен = Истина;
							КонецЕсли; 
							НижнийПределМасштаба = ТочкаПроВерки + 1;
						Иначе
							ВерхнийПределМасштаба = ТочкаПроВерки - 1;
						КонецЕсли;
					КонецЦикла;
					Если Этап = 1 Тогда
						ВычисленныйНачальныйМасштаб = ВерхнийПределМасштаба;
						Если ВычисленныйНачальныйМасштаб >= ВычисленныйКонечныйМасштаб Тогда
							МасштабТекВарианта = ВычисленныйНачальныйМасштаб;
							РезультатТекВарианта = -1;
						Иначе
							Прервать;
						КонецЕсли;
					КонецЕсли;
					Если РезультатТекВарианта < РезультатРешения Тогда
						ТочкаПроВерки = МасштабТекВарианта;
						ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
								КолвоВсего, МасштабРешения, РезультатРешения, ПлохихВНачальнойТочке, МасштабироватьДалее);
					КонецЕсли;
					Если Этап = 2 Тогда
						РезультатУхудшился = РезультатТекВарианта < РезультатРешения;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	#КонецОбласти 
	
	#Область УМЕНЬШЕНИЕ_МАСШТАБА_ПЕРЕБОРОМ
		Если УменьшениеМасштаба И МасштабироватьДалее И ЕслиНеНашлосьБыстроИскатьПеребором Тогда
			#Область КРОМЕ_ПЛОХИХ_МАСШТАБОВ
				Для Сдвиг = ВычисленныйКонечныйМасштаб По ВычисленныйНачальныйМасштаб - 1 Цикл
					ТочкаПроВерки = ВычисленныйНачальныйМасштаб + ВычисленныйКонечныйМасштаб - Сдвиг - 1;
					Если ПлохиеМасштабы.Найти(ТочкаПроВерки) = Неопределено Тогда
						ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
								КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
						Если НЕ МасштабироватьДалее Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			#КонецОбласти
			
			//В плохих масштабах решение м.б. лучшим только если текущее решение ухудшилось при точной проверке
			Если МасштабироватьДалее И РезультатУхудшился Тогда
				Для каждого ТочкаПроВерки Из ПлохиеМасштабы Цикл
					ПроверитьРасположениеИОбновитьРезультат(ТабДок, ВременныйТД, МассивОписанийДокументов, Ложь, ТочкаПроВерки, ХранитьТД, ДопустимоПлохих,
							КолвоВсего, МасштабРешения, РезультатРешения,, МасштабироватьДалее);
					Если НЕ МасштабироватьДалее Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	#КонецОбласти
	
	ПолучилосьПлохих = РезультатРешения;
	
	#Область АНАЛИЗ_РЕЗУЛЬТАТА_И_ВСТАВКА_РАЗРЫВА
		Если МасштабироватьДалее И ВставлятьРазрыв Тогда
			ВременныйТД = ТабДок;
			ТабДок = СкопироватьПараметрыТД(, ВременныйТД);
			Если ВычисленныйНачальныйМасштаб >= ВычисленныйКонечныйМасштаб Тогда
				ТабДок.АвтоМасштаб = Ложь;
				ТабДок.МасштабПечати = ВычисленныйНачальныйМасштаб;
			Иначе
				ТабДок.АвтоМасштаб = Истина;
				ТабДок.МасштабПечати = 0;
			КонецЕсли; 
			НуженРазделитель = Ложь;
			Для каждого ОписаниеДока Из МассивОписанийДокументов Цикл
				Если НуженРазделитель Тогда
					ТабДок.ВывестиГоризонтальныйРазделительСтраниц();
				Иначе
					НуженРазделитель = Истина;
				КонецЕсли;
				ОбластьКПроверкеИВыводу = ВременныйТД.ПолучитьОбласть(ОписаниеДока.НачалоНиза - 1,, ОписаниеДока.Конец);
				ТабДок.Вывести(ВременныйТД.ПолучитьОбласть(ОписаниеДока.Начало,, ОписаниеДока.НачалоНиза - 2));
				Если НЕ ТабДок.ПроверитьВывод(ОбластьКПроверкеИВыводу) Тогда
					ТабДок.ВывестиГоризонтальныйРазделительСтраниц();
				КонецЕсли;
				ТабДок.Вывести(ОбластьКПроверкеИВыводу);
			КонецЦикла; 
		ИначеЕсли МасштабРешения = 0 Тогда
			ТабДок.АвтоМасштаб = Истина;
			ТабДок.МасштабПечати = Неопределено;
		ИначеЕсли МасштабРешения <> - 1 Тогда
			ТабДок.АвтоМасштаб = Ложь;
			ТабДок.МасштабПечати = МасштабРешения;
		КонецЕсли; 
	#КонецОбласти 
			
КонецПроцедуры // ТабДок_РасположитьВСтранице

#КонецОбласти

#КонецОбласти 

#Область УПРАВЛЯЕМАЯ_ФОРМА

// Устанавливает флаг в таблице формы в нужное значение
// Параметры:
//  Форма  - Управляемая форма - Форма, где меняются флаги
//  ТаблицаФормы  - Таблица формы - содержащая изменяемую колонку
//	ИмяПоля - Строка - на клиенте - путь к данным;
//			на сервере - список полей через запятую. Изменяется текущее, если оно в списке или список пуст.
//			Если текущее не найдено в списке - изменяется первое, если оно задано. По умолчанию "Пометка"
//	НовоеЗначение - Булево/Неопределено - Устанавливаемое значение. По умолчанию Истина.
//			В рехиме инвертирования - значение, подставляемое вместо Истина:
//			*Неопределено - Истина ==> Неопределено ==> Ложь ==> Истина; 
//			*Ложь - Истина ==> Ложь ==> Неопределено ==> Истина; 
//			*Истина - Истина ==> Ложь ==> Истина; 
//			*0 - 1 ==> 0 ==> 2 ==> 1; 
//			*1 - 1 ==> 0 ==> 1; 
//			*2 - 1 ==> 2 ==> 0 ==> 1; 
//	Инвертировать - Булево - режим инвертирования флагов. По умолчанию Ложь.
//	ИмяДанныхТаблицы - Строка - Имя данных формы, соответствующих таблице. По умолчанию "" - автоопределение.
//	МассивСтрокКИзменению - Массив - массив строк таблицы/дерева (ДанныеФормыЭлементДерева), в которых будет меняться флаг.
//			По умолчанию Неопределено = выделенные строки или (если выделена одна строка или ничего не выделено) = все строки.
// Возвращаемое значение - Массив - Строки данных формы с изменёнными флагами.
Функция УстановитьФлаги(Форма, ТаблицаФормы_, ИмяПоля = "Пометка", НовоеЗначение = Истина, Инвертировать = Ложь, ИмяДанныхТаблицы = "", МассивСтрокКИзменению = Неопределено) Экспорт
	Результат = Новый Массив;
	ИмяДанныхПоляВТаблице = СтрЗаменить(ИмяПоля, " ", "");
	#Если Сервер ИЛИ МобильноеПриложениеСервер Тогда
		ДопустимыеПоля = ИмяДанныхПоляВТаблице;
		ИмяДанныхПоляВТаблице = СтрЗаменить(ТаблицаФормы_.ТекущийЭлемент.ПутьКДанным, ".", Символы.ПС);
		ИмяДанныхПоляВТаблице = СтрПолучитьСтроку(ИмяДанныхПоляВТаблице, СтрЧислоСтрок(ИмяДанныхПоляВТаблице));
		Если ИмяПоля <> "" Тогда
			Если Найти("," + ДопустимыеПоля + ",", "," + ИмяДанныхПоляВТаблице + ",") = 0 Тогда
				ИмяДанныхПоляВТаблице = СтрПолучитьСтроку(СтрЗаменить(ДопустимыеПоля, ",", Символы.ПС), 1);
			КонецЕсли;
		КонецЕсли; 
	#КонецЕсли
	#Область СТРОКИ_ДЛЯ_ФЛАГОВ
		МассивВЧёмМенять = Новый Массив;
		Если МассивСтрокКИзменению = Неопределено Тогда
			Если ИмяДанныхТаблицы = "" Тогда
				#Если Сервер ИЛИ МобильноеПриложениеСервер Тогда
					ИмяДанныхТаблицы = ТаблицаФормы_.ПутьКДанным;
				#Иначе
					ИмяДанныхТаблицы = "";
					ТестСтр = Новый Структура("Объект," + ТаблицаФормы_.Имя);
					ЗаполнитьЗначенияСвойств(ТестСтр, Форма);
					Если ТестСтр[ТаблицаФормы_.Имя] = Неопределено Тогда
						Если ТестСтр.Объект <> Неопределено Тогда
							ЗаполнитьЗначенияСвойств(ТестСтр, Форма);
							Если ТестСтр[ТаблицаФормы_.Имя] <> Неопределено Тогда
								ИмяДанныхТаблицы = "Объект." + ТаблицаФормы_.Имя;
							КонецЕсли;
						КонецЕсли;
					Иначе
						ИмяДанныхТаблицы = ТаблицаФормы_.Имя;
					КонецЕсли;
				#КонецЕсли
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяДанныхТаблицы) Тогда
				Колво = ТаблицаФормы_.ВыделенныеСтроки.Количество();
				ДанныеТаблицы = Вычислить("Форма." + ИмяДанныхТаблицы);
				Все = (Колво < 2) ИЛИ (Колво = ДанныеТаблицы.Количество());
				Если Все Тогда
					МассивВЧёмМенять = ДанныеТаблицы;
				Иначе
					Для каждого ВСтрока Из ТаблицаФормы_.ВыделенныеСтроки Цикл
						МассивВЧёмМенять.Добавить(ДанныеТаблицы.НайтиПоИдентификатору(ВСтрока));
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		Иначе
			МассивВЧёмМенять = МассивСтрокКИзменению;
		КонецЕсли;
	#КонецОбласти
	Для каждого СтрокаЗамены Из МассивВЧёмМенять Цикл
		ТекЗнч = СтрокаЗамены[ИмяДанныхПоляВТаблице];
		Если НЕ Инвертировать Тогда
			Если (ТекЗнч = Неопределено) ИЛИ (ТекЗнч = Истина) ИЛИ (ТекЗнч = Ложь) ИЛИ (ТекЗнч = 0) ИЛИ (ТекЗнч = 1) ИЛИ (ТекЗнч = 2) Тогда
				Если ТекЗнч <> НовоеЗначение Тогда
					Результат.Добавить(СтрокаЗамены);
					СтрокаЗамены[ИмяДанныхПоляВТаблице] = НовоеЗначение;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Результат.Добавить(СтрокаЗамены);
			Если ТекЗнч = Неопределено Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = НовоеЗначение <> Неопределено;
			ИначеЕсли ТекЗнч = Истина Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = Истина, Ложь, НовоеЗначение);
			ИначеЕсли ТекЗнч = Ложь Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = Ложь, Неопределено, Истина);
			ИначеЕсли ТекЗнч = 2 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 2, 0, 1);
			ИначеЕсли ТекЗнч = 1 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 1, 0, НовоеЗначение);
			ИначеЕсли ТекЗнч = 0 Тогда
				СтрокаЗамены[ИмяДанныхПоляВТаблице] = ?(НовоеЗначение = 0, 2, 1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // УстановитьФлаги
	
#КонецОбласти

#Область ДАТЫ_И_ПЕРИОДЫ
	
// Возвращает граничную дату по варианту СДН или СП. Аналог обращений СтандартнаяДатаНачала.Дата или СтандартныйПериод.ДатаОкончания,
//но дляотсчёта от несегодня СДП и СДН неприменимы.
// Параметры:
//  ДатаОтсчёта  - Дата - Дата отсчёта для вычисления периода
//	Вариант - ВариантСтандартнойДатыНачала/ВариантСтандартногоПериода - вариант из СДП или СДН, применяемый к ДатаОтсчёта
//	Начало - Неопределено/Булево - При Истина возращается дата начала периода. При Ложь - возвращается конец.
//			По умолчанию Неопределено - возвращается структура с ключами Дата1 и Дата2.
//			Для СДН Конец = Дата-1, начало = Дата, т.е. Конец < Начало.
// Возвращаемое значение:
//   Дата   - Найденная граничная дата
Функция ДатаПоВарианту(ДатаОтсчёта, Вариант, Начало = Неопределено) Экспорт
	Результат = ?(Начало, '00000000', '39991231235959');
	Если Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоГода Тогда
		Дата1 = Дата(Год(ДатаОтсчёта) - 1, 1, 1);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоДня Тогда
		Дата1 = НачалоДня(ДатаОтсчёта - 24 * 3600);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоКвартала Тогда
		Дата1 = ДобавитьМесяц(НачалоКвартала(ДатаОтсчёта), -3);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоМесяца Тогда
		Дата1 = ДобавитьМесяц(НачалоМесяца(ДатаОтсчёта), -1);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлогоПолугодия Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) < 7 Тогда
			Дата1 = ДобавитьМесяц(Дата1, -6);
		КонецЕсли;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлойДекады Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) > 20 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
		КонецЕсли;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоПрошлойНедели Тогда
		Дата1 = НачалоНедели(ДатаОтсчёта) - 7 * 24 * 3600;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоГода Тогда
		Дата2 = КонецГода(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоДня Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоКвартала Тогда
		Дата2 = КонецКвартала(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоМесяца Тогда
		Дата2 = КонецМесяца(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующегоПолугодия Тогда
		Дата2 = КонецГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) < 7 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -6);
		КонецЕсли;
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующейДекады Тогда
		Дата2 = КонецМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -1) + 10 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
		КонецЕсли;
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоСледующейНедели Тогда
		Дата2 = КонецНедели(ДатаОтсчёта);
		Дата1 = Дата2 + 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоГода Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоДня Тогда
		Дата1 = НачалоДня(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоКвартала Тогда
		Дата1 = НачалоКвартала(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоМесяца Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтогоПолугодия Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) > 6 Тогда
			Дата1 = ДобавитьМесяц(ДатаОтсчёта, 6);
		КонецЕсли;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтойДекады Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) > 10 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) > 20 Тогда
			Дата1 = Дата1 + 20 * 24 * 3600;
		КонецЕсли;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.НачалоЭтойНедели Тогда
		Дата1 = НачалоНедели(ДатаОтсчёта);
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартнойДатыНачала.ПроизвольнаяДата Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = Дата1 - 1;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Вчера Тогда
		Дата2 = НачалоДня(ДатаОтсчёта) - 1;
		Дата1 = НачалоДня(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоГода Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецГода(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоКвартала Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецКвартала(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоМесяца Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецМесяца(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтогоПолугодия Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) < 7 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -6);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтойДекады Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -1) + 10 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ДоКонцаЭтойНедели Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = КонецНедели(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Завтра Тогда
		Дата1 = КонецДня(ДатаОтсчёта) + 1;
		Дата2 = КонецДня(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Месяц Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = ДобавитьМесяц(Дата2, -1) + 1;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Последние7Дней Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = Дата2 + 1 - 7 * 24 * 3600;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод Тогда
		Дата1 = ДатаОтсчёта;
		Дата2 = ДатаОтсчёта;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяДекада Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата2 = Дата1 - 1;
			Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		Иначе
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяДекадаДоТакогоЖеНомераДня Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата1 = ДобавитьМесяц(Дата1, -1) + 20 * 24 * 3600;
			Дата2 = ДобавитьМесяц(Дата2, -1) + 20 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата2 = Дата2 - 10 * 24 * 3600;
		Иначе
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата2 - 10 * 24 * 3600;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяНеделя Тогда
		Дата1 = НачалоНедели(ДатаОтсчёта) - 7 * 24 * 3600;
		Дата2 = КонецНедели(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлаяНеделяДоТакогоЖеДняНедели Тогда
		Дата2 = КонецДня(ДатаОтсчёта) - 7 * 24 * 3600;
		Дата1 = НачалоНедели(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлоеПолугодие Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) < 7 Тогда
			Дата1 = ДобавитьМесяц(Дата1, -6);
		КонецЕсли;
		Дата2 = ДобавитьМесяц(Дата1 - 1, 6);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлоеПолугодиеДоТакойЖеДаты Тогда
		Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), -6);
		Дата1 = НачалоГода(Дата2);
		Если Месяц(Дата1) > 6 Тогда
			Дата1 = ДобавитьМесяц(Дата1, 6);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйГод Тогда
		Дата2 = НачалоГода(ДатаОтсчёта) - 1;
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйГодДоТакойЖеДаты Тогда
		Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -12));
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйКвартал Тогда
		Дата2 = НачалоКвартала(ДатаОтсчёта) - 1;
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйКварталДоТакойЖеДаты Тогда
		Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -3));
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйМесяц Тогда
		Дата2 = НачалоМесяца(ДатаОтсчёта) - 1;
		Дата1 = НачалоМесяца(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ПрошлыйМесяцДоТакойЖеДаты Тогда
		Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, -1));
		Дата1 = НачалоМесяца(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Сегодня Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоДня(ДатаОтсчёта);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяДекада Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата1 = Дата1 + 20 * 24 * 3600;
			Дата2 = КонецМесяца(ДатаОтсчёта);
		Иначе
			Дата2 = КонецМесяца(ДатаОтсчёта) + 10 * 24 * 3600 - 1;
			Дата1 = ДобавитьМесяц(Дата1, 1);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяДекадаДоТакогоЖеНомераДня Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата2 + 10 * 24 * 3600;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата1 = Дата1 + 20 * 24 * 3600;
			Дата2 = Дата2 + 10 * 24 * 3600;
		Иначе
			Дата1 = ДобавитьМесяц(Дата1, 1);
			Дата2 = ДобавитьМесяц(Дата2, 1) - 20 * 24 * 3600;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяНеделя Тогда
		Дата1 = КонецНедели(ДатаОтсчёта) + 1;
		Дата2 = КонецНедели(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующаяНеделяДоТакогоЖеДняНедели Тогда
		Дата2 = КонецДня(ДатаОтсчёта) + 7 * 24 * 3600;
		Дата1 = НачалоНедели(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующееПолугодие Тогда
		Дата2 = КонецГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) > 6 Тогда
			Дата2 = ДобавитьМесяц(Дата2, 6);
		КонецЕсли;
		Дата1 = ДобавитьМесяц(Дата1 + 1, -6);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующееПолугодиеДоТакойЖеДаты Тогда
		Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 6);
		Дата1 = НачалоГода(Дата2);
		Если Месяц(Дата1) > 6 Тогда
			Дата1 = ДобавитьМесяц(Дата1, 6);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.Следующие7Дней Тогда
		Дата1 = НачалоДня(ДатаОтсчёта);
		Дата2 = Дата1 + 7 * 24 * 3600 - 1;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийГод Тогда
		Дата1 = КонецГода(ДатаОтсчёта)+ 1;
		Дата2 = КонецГода(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийГодДоТакойЖеДаты Тогда
		Дата2 = КонецДня(ДобавитьМесяц(ДатаОтсчёта, 12));
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийКвартал Тогда
		Дата1 = КонецКвартала(ДатаОтсчёта) + 1;
		Дата2 = КонецКвартала(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийКварталДоТакойЖеДаты Тогда
		Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 3);
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийМесяц Тогда
		Дата1 = КонецМесяца(ДатаОтсчёта) + 1;
		Дата2 = КонецМесяца(Дата1);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СледующийМесяцДоТакойЖеДаты Тогда
		Дата2 = ДобавитьМесяц(КонецДня(ДатаОтсчёта), 1);
		Дата1 = НачалоМесяца(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоГода Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоКвартала Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоМесяца Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоМесяца(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтогоПолугодия Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоГода(Дата2);
		Если Месяц(Дата1) > 6 Тогда
			Дата1 = ДобавитьМесяц(Дата1, 6);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтойДекады Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
		Иначе
			Дата1 = Дата1 + 20 * 24 * 3600;
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.СНачалаЭтойНедели Тогда
		Дата2 = КонецДня(ДатаОтсчёта);
		Дата1 = НачалоНедели(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтаДекада Тогда
		Дата1 = НачалоМесяца(ДатаОтсчёта);
		Если День(ДатаОтсчёта) < 11 Тогда
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		ИначеЕсли День(ДатаОтсчёта) < 21 Тогда
			Дата1 = Дата1 + 10 * 24 * 3600;
			Дата2 = Дата1 + 10 * 24 * 3600 - 1;
		Иначе
			Дата1 = Дата1 + 20 * 24 * 3600;
			Дата2 = КонецМесяца(Дата1);
		КонецЕсли;
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтаНеделя Тогда
		Дата2 = КонецНедели(ДатаОтсчёта);
		Дата1 = НачалоНедели(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтоПолугодие Тогда
		Дата1 = НачалоГода(ДатаОтсчёта);
		Если Месяц(ДатаОтсчёта) > 6 Тогда
			Дата1 = ДобавитьМесяц(Дата1, 6);
		КонецЕсли;
		Дата2 = ДобавитьМесяц(Дата1 - 1, 6);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотГод Тогда
		Дата2 = КонецГода(ДатаОтсчёта);
		Дата1 = НачалоГода(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотКвартал Тогда
		Дата2 = КонецКвартала(ДатаОтсчёта);
		Дата1 = НачалоКвартала(Дата2);
	ИначеЕсли Вариант = ВариантСтандартногоПериода.ЭтотМесяц Тогда
		Дата2 = КонецМесяца(ДатаОтсчёта);
		Дата1 = НачалоМесяца(Дата2);
	Иначе
		Дата1 = ДатаОтсчёта;
		Дата2 = ДатаОтсчёта;
	КонецЕсли;
	Возврат ?(Начало = Неопределено, Новый Структура("Дата1,Дата2", Дата1, Дата2), ?(Начало, Дата1, Дата2));
КонецФункции // ДатаПоВарианту

// Возвращает текущую дату клиента или сервера
// Параметры:
//  Универсальная  - Булево - На сервере вернуть униврсальную дату. Ложь (по умолчанию) с сервера возвратит дату сеанса
// Возвращаемое значение:
//   Дата   - Текущая дата клиента или сервера
Функция ЗасечьВремя(Универсальная = Ложь) Экспорт
	Если МестоВыполненияКода(Истина) = "Клиент" Тогда
		Результат = ТекущаяДата();
	Иначе
		Если Универсальная Тогда
			Код = "ТекущаяУниверсальнаяДата()";
		Иначе
			Код = "ТекущаяДатаСеанса()";
		КонецЕсли;
		Результат = Вычислить(Код);
	КонецЕсли;
	Возврат Результат
КонецФункции // ЗасечьВремя

// Возвращает соответствие месяца номеру.
// Параметры:
//   КлючСтрокаЗначениеЧисло - Булево - Ложь (по умолч) = Ключи = цифры (значения первая заглавная), Истина = Ключи = Строки (ВРЕГ), строки всегда без предлогов
//   Формат_ - Строка -
//			*В среду
//          *Все (только для КлючСтрокаЗначениеЧисло = Истина)
//          *Все среды
//			*До среды
//			*К среде
//			*По средам
//			*Среда (по умолчанию)
// Возвращаемое значение:
//   Соответствие   - месяцев и их номеров
Функция СоответствиеДнейНедели(КлючСтрокаЗначениеЧисло = Ложь, Формат_ = "Среда") Экспорт
	Результат = Новый Соответствие;
	Если КлючСтрокаЗначениеЧисло Тогда
		Если Формат_ = "Среда" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИК", 1);
			Результат.Вставить("ВТОРНИК", 2);
			Результат.Вставить("СРЕДА", 3);
			Результат.Вставить("ЧЕТВЕРГ", 4);
			Результат.Вставить("ПЯТНИЦА", 5);
			Результат.Вставить("СУББОТА", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЕ", 7);
		КонецЕсли;
		Если Формат_ = "По средам" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИКАМ", 1);
			Результат.Вставить("ВТОРНИКАМ", 2);
			Результат.Вставить("СРЕДАМ", 3);
			Результат.Вставить("ЧЕТВЕРГАМ", 4);
			Результат.Вставить("ПЯТНИЦАМ", 5);
			Результат.Вставить("СУББОТАМ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЯМ", 7);
		КонецЕсли;
		Если Формат_ = "В среду" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИК", 1);
			Результат.Вставить("ВТОРНИК", 2);
			Результат.Вставить("СРЕДУ", 3);
			Результат.Вставить("ЧЕТВЕРГ", 4);
			Результат.Вставить("ПЯТНИЦУ", 5);
			Результат.Вставить("СУББОТУ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЕ", 7);
		КонецЕсли;
		Если Формат_ = "До среды" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИКА", 1);
			Результат.Вставить("ВТОРНИКА", 2);
			Результат.Вставить("СРЕДЫ", 3);
			Результат.Вставить("ЧЕТВЕРГА", 4);
			Результат.Вставить("ПЯТНИЦЫ", 5);
			Результат.Вставить("СУББОТЫ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЯ", 7);
		КонецЕсли;
		Если Формат_ = "К среде" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИКУ", 1);
			Результат.Вставить("ВТОРНИКУ", 2);
			Результат.Вставить("СРЕДЕ", 3);
			Результат.Вставить("ЧЕТВЕРГУ", 4);
			Результат.Вставить("ПЯТНИЦЕ", 5);
			Результат.Вставить("СУББОТЕ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЮ", 7);
		КонецЕсли;
		Если Формат_ = "Все среды" ИЛИ Формат_ = "Все" Тогда
			Результат.Вставить("ПОНЕДЕЛЬНИКИ", 1);
			Результат.Вставить("ВТОРНИКИ", 2);
			Результат.Вставить("СРЕДЫ", 3);
			Результат.Вставить("ЧЕТВЕРГИ", 4);
			Результат.Вставить("ПЯТНИЦЫ", 5);
			Результат.Вставить("СУББОТЫ", 6);
			Результат.Вставить("ВОСКРЕСЕНЬЯ", 7);
		КонецЕсли;
	Иначе
		Если Формат_ = "Среда" Тогда
			Результат.Вставить(1, "Понедельник");
			Результат.Вставить(2, "Вторник");
			Результат.Вставить(3, "Среда");
			Результат.Вставить(4, "Четверг");
			Результат.Вставить(5, "Пятница");
			Результат.Вставить(6, "СУббота");
			Результат.Вставить(7, "Воскресенье");
		ИначеЕсли Формат_ = "По средам" Тогда
			Результат.Вставить(1, "Понедельникам");
			Результат.Вставить(2, "Вторникам");
			Результат.Вставить(3, "Средам");
			Результат.Вставить(4, "Четвергам");
			Результат.Вставить(5, "Пятницам");
			Результат.Вставить(6, "СУбботам");
			Результат.Вставить(7, "Воскресеньям");
		ИначеЕсли Формат_ = "В среду" Тогда
			Результат.Вставить(1, "Понедельник");
			Результат.Вставить(2, "Вторник");
			Результат.Вставить(3, "Среду");
			Результат.Вставить(4, "Четверг");
			Результат.Вставить(5, "Пятницу");
			Результат.Вставить(6, "СУбботу");
			Результат.Вставить(7, "Воскресенье");
		ИначеЕсли Формат_ = "До среды" Тогда
			Результат.Вставить(1, "Понедельника");
			Результат.Вставить(2, "Вторника");
			Результат.Вставить(3, "Среды");
			Результат.Вставить(4, "Четверга");
			Результат.Вставить(5, "Пятницы");
			Результат.Вставить(6, "СУбботы");
			Результат.Вставить(7, "Воскресенья");
		ИначеЕсли Формат_ = "К среде" Тогда
			Результат.Вставить(1, "Понедельнику");
			Результат.Вставить(2, "Вторнику");
			Результат.Вставить(3, "Среде");
			Результат.Вставить(4, "Четвергу");
			Результат.Вставить(5, "Пятнице");
			Результат.Вставить(6, "СУбботе");
			Результат.Вставить(7, "Воскресенью");
		ИначеЕсли Формат_ = "Все среды" Тогда
			Результат.Вставить(1, "Понедельники");
			Результат.Вставить(2, "Вторники");
			Результат.Вставить(3, "Среды");
			Результат.Вставить(4, "Четверги");
			Результат.Вставить(5, "Пятницы");
			Результат.Вставить(6, "СУбботы");
			Результат.Вставить(7, "Воскресенья");
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // СоответствиеМесяцев

// Возвращает соответствие месяца номеру.
// Параметры:
//   КлючСтрокаЗначениеЧисло - Булево - Ложь (по умолч) = Ключи = цифры (значения Первая Заглавная), Истина = Ключи = Строки (ВРЕГ)
//   Родительный - Булево/Неопределено -
//			Неопределено (по умолч) = для КлючСтрокаЗначениеЧисло = Истина = оба, КлючСтрокаЗначениеЧисло = Ложь = аналогично Ложь;
//			Ложь = Строка в именительном падеже,
//			Истина = Строка в родительном падеже
// Возвращаемое значение:
//   Соответствие   - месяцев и их номеров
Функция СоответствиеМесяцев(КлючСтрокаЗначениеЧисло = Ложь, Родительный = Неопределено) Экспорт
	Результат = Новый Соответствие;
	Если КлючСтрокаЗначениеЧисло Тогда
		Если Родительный <> Истина Тогда
			Результат.Вставить("ЯНВАРЬ", 	1);
			Результат.Вставить("ФЕВРАЛЬ", 2);
			Результат.Вставить("МАРТ", 	3);
			Результат.Вставить("АПРЕЛЬ", 	4);
			Результат.Вставить("МАЙ", 	5);
			Результат.Вставить("ИЮНЬ", 	6);
			Результат.Вставить("ИЮЛЬ", 	7);
			Результат.Вставить("АВГУСТ", 	8);
			Результат.Вставить("СЕНТЯБРЬ", 9);
			Результат.Вставить("ОКТЯБРЬ", 10);
			Результат.Вставить("НОЯБРЬ", 	11);
			Результат.Вставить("ДЕКАБРЬ", 12);
		КонецЕсли;
		Если Родительный <> Ложь Тогда
			Результат.Вставить("ЯНВАРЯ", 	1);
			Результат.Вставить("ФЕВРАЛЯ", 2);
			Результат.Вставить("МАРТА", 	3);
			Результат.Вставить("АПРЕЛЯ", 	4);
			Результат.Вставить("МАЯ", 	5);
			Результат.Вставить("ИЮНЯ", 	6);
			Результат.Вставить("ИЮЛЯ", 	7);
			Результат.Вставить("АВГУСТА", 	8);
			Результат.Вставить("СЕНТЯБРЯ", 9);
			Результат.Вставить("ОКТЯБРЯ", 10);
			Результат.Вставить("НОЯБРЯ", 	11);
			Результат.Вставить("ДЕКАБРЯ", 12);
		КонецЕсли;
	Иначе
		Если Родительный = Истина Тогда
			Результат.Вставить(1, "Января");
			Результат.Вставить(2, "Февраля");
			Результат.Вставить(3, "Марта");
			Результат.Вставить(4, "Апреля");
			Результат.Вставить(5, "Мая");
			Результат.Вставить(6, "Июня");
			Результат.Вставить(7, "Июля");
			Результат.Вставить(8, "Августа");
			Результат.Вставить(9, "Сентября");
			Результат.Вставить(10, "Октября");
			Результат.Вставить(11, "Ноября");
			Результат.Вставить(12, "Декабря");
		Иначе
			Результат.Вставить(1, "Январь");
			Результат.Вставить(2, "Февраль");
			Результат.Вставить(3, "Март");
			Результат.Вставить(4, "Апрель");
			Результат.Вставить(5, "Май");
			Результат.Вставить(6, "Июнь");
			Результат.Вставить(7, "Июль");
			Результат.Вставить(8, "Август");
			Результат.Вставить(9, "Сентябрь");
			Результат.Вставить(10, "Октябрь");
			Результат.Вставить(11, "Ноябрь");
			Результат.Вставить(12, "Декабрь");
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции // СоответствиеМесяцев

#КонецОбласти

//Аналог ЕстьNull - чтобы писать формулу одной строкой и не делать доп.переменных
//Параметры:
//	Первое - Произвольное - Значение, сравниваемое с "нежелательным".
//	Второе - Произвольное - "Нежелательное" значение
//	Третье - Произвольное - Замена "нежелательному" значению.
//Возвращаемое значение:
//	Произвольное - Если Первое = Второму, то Третье, иначе - Первое.
Функция ЕслиПервоеВтороеРавныТоТретьеИначеПервое(Первое, Второе, Третье) Экспорт
	Возврат ?(Первое = Второе, Третье, Первое)
КонецФункции

// Преобразует (сериализует) любое значение в XML-строку.
// Преобразованы в могут быть только те объекты, для которых в синтакс-помощнике указано, что они сериализуются.
// См. также ЗначениеИзСтрокиXML.
//
// Параметры:
//  Значение - Произвольный - значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//  Строка - XML-строка.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает индекс коллекции, соответствующий искомому значению
// Параметры:
//  Искомое  - Число, строка, иное значение, сравнимое на больше-меньше - значение, искомое в коллекции. Значения по умолчанию дают индекс для вставки.
//  Коллекция  - Массив, Таблица значений или иная коллекция - место поиска
//  ИмяРеквизита  - Строка - Имя колонки, в которой ищется Искомое. Для массива не используется. Коллекция должна быть отсортирована.
//  ЕслиНетРавного  - Произвольный - Что вернуть, если равное не найдено. "Меньший", "Больший"  (по умолчанию), "БлижайшийЕслиМежду_Меньший", "БлижайшийЕслиМежду_Больший", или значение, которое будет возвращено.
//  ЕслиМногоРавных  - Произвольный - Что вернуть, если равных несколько. "МеньшийИндекс" (по умолчанию), "БольшийИндекс", "Любой", или значение, которое будет возвращено.
//  СортировкаВозрастание  - Булево - Коллекция отсортирована по возрастанию.
//  Вектор  - Число - -1(по умолчанию) - считаем, что искомое ближе к началу коллекции, 1 - иначе.
// Возвращаемое значение:
//   Число   - Индекс найденного элемента коллекции
Функция ИндексПоловиннымДелением(Искомое, Коллекция, ИмяРеквизита, ЕслиНетРавного = "Больший", ЕслиМногоРавных = "МеньшийИндекс", СортировкаВозрастание = Истина, Вектор = -1) Экспорт
	ЭтоМассив = ТипЗнч(Коллекция) = Тип("Массив");
	Индекс1 = 0;
	Граница = Коллекция.Количество();
	Индекс2 = Граница;
	Результат = 0;
	МеньшийИндекс = ЕслиМногоРавных = "МеньшийИндекс";
	БольшийИндекс = ЕслиМногоРавных = "БольшийИндекс";
	НайденРавный = Ложь;
	Пока Индекс1 < Индекс2 Цикл
		Результат = Индекс1 + ШагПоловинногоДеления(Индекс2 - Индекс1 + 1, Вектор) - 1;
		Показатель = ?(ЭтоМассив, Коллекция[Результат], Коллекция[Результат][ИмяРеквизита]);
		ЭтоРавный = Искомое = Показатель;
		Если ЭтоРавный И ЕслиМногоРавных = "Любой" Тогда
			Прервать;
		ИначеЕсли ЭтоРавный И НайденРавный И НЕ МеньшийИндекс И НЕ БольшийИндекс Тогда
			Результат = ЕслиМногоРавных;
			Прервать;
		ИначеЕсли ЭтоРавный И МеньшийИндекс ИЛИ (Искомое < Показатель) = СортировкаВозрастание Тогда
			Индекс2 = Результат;
		Иначе
			Индекс1 = Результат + 1;
			Результат = Индекс1;
		КонецЕсли;
		НайденРавный = НайденРавный ИЛИ ЭтоРавный;
	КонецЦикла;
	Если НЕ НайденРавный Тогда
		ЭтоМеждуБольший = ЕслиНетРавного = "БлижайшийЕслиМежду_Больший";
		Если ЕслиНетРавного = "Меньший" Тогда
			Результат = Результат - 1;
		ИначеЕсли ЕслиНетРавного = "Больший" Тогда
		ИначеЕсли (ЕслиНетРавного = "БлижайшийЕслиМежду_Меньший") ИЛИ ЭтоМеждуБольший Тогда
			Если Граница < 2 Тогда
				Результат = 0;
			ИначеЕсли Результат > 0 Тогда
				Контрольное = ?(ЭтоМассив,
						Коллекция[Результат] + Коллекция[Результат - 1],
						Коллекция[Результат][ИмяРеквизита] +  Коллекция[Результат - 1][ИмяРеквизита]);
				Если (2 * Искомое > Контрольное) <> СортировкаВозрастание И ((2 * Искомое <> Контрольное) ИЛИ НЕ ЭтоМеждуБольший) Тогда
					Результат = Результат - 1;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Результат = Результат - 1;
		КонецЕсли;
	ИначеЕсли ЕслиМногоРавных = "БольшийИндекс" Тогда
		Результат = Результат - 1;
	КонецЕсли;
	Возврат Результат
КонецФункции // ИндексПоловиннымДелением

//"Клиент", "Сервер", и т.д. Старое название - РежимЗапуска
//Параметры:
//	КлиентИлиСерверВЦелом - Булево - Вернуть просто "Клиент" или "Сервер", не уточняя, какой именно. По умолчанию Ложь. 
//Возвращаемое значение:
//	Строка - Обозначение текущего места выполнения кода
Функция МестоВыполненияКода(КлиентИлиСерверВЦелом = Ложь) Экспорт
	Результат = "Странный";
	Если КлиентИлиСерверВЦелом Тогда
		#Если Клиент Тогда
			Результат = "Клиент";
		#ИначеЕсли Сервер Тогда
			Результат = "Сервер";
		#КонецЕсли
	КонецЕсли;
	Если Результат = "Странный" Тогда
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			Результат = "ТолстыйКлиентОбычноеПриложение";
		#ИначеЕсли МобильноеПриложениеКлиент Тогда
			Результат = "МобильноеПриложениеКлиент";
		#ИначеЕсли МобильноеПриложениеСервер Тогда
			Результат = "МобильноеПриложениеСервер";
		#ИначеЕсли ТолстыйКлиентУправляемоеПриложение Тогда
			Результат = "ТолстыйКлиентУправляемоеПриложение";
		#ИначеЕсли Сервер Тогда
			Результат = "Сервер";
		#ИначеЕсли ВнешнееСоединение Тогда
			Результат = "ВнешнееСоединение";
		#ИначеЕсли ТонкийКлиент Тогда
			Результат = "ТонкийКлиент";
		#ИначеЕсли ВебКлиент Тогда
			Результат = "ВебКлиент";
		#КонецЕсли
	КонецЕсли;
	Возврат Результат
КонецФункции // МестоВыполненияКода()

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
// Параметры:
//  РаспределяемаяСумма - Число - сумма, которую надо распределить;
//  МассивКоэффициентов - Массив - коэффициенты распределения;
//  Точность - Число - точность округления при распределении. Необязателен.
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае если распределить не удалось (сумма = 0, кол-во коэффициентов = 0,
//           или суммарный вес коэффициентов = 0), тогда возвращается значение Неопределено.
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, Коэффициенты, Знач Точность = 2) Экспорт
	Если Коэффициенты.Количество() = 0 Или Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИндексМаксимальногоКоэффициента = 0;
	МаксимальныйКоэффициент = 0;
	РаспределеннаяСумма = 0;
	СуммаКоэффициентов  = 0;
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Коэффициент = Коэффициенты[Индекс];
		АбсолютноеЗначениеКоэффициента = ?(Коэффициент > 0, Коэффициент, -Коэффициент);
		Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
			МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
			ИндексМаксимальногоКоэффициента = Индекс;
		КонецЕсли;
		СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
	КонецЦикла;
	Если СуммаКоэффициентов = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Новый Массив(Коэффициенты.Количество());
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Результат[Индекс] = Окр(РаспределяемаяСумма * Коэффициенты[Индекс] / СуммаКоэффициентов, Точность, 1);
		РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
	КонецЦикла;
	// Погрешности округления отнесем на коэффициент с максимальным весом.
	Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
		Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + РаспределяемаяСумма - РаспределеннаяСумма;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//Возвращает Истина, Если Значнние1 = Значение2
//Параметры:
//	Значение1 - Произвольное сериализуемое - для сравнения
//	Значение2 - Произвольное сериализуемое - для сравнения
//	Возвращаемое значение:
//		Булево - равны ли параметры
Функция УниверсальныеЗначенияСовпадают(Значение1, Значение2) Экспорт
	Если Значение1 = Неопределено Или Значение2 = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Значение1 = Значение2
		Или ЗначениеВСтрокуXML(Значение1) = ЗначениеВСтрокуXML(Значение2);
КонецФункции

// Возвращает шаг половинного деления по длине отрезка. Предполагается, что ожидаемое значение в интервале задано нормальным распределением с пиком примерно в трети от одного из концов отрезка
// Параметры:
// ДлинаОтрезкаМасштабов   - Число - Длина отрезка
// Вектор   - Число - -1 или 1 или 0 (по умолчанию). 1 показывает, что пик распределения ближе к концу отрезка, -1 - что к началу, 0 - Строго пополам
// Возвращаемое значение:
//   Число   - Длина шага половинного деления (куда сделать ход). Например, для 7 возвратит 4.
Функция ШагПоловинногоДеления(ДлинаОтрезкаМасштабов, Вектор) Экспорт
	Возврат ?(Вектор = 0, Цел((ДлинаОтрезкаМасштабов + 1)/ 2), (1 + Вектор) * (ДлинаОтрезкаМасштабов + 1) / 2 - Вектор * Pow(2, Цел(Log(ДлинаОтрезкаМасштабов + 1) / Log(2))) / 2)
КонецФункции // ШагПоловинногоДеления
 
#КонецОбласти

