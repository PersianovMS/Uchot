#Область БИБЛИОТЕКА_ФУНКЦИЙ

#Область ОТЛАДКА

//Читает набор записей и возвращает таблицу значений - его содержимое.
//Иногда может быть пригодна для чтения движений, уже записанных в базу.
//Параметры:
//	НаборЗаписей - Набор записей регистра - читаемый набор записей.
//Возвращаемое значение - Таблица значений - Куда выгружен прочитанный НЗ.
Функция ПрочитатьНаборЗаписейДляОтладки(НаборЗаписей, ВернутьКакБыло = Истина) Экспорт
	Попытка
		Если ВернутьКакБыло Тогда
			ВремТЗ = НаборЗаписей.Выгрузить();
			НаборЗаписей.Прочитать();
			Результат = НаборЗаписей.Выгрузить();
			НаборЗаписей.Загрузить(ВремТЗ);
		Иначе
			НаборЗаписей.Прочитать();
			Результат = НаборЗаписей.Выгрузить();
		КонецЕсли; 
	Исключение
		Результат = Ложь;
	КонецПопытки;	
	Возврат Результат
КонецФункции

// Выполняет код и возвращает рассчитанное значение
// Параметры:
//	ТекстКодаПараметр - Строка - Выполняемый код
//	Прм - Произвольный, обычно структура - параметры, по умолчанию Неопределено
//	Результат - Произвольный - Результат, возвращаемый по умолчанию, по умолчанию Неопределено
//	РежимВычисления - Булево - 
//			* При Истина к ТекстКода применяется Вычислить
//			* При Ложь - Выполнить, а возвращается значение переменной Результат.
//			По умолчанию Ложь
//	ПрямоеОбращение - Строка, Массив - Ключи параметров, которые надо сделать доступными в ТекстКода без применения "Прм.".
//			"-В" (По умолчанию) означает, что все ключи Прм переводятся в прямой доступ.  
//	Журнал - Булево - Выполнять в попытке и ошибку записать в журнал
//	ИмяПроцесса - Строка - Параметр записи журнала
//	ПрефиксОшибки - Строка - Префикс, записываемый в журнал перед сообщением об ошибке.
//Возвращаемое значение:
//		Произвольное - то, что будет вычислено.
Функция ВыполнитьКод(
		ТекстКодаПараметр,
		Прм = Неопределено,
		Результат = Неопределено,
		РежимВычисления = Ложь,
		ПрямоеОбращение = "-В",
		Журнал = Ложь,
		ИмяПроцесса = "",
		ПрефиксОшибки = "") Экспорт
	Результат_ = Результат;
	#Область ЗАЩИТА
		//Предполагается, что обычным пользователям доступ к выполнению функции ограничен, так как иначе УстановитьПривилегированныйРежим, и всё доступно.
		//А вот от легального входа ограниченного пользователя внешним соединением с последующим запуском этой функции нужна защита.
		//Специальная роль (которой можно и не делать) ИЛИ Запуск тонкого/толстого клиента ИЛИ Фоновое задание без пользователя.
		//Хотя внешнее соединение тоже может запустить реглзадание, и тут пока нет защиты, хотя ВС должен быть админом для запуска РЗ.
		Попытка
			МожноВычислять = РольДоступна("ВОЛНА_ВыполнениеПроизвольногоКодаПриВызовеСервера");
		Исключение
			МожноВычислять = Ложь;
		КонецПопытки;
		Если ТекущийРежимЗапуска() <> Неопределено ИЛИ
				ИмяПользователя() = "" Тогда
			МожноВычислять = Истина;
		Иначе
			Попытка
				МожноВычислять = РольДоступна("ВОЛНА_ВыполнениеПроизвольногоКодаПриВызовеСервера");
			Исключение
				МожноВычислять = Ложь;
			КонецПопытки;
		КонецЕсли;
	#КонецОбласти
	Если МожноВычислять Тогда
		Результат_ = ВОЛНА_ОбщегоНазначения_КлиентСервер.ВыполнитьКод(ТекстКодаПараметр, Прм, Результат, РежимВычисления, ПрямоеОбращение, Журнал, ИмяПроцесса, ПрефиксОшибки)
	КонецЕсли;
	Возврат Результат_
КонецФункции

#Конецобласти

#Область МЕНЕДЖЕРЫ_РАСПОЗНАВАНИЕ_И_РАСЧЁТ
	
// Запускает менеджер (обработчик) реквизита или события.
// Параметры:
//  Менеджер  - Строка, Дополнительная обработка УФ, Внешняя обработка ОФ, ПереопределяемаяПроцедура, Путь к файлу обработки или иное значение - Путь к менеджеру, код менеджера или иное.
//			В ПП стандартный возврат Результата, в ВО - запуск метода обработки "ЗапуститьМенеджер(ПараметрыМенеджера)",
//			в ДО - запуск серверного метода "ВыполнитьКоманду" с заданным в параметрах именем команды или командой "ЗапуститьМенеджер" по умолчанию.
//			Все параметры (АдресВременногоХранилища, ПолучитьСКД, ПолучитьНастройкиСКД, ПолучитьПараметры) передаются в ПараметрахМенеджера.
//			СТРОКА обрабатывается в таком порядке:
//					1.Проверка на Префикс "Результат =" - такая строка считается исполняемым кодом;
//					2.Проверка на служебные префиксы:
//						*"F:" - путь к файлу обработки для исполнения,
//						*"Т:" (рус) - строка,
//						*"В:" (рус) - вычисление,
//						*"Р:" (рус) - распознавание,
//					3.Попытка вычислить;
//					4.Попытка распознать по строке с применением типов из массива ТипыДляРаспознавания; Если массив пустой, распознавание идёт по всем типам, если Неопределено, шаг пропускается.
//					5.Возврат самой строки.
//  ПараметрыМенеджера  - Структура - Параметры, передаваемые для применения в менеджере. В формуле обозначаются Прм.
//  ТипыДляРаспознавания  - Массив типов или менеджеров прикладного типа или менеджер прикладного типа или тип - допустимые типы результата при распознавании.
//  ОбработкаИсключения  - Код выполнения распознавания. Выполняется, если менеджер - не строка и не выполняемая обработка.
//  ПоРеквизиту  - Имя реквизита, по которому вести распознавание.
//  Родитель  - Родитель, внутри которого вести распознавание.
//  Владелец  - Владелец, внутри которого вести распознавание.
//	СообщатьСюда - Строка или Неопределено - По умолчанию Неопределено. Если указана строка, сообщения выводятся в неё, а не на экран.
// Возвращаемое значение:
//   Произвольное   - Результат, возвращаемый менеджером
Функция ЗапуститьМенеджер(
		Менеджер,
		ПараметрыМенеджера = Неопределено,
		ТипыДляРаспознавания = Неопределено,
		ОбработкаИсключения = "",
		ПоРеквизиту = "",
		Родитель = Неопределено,
		Владелец = Неопределено,
		СообщатьСюда = Неопределено) Экспорт
	ЕстьСтрокаТабло = СообщатьСюда <> Неопределено;
	ЕстьДопИнструменты = ВОЛНА_ОбщегоНазначения_ВСПовтИспСеанс.ЕстьДопОбработки();
	ТипМенеджера = ТипЗнч(Менеджер);
	Результат = Менеджер;
	ТекстКода = "";
	Распознать = "";
	Если ПараметрыМенеджера = Неопределено Тогда
		ПараметрыМенеджера = Новый Структура; 
	КонецЕсли; 
	
	Если ТипМенеджера = Тип("Строка") Тогда
		//Это строка
		ТекПрефикс = Лев(Менеджер, 2);
		Если ТекПрефикс = "Т:" Тогда
			Результат = Сред(Менеджер, 3);//Получить строку без лишних заморочек
		ИначеЕсли Лев(Менеджер, 11) = "Результат =" Тогда
			ТекстКода = Менеджер;
		ИначеЕсли ТекПрефикс = "F:" Тогда
			ИмяФайла = Сред(Менеджер, 3);
			Результат = ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, ПараметрыМенеджера);
		ИначеЕсли ТекПрефикс = "В:" Тогда
			Результат = ВыполнитьКод(СтрЗаменить(Сред(Менеджер, 3), Символ(10), " "), ПараметрыМенеджера,, Истина);
		ИначеЕсли ТекПрефикс = "Р:" Тогда
			Распознать = Сред(Менеджер, 3); 
		Иначе
			ПрогКод = СтрЗаменить(Менеджер, Символ(10), " ");
			Попытка
				Результат = ВыполнитьКод(ПрогКод, ПараметрыМенеджера,, Истина);
			Исключение
				Распознать = Менеджер;
			КонецПопытки;
		КонецЕсли;
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьПП, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаПП), Неопределено) Тогда
		//Это ПП
		ТекстКода = "Результат = Справочники.ВОЛНА_ПереопределяемыеПроцедуры.ВычислитьФункцию(Менеджер,, ПараметрыМенеджера,
				|?(ПараметрыМенеджера.Свойство(""ПолучитьСКД""), ПараметрыМенеджера.ПолучитьСКД, Ложь),
				|?(ПараметрыМенеджера.Свойство(""ПолучитьНастройкиСКД""), ПараметрыМенеджера.ПолучитьНастройкиСКД, Ложь),
				|?(ПараметрыМенеджера.Свойство(""ПолучитьПараметры""), ПараметрыМенеджера.ПолучитьПараметры, Ложь));"
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьВО, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаВО), Неопределено) Тогда
		//Это ВО
		Если БезопасныйРежим() Тогда
			Результат = Неопределено;
			ДобавитьОшибку(ПараметрыМенеджера, "В безопасном режиме нельзя прочитать временный файл и запустить внешнюю обработку!");
		Иначе
			ТекстКода = "ЭтоОбработка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Менеджер, ""ВидОбработки"") = Перечисления.ВидыДополнительныхВнешнихОбработок.Обработка;
					|Если ЭтоОбработка Тогда
					|	Попытка
					|		ИмяФайла = ПолучитьИмяВременногоФайла();
					|		ДвоичныеДанные = Менеджер.ХранилищеВнешнейОбработки.Получить();
					|		ДвоичныеДанные.Записать(ИмяФайла);
					|		Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, ПараметрыМенеджера);
					|	Исключение
					|		ООШ = ОписаниеОшибки();
					|		ДобавитьОшибку(ПараметрыМенеджера, ООШ);
					|		Результат = Менеджер;
					|	КонецПопытки;
					|КонецЕсли;"
		КонецЕсли; 
	ИначеЕсли ТипМенеджера = ?(ЕстьДопИнструменты.ЕстьДО, Тип("СправочникСсылка." + ЕстьДопИнструменты.ИмяТипаДО), Неопределено) Тогда
		//Это ДО
		ТекстКода = "ПараметрыКоманды = Новый Структура(""ДополнительнаяОбработкаСсылка,ИдентификаторКоманды,ОбъектыНазначения"",
				|		Менеджер, ?(ПараметрыМенеджера.Свойство(""ИмяКоманды""), ПараметрыМенеджера.ИмяКоманды, ""ЗапуститьМенеджер""),
				|		?(ПараметрыМенеджера.Свойство(""ОбъектыНазначения""), ПараметрыМенеджера.ОбъектыНазначения, Новый Массив));
				|Если ПараметрыМенеджера.Свойство(""АдресВременногоХранилища"") Тогда
				|	ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды, ПараметрыМенеджера.АдресВременногоХранилища);
				|	Результат = ПолучитьИзВременногоХранилища(ПараметрыМенеджера.АдресВременногоХранилища);
				|Иначе
				|	ДополнительныеОтчетыИОбработки.ВыполнитьКоманду(ПараметрыКоманды);
				|	Результат = ПараметрыКоманды.Результат;
				|КонецЕсли;
				|Если ПараметрыКоманды.Свойство(""ОписаниеОшибки"") Тогда
				|	ДобавитьОшибку(ПараметрыМенеджера, ПараметрыКоманды.ОписаниеОшибки);
				|КонецЕсли";
	ИначеЕсли ОбработкаИсключения <> "" Тогда
		Попытка
			ВыполнитьКод(ОбработкаИсключения, ПараметрыМенеджера, Результат);
		Исключение
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		КонецПопытки;
	КонецЕсли;
	Если Распознать <> "" Тогда
		Результат = РаспознатьЗначение(Распознать, ТипыДляРаспознавания, ПоРеквизиту, Родитель, Владелец);
	ИначеЕсли ТекстКода <> "" Тогда
		Попытка
			ВыполнитьКод(ТекстКода, ПараметрыМенеджера, Результат);
		Исключение
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(ПараметрыМенеджера, ООШ);
		КонецПопытки;
	КонецЕсли; 
	
	Если ПараметрыМенеджера.Свойство("ОписаниеОшибки") Тогда
		ТекстСообщения = ПараметрыМенеджера.ОписаниеОшибки;
		Если ЕстьСтрокаТабло Тогда
			СообщатьСюда = СообщатьСюда + ТекстСообщения + Символы.ПС;
		Иначе
			Сообщить(ТекстСообщения);
		КонецЕсли;		
		ПараметрыМенеджера.Вставить("ПоследняяОшибка", ПараметрыМенеджера.ОписаниеОшибки);
		ПараметрыМенеджера.Удалить("ОписаниеОшибки");
	КонецЕсли; 
	Возврат Результат;
КонецФункции // ЗапуститьМенеджер()

//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим уже д.б. проверен. Вспомогательная для ЗапуститьМенеджер.
//Параметры:
//	ИмяФайла - Строка - Полный путь к файлу обработки;
//	Параметры_ - Параметры выполнения, передаваемые в метод.
//Возвращаемое значение;
//	Произвольный - Результат, возвращаемый методом
Функция ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_)
	ВнешняяОбработка = ВнешниеОбработки.Создать(ИмяФайла);
	Возврат ВнешняяОбработка.ЗапуститьМенеджер(Параметры_);
КонецФункции
 
//Запускает экспортную функцию "ЗапуститьМенеджер" обработки из указанного файла. Безопасный режим проверяется этой функцией. Вспомогательная для ЗапуститьМенеджер.
//Параметры:
//	ИмяФайла - Строка - Полный путь к файлу обработки;
//	Параметры_ - Параметры выполнения, передаваемые в метод. В ключе "ОписаниеОшибки" возвращается строка - список ошибок выполнения.
//Возвращаемое значение;
//	Произвольный - Результат, возвращаемый методом. При ошибке - Неопределено.
Функция ЗапуститьОбработкуИзФайлаСПроверкойБР(ИмяФайла, Параметры_)
	Если БезопасныйРежим() Тогда
		Результат = Неопределено;
		ДобавитьОшибку(Параметры_, "В безопасном режиме нельзя прочитать " + ИмяФайла);
	Иначе
		Попытка
			Результат = ЗапуститьОбработкуИзФайла(ИмяФайла, Параметры_);
		Исключение
			Результат = Неопределено;
			ООШ = ОписаниеОшибки();
			ДобавитьОшибку(Параметры_, "Обработка " + ИмяФайла + " не была выполнена по причине:" + ООШ);
		КонецПопытки;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Вспомогательная для ЗапуститьМенеджер.
// Добавляет переданную строку в ключ ОписаниеОшибки структуры параметров.
//Параметры:
//	Параметры_	- Структура - в ключ ОписаниеОшибки которой будет дописано сообщение;
//	Описание	-	Текст описания ошибки, записываемый в структуру
Процедура ДобавитьОшибку(Параметры_, Описание)
	Если Параметры_.Свойство("ОписаниеОшибки") Тогда
		Параметры_.ОписаниеОшибки = Параметры_.ОписаниеОшибки + "; " + Описание;
	Иначе
		Параметры_.Вставить("ОписаниеОшибки", Описание);
	КонецЕсли; 
КонецПроцедуры

//Возвращает результат распознавания строкового значения
//Параметры:
//	Значение_ - Строка - Распознаваемое значение в строковом выражении
//	ТипыИлиМенеджеры - Менеджер ссылочного значения или массив таких менеджеров или тип/массивТипов - типы, в которых ищется ссылочное значение. Если опущен, то возвращается простое нессылочное значение.
//	ПоРеквизиту - Строка - Имя реквизита, в котором ищется значение.
//	Родитель - ЛюбаяСсылка - Если требуется поиск по родителю, то задавать сюда. По умолчанию Неопределено (поиск не используется). Для поиска документа по номеру в этот реквизит надо поместить дату.
//	Владелец - ЛюбаяСсылка - Если требуется поиск по владельцу, то задавать сюда. По умолчанию Неопределено (поиск не используется)
//	АпострофЭтоСтрока - Булево - По умолчанию Истина. Значение, начинающееся с апострофа, будет считаться строкой.
//	НеРаспознаватьУИДБезТипа - Булево - По умолчанию Ложь. Отключает распознавание нетипизированных УИДов, что в некоторых случаях сильно ускорит выполнение.
//Возвращаемое значение:
//	Произвольный - Распознанное значение
Функция РаспознатьЗначение(Значение_, ТипыИлиМенеджеры = "", ПоРеквизиту = "", Родитель = Неопределено, Владелец = Неопределено, АпострофЭтоСтрока = Истина, НеРаспознаватьУИДБезТипа = Ложь) Экспорт
	Результат = Значение_;
	ВРЕГ_ = Врег(Значение_);
	Если АпострофЭтоСтрока И Лев(ВРЕГ_, 1) = "'"  Тогда
		Результат = Сред(Значение_, 2);
	Иначе
		Распознан = Ложь;
		ЭтоСтрока = Ложь;
		ЭтоЧисло = Ложь;
		ЭтоДата = Ложь;
		ЭтоБулево = Ложь;
		ЭтоУниверсал = ТипыИлиМенеджеры = "";
		Если НЕ ЭтоУниверсал Тогда
			мТиМ = ВОЛНА_ОбщегоНазначения_КлиентСервер.ПреобразоватьВМассив(ТипыИлиМенеджеры);
			ТипТип = Тип("Тип");
			ТипСтрока = Тип("Строка");
			ТипДата = Тип("Дата");
			ТипЧисло = Тип("Число");
			ТипБулево = Тип("Булево");
			Для каждого ТекТиМ Из мТиМ Цикл
				ТекТип = ТипЗнч(ТекТиМ);
				ОбработатьТип = Ложь;
				Если ТекТип = ТипСтрока Тогда
					ВР_Т = Врег(ТекТиМ);
					Если ВР_Т = "СТРОКА" Тогда
						ЭтоСтрока = Истина;
					ИначеЕсли ВР_Т = "БУЛЕВО" Тогда
						ЭтоБулево = Истина;
					ИначеЕсли ВР_Т = "ЧИСЛО" Тогда
						ЭтоЧисло = Истина;
					ИначеЕсли ВР_Т = "ДАТА" Тогда
						ЭтоДата = Истина;
					Иначе
						ОбработатьТип = Истина;
					КонецЕсли;
				Иначе
					Если ТекТиМ = ТипСтрока Тогда
						ЭтоСтрока = Истина;
					ИначеЕсли ТекТиМ = ТипБулево Тогда
						ЭтоБулево = Истина;
					ИначеЕсли ТекТиМ = ТипЧисло Тогда
						ЭтоЧисло = Истина;
					ИначеЕсли ТекТиМ = ТипДата Тогда
						ЭтоДата = Истина;
					Иначе
						ОбработатьТип = Истина;
					КонецЕсли;
				КонецЕсли;
				Если ОбработатьТип Тогда
					Если ТекТип = ТипТип Тогда
						Менеджер = ИмяТаблицыОбъектаПоТипу(ТекТиМ, "Менеджер"); //ВОЛНА_ОбщегоНазначения_ВСПовтИспСеанс.
					ИначеЕсли ТекТип = ТипСтрока Тогда
						Менеджер = Вычислить(ТекТиМ);
					Иначе
						Менеджер = ТекТиМ;
					КонецЕсли; 
					ТипМенеджера = СтрПолучитьСтроку(СтрЗаменить(Менеджер, ".", Символы.ПС), 1);
					ЭтоУИД_ = ВОЛНА_ОбщегоНазначения_КлиентСервер.ЭтоУИД(Значение_);
					Если ЭтоУИД_ Тогда
						ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(Значение_));
						Если Лев(Строка(ТекСсылка), 18) = "<Объект не найден>" Тогда
							ЭтоУИД_ = Ложь
						Иначе
							Результат = ТекСсылка
						КонецЕсли
					КонецЕсли;
					Если НЕ ЭтоУИД_ И (Менеджер <> Неопределено) Тогда
						Если ТипМенеджера = "ПеречислениеМенеджер" Тогда //"Перечисления"
							//Перечисления грузим особо
							Результат = Менеджер.ПустаяСсылка();
							Если НЕ ПустаяСтрока(Значение_) Тогда
								ЗначенияП = Результат.Метаданные().ЗначенияПеречисления;
								ЗначениеПеречисления = ЗначенияП.Найти(Значение_);
								Если ЗначениеПеречисления = Неопределено Тогда
									Для каждого ЗначениеПеречисления Из ЗначенияП Цикл
										Если ЗначениеПеречисления.Синоним = Значение_ Тогда
											Прервать;
										КонецЕсли; 
									КонецЦикла; 
								КонецЕсли; 
								Если ЗначениеПеречисления <> Неопределено Тогда
									Результат = Менеджер[ЗначениеПеречисления.Имя];
								КонецЕсли; 
							КонецЕсли; 
						Иначе
							Если ПоРеквизиту = "" Тогда
								ПоРеквизиту = ?((ТипМенеджера = "БизнесПроцессМенеджер") ИЛИ (ТипМенеджера = "ДокументМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), "Номер",   //"БизнесПроцессы" "Документы" "Задачи"
										?((ТипМенеджера = "ПланОбменаМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер"), "Код", "Наименование"))
							КонецЕсли;
							ИскатьПоНомеру = ?(ПоРеквизиту = "Номер", (ТипМенеджера = "БизнесПроцессМенеджер") ИЛИ (ТипМенеджера = "ДокументМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), Ложь);
							ИскатьПоКоду = ?(ПоРеквизиту = "Код", (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланОбменаМенеджер") ИЛИ
									(ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер") ИЛИ (ТипМенеджера = "ПланВидовРасчетаМенеджер"), Ложь);
							ИскатьПоНаименованию = ?(ПоРеквизиту = "Наименование", (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланОбменаМенеджер") ИЛИ
									(ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер") ИЛИ (ТипМенеджера = "ПланВидовРасчетаМенеджер") ИЛИ (ТипМенеджера = "ЗадачаМенеджер"), Ложь);
							ИскатьПоРодителю = ?(Родитель = Неопределено, Ложь, (ТипМенеджера = "СправочникМенеджер") ИЛИ (ТипМенеджера = "ПланВидовХарактеристикМенеджер") ИЛИ (ТипМенеджера = "ПланСчетовМенеджер"));
							ИскатьПОВладельцу = ?(Владелец = Неопределено, Ложь, ТипМенеджера = "СправочникМенеджер");
							Нашлось = Неопределено;
							Если ИскатьПоНомеру Тогда
								Если ТипМенеджера = "ДокументМенеджер" Тогда
									Нашлось = Менеджер.НайтиПоНомеру(Значение_, ?(Родитель = Неопределено, ТекущаяДата(), Родитель))
								Иначе
									Нашлось = Менеджер.НайтиПоНомеру(Значение_)
								КонецЕсли;
							ИначеЕсли ИскатьПоКоду Тогда
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель, Владелец)
									ИначеЕсли ТипМенеджера = "СправочникМенеджер" Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь, Родитель)
									Иначе
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Родитель)
									КонецЕсли
								Иначе
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь,, Владелец)
									ИначеЕсли ТипМенеджера = "СправочникМенеджер" Тогда
										Нашлось = Менеджер.НайтиПоКоду(Значение_, Ложь)
									Иначе
										Нашлось = Менеджер.НайтиПоКоду(Значение_)
									КонецЕсли
								КонецЕсли
							ИначеЕсли ИскатьПоНаименованию Тогда
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель, Владелец)
									Иначе
										Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина, Родитель)
									КонецЕсли
								ИначеЕсли ИскатьПоВладельцу Тогда
									Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина,, Владелец)
								Иначе
									Нашлось = Менеджер.НайтиПоНаименованию(Значение_, Истина)
								КонецЕсли
							Иначе
								Если ИскатьПоРодителю Тогда
									Если ИскатьПоВладельцу Тогда
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель, Владелец)
									Иначе
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_, Родитель)
									КонецЕсли
								ИначеЕсли ИскатьПоВладельцу Тогда
									Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_,, Владелец)
								Иначе
									Попытка
										Нашлось = Менеджер.НайтиПоРеквизиту(ПоРеквизиту, Значение_)
									Исключение
										Нащлось = Ложь;
									КонецПопытки;
								КонецЕсли
							КонецЕсли;
							Если ЗначениеЗаполнено(Нашлось) Тогда
								Результат = Нашлось;
							КонецЕсли; 
						КонецЕсли
					КонецЕсли;
					Если Результат <> Значение_ Тогда
						Распознан = Истина;
						Прервать
					КонецЕсли; 
				КонецЕсли;
			КонецЦикла; 
		КонецЕсли;
		Если НЕ Распознан Тогда
			//Возвращается простое значение. Сначала - отработка насильственных типов
			Если (ВРЕГ_ = "ДА" ИЛИ ВРЕГ_ = "ИСТИНА") И (ЭтоУниверсал ИЛИ ЭтоБулево) Тогда
				Результат = Истина;
			ИначеЕсли (ВРЕГ_ = "НЕТ" ИЛИ ВРЕГ_ = "ЛОЖЬ") И (ЭтоУниверсал ИЛИ ЭтоБулево) Тогда
				Результат = Ложь;
			Иначе
				Если ЭтоУниверсал Тогда
					Попытка
						Результат = Вычислить(Значение_);
						Распознан = Истина;
					Исключение
					КонецПопытки;
				КонецЕсли;
				Если НЕ Распознан Тогда
					Если ЭтоУниверсал ИЛИ ЭтоДата Тогда
						Попытка
							ЭтоТолькоВремя = Сред(Значение_, 2, 1) = ":" ИЛИ Сред(Значение_, 3, 1) = ":";
							СтрокаДатаВремя = СтрЗаменить(Значение_, " ", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ":", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, "/", Символы.ПС);
							СтрокаДатаВремя = СтрЗаменить(СтрокаДатаВремя, ".", Символы.ПС);
							Если ЭтоТолькоВремя Тогда
								День    = 1;
								Месяц   = 1;
								Год     = 1;
								Час     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 1)));
								Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 1, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 2))), 0);
								Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 2, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 3))), 0);
							Иначе
								День    = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 1)));
								Месяц   = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 2)));
								Год     = Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 3)));
								Час     = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 3, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 4))), 0);
								Минута  = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 4, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 5))), 0);
								Секунда = ?(СтрЧислоСтрок(СтрокаДатаВремя) > 5, Число(СокрЛП(СтрПолучитьСтроку(СтрокаДатаВремя, 6))), 0);
							КонецЕсли;
							НовДата = ДобавитьМесяц(Дата(1, 1, 1), (Год - 1) * 12 + Месяц - 1) + (День * 24 + Час - 24) * 3600 + Минута * 60 + Секунда;
							Если ЗначениеЗаполнено(НовДата)  Тогда
								Если Год < 100 И НЕ ЭтоТолькоВремя Тогда
									НовДата = ДобавитьМесяц(НовДата, Цел(Год(ТекущаяДатаСеанса()) / 100) * 1200);
								КонецЕсли
							КонецЕсли;
							Результат = НовДата;
							Распознан = Истина;
						Исключение
						КонецПопытки
					КонецЕсли;
					Если НЕ Распознан Тогда
						Если ЭтоУниверсал ИЛИ ЭтоЧисло Тогда
							Попытка
								Результат = Число(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение_, " ", ""), " ", ""), ",", "."));
								Распознан = Истина;
							Исключение
							КонецПопытки;
						КонецЕсли;
						Если НЕ Распознан Тогда
						    Если ЭтоСтрока Тогда
								Результат = Строка(Значение_);
							ИначеЕсли ЭтоБулево Тогда
								Результат = НЕ ПустаяСтрока(Значение_);
							Иначе
								Если ?(НеРаспознаватьУИДБезТипа, Ложь, ВОЛНА_ОбщегоНазначения_КлиентСервер.ЭтоУИД(Значение_)) Тогда
									Результат = UUIDToСсылка(Значение_);
								КонецЕсли;
							КонецЕсли;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли
		КонецЕсли;
	КонецЕсли;
	Возврат Результат
КонецФункции //РаспознатьЗначение

#КонецОбласти 

#Область КОЛЛЕКЦИИ

#Область ПРОИЗВОЛЬНАЯ_КОЛЛЕКЦИЯ
	
// Копирует колонку без данных в приёмник. Возвращает имя добавленной или найденной колонки.
// Параметры:
//  Приёмник  - Коллекция колонко дерева значений, таблицы значений - в которую будут добавлены колонки
//  Колонка  - КолонкаДерева значений, таблицы значений - которую надо перенести
//	ИмяКолонкиВПриёмнике - Строка - Имя соответствующей колонки в приёмнике. По умолчанию "" - имена совпадают.
//	Метод	- Число:
//		* 0 или 3 - Не проверять наличие в приёмнике. Если колонка там есть, при добавлении будет ошибка.
//		* 1 - Проверять наличие в приёмнике. Если колонка там есть, считаем, что всё ок.
//		* 2 - Проверять наличие в приёмнике. Если колонка там есть, старая колонка приёмника будет удалена.
//		* 4 - Проверять наличие в приёмнике. Если колонка там есть, колонка будет добавлена под корректным сгенерированным именем.
//	Возвращаемое значение:
//		Строка - имя колонки (найденной или добавленной);
Функция СкопироватьКолонку(Приёмник, Колонка, ИмяКолонкиВПриёмнике = "", Метод = 3) Экспорт
	Результат = ?(ИмяКолонкиВПриёмнике = "", Колонка.Имя, ИмяКолонкиВПриёмнике);
	Если (Метод = 3) ИЛИ (Метод = 0) Тогда
		НадоДобавить = Истина;
	Иначе
		Ё = 0;
		НадоДобавить = Ложь;
		Пока НЕ НадоДобавить Цикл
			СтараяКолонка = Приёмник.Найти(Результат);
			Если СтараяКолонка = Неопределено Тогда
				НадоДобавить = Истина;
			ИначеЕсли Метод = 4 Тогда
				Результат = Колонка.Имя + Ё;
				Ё = Ё + 1;
			ИначеЕсли Метод = 2 Тогда
				Приёмник.Удалить(СтараяКолонка);
			Иначе
				Прервать
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли;
	Если НадоДобавить Тогда
		Приёмник.Добавить(Результат, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
	КонецЕсли;
	Возврат Результат
КонецФункции// ДобавитьНедостающиеКолонки
 
#КонецОбласти 

#Область ТАБЛИЦЫ_ЗНАЧЕНИЙ

#Область ПРОЦЕДУРА_ОБЪЕДИНИТЬ_ТАБЛИЦЫ
	
//Вспомогательная к следующей экспортной процедуре
Процедура ЗаполнитьСтрокиПоСтруктурам(ТабПриёмник, ТабИсточник, СтруктураКопируемыхКолонок, СтруктураВычисляемыхКолонок)
	Для каждого СтрокаИсточник из ТабИсточник Цикл
		СтрокаПриёмник = ТабПриёмник.Добавить();
		Для каждого Колонка из СтруктураКопируемыхКолонок Цикл
			СтрокаПриёмник[Колонка.Ключ] = СтрокаИсточник[Колонка.Значение]
		КонецЦикла;
		Для каждого Колонка из СтруктураВычисляемыхКолонок Цикл
			СтрокаПриёмник[Колонка.Ключ] = Вычислить(Колонка.Значение)
		КонецЦикла
	КонецЦикла
КонецПроцедуры

//Вспомогательная к следующей экспортной процедуре
Функция ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, Ключ, ТипНовой, ШиринаНовой = 0, ЭтоВычисляемая = Ложь)
	Если КолонкиРезультата.Свойство(Ключ) Тогда
		Если НЕ ЭтоВычисляемая Тогда
			КолонкиРезультата[Ключ].ТипЗначения = ВОЛНА_ОбщегоНазначения_КлиентСервер.ОбъединитьОписанияТипов(КолонкиРезультата[Ключ].ТипЗначения, ТипНовой);
			Если КолонкиРезультата[Ключ].Ширина <> 0 Тогда
				КолонкиРезультата[Ключ].Ширина = Макс(КолонкиРезультата[Ключ].Ширина, ШиринаНовой);
			КонецЕсли;
		КонецЕсли; 
		Возврат Истина;
	Иначе
		Если ЭтоВычисляемая Тогда
			КолонкиРезультата.Вставить(Ключ, Новый Структура("Заголовок,ТипЗначения,Ширина", Ключ,, 0));
		Иначе
			КолонкиРезультата.Вставить(Ключ, Новый Структура("Заголовок,ТипЗначения,Ширина", Ключ, ТипНовой, ШиринаНовой));
		КонецЕсли; 
		Возврат Ложь;
	КонецЕсли; 
КонецФункции

// Объединяет несколько таблиц в одну с учётом типов колонок
// Параметры:
//  СтруктураТаблиц - Массив, структура, фиксированная структура (ФС), список значений или соответствие - Состоит из структур или ФС с информацией об объединяемых таблицах с полями:
//				Таблица - сама таблица (таблица значений или табличная часть);
//				СтруктураКопируемыхКолонок - структура или ФС, где ключ - имя колонки приёмника, а значение - имя источника
//				СтруктураВычисляемыхКолонок - структура или ФС, где ключ - имя колонки приёмника, а значение - формула с возможностью
//						применения переменных СтрокаИсточник, СтрокаПриёмник, ТабИсточник и ТабПриёмник;
//				ОсобыеПоля - строка с именами колонок через ПС или запятую;
//				ВзятьОсобые - Булево. Если Истина, то переносятся Особые поля и поля из СКК и СВК. Если ложь или не указан - переносятся поля из СКК и СВК, а также все поля, не перечисленные в Особых.
//			Если этот параметр - не массив, тогда структуры находятся в значениях.
// Возвращаемое значение:
//   Таблица значений   - Таблица, содержащая объединение таблиц по заданным правилам. Например, чтобы перенести все колонки "один в один", достаточно заполнить ключ "Таблица".
Функция ОбъединитьТаблицы(СтруктураТаблиц) Экспорт
	//Сформировать таблицу - результат: определить имена колонок, типы колонок.
	//Перенести данные таблиц.
	Результат = Новый ТаблицаЗначений;

	#Область ФОРМИРОВАНИЕ_МАССИВА_ОПИСАНИЙ_ТАБЛИЦ
	ТипПараметра = ТипЗнч(СтруктураТаблиц);
	Если (ТипПараметра = Тип("Структура")) ИЛИ (ТипПараметра = Тип("ФиксированнаяСтруктура"))
			ИЛИ (ТипПараметра = Тип("Соответствие")) ИЛИ (ТипПараметра = Тип("ФиксированноеСоответствие")) ИЛИ (ТипПараметра = Тип("СписокЗначений")) Тогда
		МассивТаблиц = Новый Массив;
		Для каждого КиЗ Из СтруктураТаблиц Цикл
			МассивТаблиц.Добавить(КиЗ.Значение);
		КонецЦикла; 
	ИначеЕсли (ТипПараметра = Тип("Массив")) ИЛИ (ТипПараметра = Тип("ФиксированныйМассив")) Тогда
		МассивТаблиц = СтруктураТаблиц;
	Иначе
		МассивТаблиц = Новый Массив;
	КонецЕсли;
	#КонецОбласти

	#Область Формирование_описаний_колонок
	//определяются для квалификаторов:
	//ЧастиДаты,Длина,ДопустимаяДлина,ЧислоРазрядов,ЧислоРазрядовДробнойЧасти,ДопустимыйЗнак,ДлинаСтроки,ДопустимаяДлина 
	КолонкиРезультата = Новый Структура;
	Для каждого ОписаниеТаблицы Из МассивТаблиц Цикл
		Если ОписаниеТаблицы.Свойство("ВзятьОсобые") Тогда
			Если ТипЗнч(ОписаниеТаблицы.ВзятьОсобые) <> Тип("Булево") Тогда
				ОписаниеТаблицы.ВзятьОсобые = Ложь;
			КонецЕсли;
		Иначе
			ОписаниеТаблицы.Вставить("ВзятьОсобые", Ложь);
		КонецЕсли;
		Если НЕ ОписаниеТаблицы.Свойство("ОсобыеПоля") Тогда
			ОписаниеТаблицы.Вставить("ОсобыеПоля", "");
		КонецЕсли;
		Если ОписаниеТаблицы.Свойство("СтруктураКопируемыхКолонок") Тогда
			Для каждого ОписаниеКолонки Из ОписаниеТаблицы.СтруктураКопируемыхКолонок Цикл
				КолонкаИсточник = ОписаниеТаблицы.Таблица.Колонки.Найти(ОписаниеКолонки.Значение);
				Если КолонкаИсточник = Неопределено Тогда
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Удалить(ОписаниеКолонки.Ключ);
				Иначе
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ОписаниеКолонки.Ключ, КолонкаИсточник.ТипЗначения, КолонкаИсточник.Ширина);
					Если (НЕ ОписаниеТаблицы.ВзятьОсобые) И (Найти(ОписаниеТаблицы.ОсобыеПоля, ОписаниеКолонки.Значение) = 0) Тогда
						//Иначе колонка задублируется под другим именем
						ОписаниеТаблицы.ОсобыеПоля = ОписаниеТаблицы.ОсобыеПоля + Символы.ПС + ОписаниеКолонки.Значение;
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла;
		Иначе
			ОписаниеТаблицы.Вставить("СтруктураКопируемыхКолонок", Новый Структура);
		КонецЕсли; 
		Если ОписаниеТаблицы.Свойство("СтруктураВычисляемыхКолонок") Тогда
			//Вычисляемая колонка не меняет типа колонки, если он ранее задан, а если колонка новая - то тип будет произвольный.
			Для каждого ОписаниеКолонки Из ОписаниеТаблицы.СтруктураВычисляемыхКолонок Цикл
				ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ОписаниеКолонки.Ключ, Неопределено,, Истина);
			КонецЦикла;
		КонецЕсли; 
		Если ОписаниеТаблицы.ВзятьОсобые Тогда
			СтрокаПолей = СтрЗаменить(ОписаниеТаблицы.ОсобыеПоля, ",", Символы.ПС);
			Для Ё = 1 По СтрЧислоСтрок(СтрокаПолей) Цикл
				ТекИмя = СтрПолучитьСтроку(СтрокаПолей, Ё);
				КолонкаИсточник = ОписаниеТаблицы.Таблица.Колонки.Найти(ТекИмя);
				Если КолонкаИсточник <> Неопределено Тогда
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ТекИмя, КолонкаИсточник.ТипЗначения);
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Вставить(ТекИмя, ТекИмя);
				КонецЕсли; 
			КонецЦикла;
			ОписаниеТаблицы.ОсобыеПоля = "";
		Иначе
			Для каждого КолонкаИсточник Из ОписаниеТаблицы.Таблица.Колонки Цикл
				ТекИмя = КолонкаИсточник.Имя;
				Если (Найти(ОписаниеТаблицы.ОсобыеПоля, ТекИмя) = 0) Тогда
					ПроверитьНаличиеОписанияКолонки(КолонкиРезультата, ТекИмя, КолонкаИсточник.ТипЗначения);
					ОписаниеТаблицы.СтруктураКопируемыхКолонок.Вставить(ТекИмя, ТекИмя);
				КонецЕсли; 
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;
	#КонецОбласти 
	
	Для каждого ОписаниеКолонки Из КолонкиРезультата Цикл
		Результат.Колонки.Добавить(ОписаниеКолонки.Ключ, ОписаниеКолонки.Значение.ТипЗначения, ОписаниеКолонки.Значение.Заголовок, ОписаниеКолонки.Значение.Ширина)
	КонецЦикла; 
	
	Для каждого ОписаниеТаблицы Из МассивТаблиц Цикл
		ЗаполнитьСтрокиПоСтруктурам(Результат, ОписаниеТаблицы.Таблица, ОписаниеТаблицы.СтруктураКопируемыхКолонок,
				?(ОписаниеТаблицы.Свойство("СтруктураВычисляемыхКолонок"), ОписаниеТаблицы.СтруктураВычисляемыхКолонок, Новый Структура));
	КонецЦикла;
	
	Возврат Результат
КонецФункции // ОбъединитьТаблицы()
 
#КонецОбласти 

#Область ПРЕОБРАЗОВАНИЯ_В_ДРУГИЕ_ТИПЫ
	
// Записывает файл Excel с данными из таблицы значений
// Параметры:
//  ИмяФайла  - Строка - Имя записываемого файла
//  ТабЗначений  - Таблица значений - Данные для записи
// Возвращаемое значение:
//   Строка   - Описание ошибки. Пустое, если ошибки нет
Функция ExcelИзТаблицыЗначений(ИмяФайла_, ТабЗначений, ВыводитьЗаголовки = Истина) Экспорт
	Результат = "";
	ТабДокумент = Новый ТабличныйДокумент;
	Попытка
		Если ВыводитьЗаголовки Тогда
			СчКол = 1;
			Для каждого Колонка Из ТабЗначений.Колонки Цикл
				ТабДокумент.Область(1, СчКол, 1, СчКол).Текст = СокрЛП(Колонка.Имя);
				СчКол = СчКол + 1;
			КонецЦикла; 
		КонецЕсли;
		СчСтр = 1;
		Для каждого Строчка Из ТабЗначений Цикл
			СчКол = 1;
			СчСтр = СчСтр + 1;
			Для каждого Колонка Из ТабЗначений.Колонки Цикл
				ТабДокумент.Область(СчСтр, СчКол, СчСтр, СчКол).Текст = СокрЛП(Строчка[Колонка.Имя]);
				СчКол = СчКол + 1;
			КонецЦикла; 
		КонецЦикла;
		ТабДокумент.Записать(ИмяФайла_, ТипФайлаТабличногоДокумента.XLSX);
	Исключение
		Результат = ОписаниеОшибки();
	КонецПопытки;
	Возврат Результат
КонецФункции // ExcelИзТаблицыЗначений()

// Выгружает свёрнутую колонку таблицы значений
// Параметры:
//  ТЗначений  - Таблица значений - Откуда выгружать колонку
//  ИмяКолонки  - Строка - Имя выгружаемой колонки
//	УдалитьПустые - Булево - Удалить из результата пустые значения (по умолчанию Ложь)
// Возвращаемое значение:
//   Массив   - выгруженная свёрнутая колонка
Функция ВыгрузитьСвёрнутуюКолонку(ТЗначений, ИмяКолонки, УдалитьПустые = Ложь) Экспорт
	ВремТаб = ТЗначений.Скопировать(, ИмяКолонки);
	ВремТаб.Свернуть(ИмяКолонки);
	Если УдалитьПустые Тогда
		Результат = Новый Массив();
		Для каждого Строчка Из ВремТаб Цикл
			Если ЗначениеЗаполнено(Строчка[0]) Тогда
				Результат.Добавить(Строчка[0]);
			КонецЕсли; 
		КонецЦикла; 
	Иначе
		Результат = ВремТаб.ВыгрузитьКолонку(ИмяКолонки);
	КонецЕсли; 
	Возврат Результат
КонецФункции // ВыгрузитьСвёрнутуюКолонку()

// Формирует дерево значений из таблицы значений
// Параметры:
//  Таблица  - ТаблицаЗначений - Источник
//  ВетвьРодитель  - Строка дерева значений; любое другое значение будет преобразовано в дерево значений - Ветвь дерева, в которую будут добавляться строки
//  ИмяКолонкиИД  - Строка или Соответствие - Имя колонки с условными именами (ИД) строк. Если такой нет (указана пустая строка) - идентификатором служит номер строки таблицы. Может быть передано соответствие, где ключ - строка таблицы значений, а значение - её номер.
//  ИмяКолонкиРодителя  - Строка - Имя колонки, содержащей ИД родителей. По умолчанию "Родитель". Если колонки не обнаружено, все строки попадут в корень дерева.
//  ЗначениеРодителя  - Любое значение - ИД родителя, по которому будут искаться строки в таблице.
//	СтрокаЗапрещённыхПолей	- Строка	- Имена полей через запятую, которые не должны переноситься. Следует учитывать, что в дереве "Родитель" и "Строки" - реквизиты, и при наличии таких полей в источнике их надо запретить.
// Возвращаемое значение:
//   ВетвьРодитель   - Дерево значений или его строка (ветвь).
Функция ДеревоИзТаблицыЗначений(Таблица, ВетвьРодитель = Неопределено, ИмяКолонкиИД = "", ИмяКолонкиРодителя = "Родитель", ЗначениеРодителя = "", СтрокаЗапрещённыхПолей = "") Экспорт
	Если ВетвьРодитель = Неопределено Тогда
		//Инициализация дерева
		ВетвьРодитель = Новый ДеревоЗначений;
		СкоррелироватьКолонкиТаблиц(ВетвьРодитель, Таблица, 3,
				?(ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(СтрокаЗапрещённыхПолей, ИмяКолонкиРодителя) = 0, "", ИмяКолонкиРодителя) + "," +
				?(ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(СтрокаЗапрещённыхПолей, ИмяКолонкиИД) = 0, "", ИмяКолонкиИД));
	КонецЕсли; 
	Если ТипЗнч(ИмяКолонкиИД) = Тип("Соответствие") Тогда
		НетКолонкиИД = Истина;
		СоответствиеНомеровСтрок = ИмяКолонкиИД;
	Иначе
		НетКолонкиИД = ?(ИмяКолонкиИД = "", Истина, Таблица.Колонки.Найти(ИмяКолонкиИД) = Неопределено);
		Если НетКолонкиИД Тогда
			СоответствиеНомеровСтрок = Новый Соответствие;
			Ё = 1;
			Для каждого Строчка Из Таблица Цикл
				СоответствиеНомеровСтрок.Вставить(Строчка, Ё);
				Ё = Ё + 1;
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли;
	НетКолонкиРодителя = Таблица.Колонки.Найти(ИмяКолонкиРодителя) = Неопределено;
	//Обработка незаписываемых реквизитов дерева
	Если СтрокаЗапрещённыхПолей = "" Тогда
		Если Таблица.Колонки.Найти("Родитель") = Неопределено Тогда
			Если Таблица.Колонки.Найти("Строки") = Неопределено Тогда
				СтрокаЗапрещённыхПолей = "";
			Иначе
				СтрокаЗапрещённыхПолей = "Строки";
			КонецЕсли; 
		Иначе
			Если Таблица.Колонки.Найти("Строки") = Неопределено Тогда
				СтрокаЗапрещённыхПолей = "Родитель";
			Иначе
				СтрокаЗапрещённыхПолей = "Родитель,Строки";
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Источник = ?(НетКолонкиРодителя, Таблица, Таблица.НайтиСтроки(Новый Структура(ИмяКолонкиРодителя, ЗначениеРодителя)));
	Для каждого Строчка Из Источник Цикл
		НоваяСтрока = ВетвьРодитель.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка,, СтрокаЗапрещённыхПолей);//Колонки ИД и родителя отсутствуют в приёмнике
		Если НЕ НетКолонкиРодителя Тогда
			Если НетКолонкиИД Тогда
				ДеревоИзТаблицыЗначений(Таблица, НоваяСтрока, СоответствиеНомеровСтрок, ИмяКолонкиРодителя, СоответствиеНомеровСтрок[Строчка]);
			Иначе
				ДеревоИзТаблицыЗначений(Таблица, НоваяСтрока, ИмяКолонкиИД, ИмяКолонкиРодителя, Строчка[ИмяКолонкиИД]);
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Возврат ВетвьРодитель
КонецФункции // ДеревоИзТаблицыЗначений()
 
// Преобразует таблицу значений в фиксированный массив фиксированных структур.
// Для обычных массивов и структур следует использовать ОбщегоНазначения.
// Параметры:
//  ТЗначений  - Таблица значений - Преобразуемая таблица
//  ТипыКолонок  - Булево - В первом элементе возвращаемого массива структура типов колонок. По умолчанию Ложь (первый элемент - обычная строка).
// Возвращаемое значение:
//   ФиксированныйМассив   - Фиксированные структуры, соответствующие строкам
Функция МассивСтруктурИзТаблицы(ТЗначений, ТипыКолонок = Ложь) Экспорт
	Результат = Новый Массив;
	Заголовки = СписокКолонок(ТЗначений);
	Если ТипыКолонок Тогда
		Эмулятор = Новый Структура;
		Для каждого Колонка Из ТЗначений.Колонки Цикл
			Эмулятор.Вставить(Колонка.Имя, Колонка.ТипЗначения);
		КонецЦикла;
		Результат.Добавить(Новый ФиксированнаяСтруктура(Эмулятор));
	КонецЕсли;
	Для каждого Строчка Из ТЗначений Цикл
		Эмулятор = Новый Структура(Заголовки);
		ЗаполнитьЗначенияСвойств(Эмулятор, Строчка);
		Результат.Добавить(Новый ФиксированнаяСтруктура(Эмулятор));
	КонецЦикла;
	Возврат Новый ФиксированныйМассив(Результат)
КонецФункции // МассивСтруктурИзТаблицы

// Возвращает структуру, полученную из таблицы значений
// Параметры:
//  ТабЗНач - Таблица значений (табличная часть) или массив строк - источник данных
//  ИмяКолонкиКлючей - Строка - имя колонки,значения которой будут ключами (по умолчанию первая колонка).
//			Если указаны имена нескольких колонок через запятую, то ключом будет объединение строковых представлений колонок.
//  ИмяКолонкиЗначений - Строка - имя колонки,значения которой будут значениями (по умолчанию вторая (а если второй нет - первая) колонка).
//			м.б. "#ВсяСтрока" - значением будет вся строка.
//	ВернутьСоответствие - Булево - тип результата (Истина = Соответствие, Ложь(по умолчанию) = Структура). Автоопределений нет.
//	Колонки_ - колонки - колонки ТабЗнач. Если Неопределено (по умолчанию) - получаются из ТабЗнач.
// Возвращаемое значение:
//  Результат - Структура или соответствие - структура с ключами из колонки ключей и значениями из колонки значений
Функция СтруктураИзКолонокТаблицы(ТабЗНач, ИмяКолонкиКлючей = "", ИмяКолонкиЗначений = "", ВернутьСоответствие = Ложь, Колонки_ = Неопределено) Экспорт
	Если Колонки_ = Неопределено Тогда
		Колонки_ = ТабЗнач.Колонки;
	КонецЕсли; 
	Результат = ?(ВернутьСоответствие, Новый Соответствие, Новый Структура);
	Колонок = Колонки_.Количество();
	Если Колонок = 0 Тогда
		Возврат Результат
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ИмяКолонкиКлючей) Тогда
		ИмяКолонкиКлючей_ = Колонки_[0].Имя;
		КлючСтрока = НЕ ВернутьСоответствие;
	Иначе
		ИмяКолонкиКлючей_ = ИмяКолонкиКлючей;
		КлючСтрока = (СтрНайти(ИмяКолонкиКлючей, ",") > 0) ИЛИ НЕ ВернутьСоответствие;
	КонецЕсли;
	ИменаКолонокКлючей = СтрРазделить(ИмяКолонкиКлючей_, ",", Ложь);
	ИмяКолонкиЗначений_ = ?(Не ЗначениеЗаполнено(ИмяКолонкиЗначений),
			?(Колонок = 1, Колонки_[0].Имя, Колонки_[1].Имя), ИмяКолонкиЗначений);
	ЭтоВсяСтрока = ИмяКолонкиЗначений_ = "#ВсяСтрока";
	Для Каждого Строчка Из ТабЗНач Цикл
		Если КлючСтрока Тогда
			Ключ = "";
			Для каждого ТекКлюч Из ИменаКолонокКлючей Цикл
				Ключ = Ключ + Строчка[ТекКлюч];
			КонецЦикла;
		Иначе
			Ключ = Строчка[ИмяКолонкиКлючей_];
		КонецЕсли;
		Результат.Вставить(Ключ, ?(ЭтоВсяСтрока, Строчка, Строчка[ИмяКолонкиЗначений_]))
	КонецЦикла;
	Возврат Результат
КонецФункции

// Возвращает структуру, созданную по строке таблицы значений
// Параметры:
//  Источник - Таблица значений - Таблица, значения заданной строки которой будут перенесены в структуру
//  ИндексСтроки - Число - Индекс строки, преобразуемой в структуру. Если превышает пределы таблицы = будет возвращена пустая структура
//  Ключи - Строка - Список имён колонок, преобразуемых в ключи
// Возвращаемое значение:
//   Структура   - преобразованная строка таблицы
Функция СтруктураИзСтрокиТЗ(Источник, ИндексСтроки = 0, Ключи = "") Экспорт
	Результат = Новый Структура(Ключи);
	Если Источник.Количество() > ИндексСтроки Тогда
		Если Ключи = "" Тогда
			Для каждого Колонка Из Источник.Колонки Цикл
				Результат.Вставить(Колонка.Имя, Источник[ИндексСтроки][Колонка.Имя]);
			КонецЦикла;
		Иначе
			ЗаполнитьЗначенияСвойств(Результат, Источник[ИндексСтроки]);
		КонецЕсли; 
	КонецЕсли;
	Возврат Результат
КонецФункции // СтруктураИзСтрокиТЗ

#КонецОбласти

#Область ПОЛУЧЕНИЕ_ТЗ

// Создаёт пустую таблицу значений с объединением колонок входящих
// Параметры:
//  СписокТаблиц  - СписокЗначений, Структура, Соответстввие, ТаблицаЗначений с колонкой Значение, и т.д. - В Значении содержатся объединяемые таблицы или деревья значений
//  ВернутьДерево  - Булево - При Истина возвращается ДеревоЗначений, при Ложь (по умолчанию) - ТаблицаЗначений
// Возвращаемое значение:
//   ТаблицаЗнчений или деревоЗначений   - Пустой объект с объединением колонок
Функция ВыгрузитьКолонкиГрупповая(СписокТаблиц, ВернутьДерево = Ложь) Экспорт
	Результат = ?(ВернутьДерево, Новый ДеревоЗначений, Новый ТаблицаЗначений);
	ОписаниеКолонок = Новый Структура;
	Для каждого Табличка Из СписокТаблиц Цикл
		Для каждого Колонка Из Табличка.Значение.Колонки Цикл
			Если ОписаниеКолонок.Свойство(Колонка.Имя) Тогда
				ОписаниеКолонок.Вставить(Колонка.Имя, Новый Структура("ТипЗначения,Заголовок,Ширина",
						ВОЛНА_ОбщегоНазначения_КлиентСервер.ОбъединитьОписанияТипов(Колонка.ТипЗначения, ОписаниеКолонок[Колонка.Имя].ТипЗначения),
						Колонка.Заголовок,
						Макс(Колонка.Ширина, ОписаниеКолонок[Колонка.Имя].Ширина)));
			Иначе
				ОписаниеКолонок.Вставить(Колонка.Имя, Новый Структура("ТипЗначения,Заголовок,Ширина", Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина));
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
	Для каждого КиЗ Из ОписаниеКолонок Цикл
		Результат.Колонки.Добавить(КиЗ.Ключ, КиЗ.Значение.ТипЗначения, КиЗ.Значение.Заголовок, КиЗ.Значение.Ширина);
	КонецЦикла; 
	Возврат Результат
КонецФункции // ВыгрузитьКолонкиГрупповая

//ЗагрузитьТаблицуЗначенийИзТабличногоДокумента и из файла - в КлиентСервере, т.к. возможен массив структур

// Создаёт таблицу значений с заданными колонками. Может использоваться во внешнем соединении.
// Параметры:
//  СтруктураКолонок  - Структура или Неопределено - Ключ = имя колонки, Значение = Тип колонки (Тип или ОписаниеТипов, если иное - колонка произвольного типа).
// Возвращаемое значение:
//	Таблица значений - Пустая, с заданными колонками (имена и типы)
Функция СоздатьТаблицуЗначений(СтруктураКолонок = Неопределено) Экспорт
	Результат = Новый ТаблицаЗначений;
	ТипТип = Тип("Тип");
	ТипОТ = Тип("ОписаниеТипов");
	Если СтруктураКолонок <> Неопределено Тогда
		Для Каждого КиЗ Из СтруктураКолонок Цикл
			ТекТип = ТипЗнч(КиЗ.Значение);
			Если ТекТип = ТипОТ Тогда
				Результат.Колонки.Добавить(КиЗ.Ключ, КиЗ.Значение)
			ИначеЕсли ТекТип = ТипТип Тогда
				МассивТ = Новый Массив;
				МассивТ.Добавить(КиЗ.Значение);
				Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МассивТ))
			Иначе
				Результат.Колонки.Добавить(КиЗ.Ключ)
			КонецЕсли
		КонецЦикла
	КонецЕсли;
	Возврат Результат
КонецФункции // СоздатьТаблицуЗначений()

// Создаёт таблицу значений с заданными строками колонками и значениями. Может использоваться во внешнем соединении.
// Параметры:
//  ИменаКолонок  - Строка - Имена колонок с разделителем ","
//	ТекстыЗначений - Строка - тексты значений колонок с разделителем
//	Разделитель - Строка - разделитель значений
//	ПрефиксФормулы - Строка - значение, начинающееся с этой строки, считается формулой.
//	ПараметрыВычисления  - Структура - Параметры, используемые при вычислении.
//Возвращаемое значение:
//	ТаблицаЗначений - Рассчитанная таблица значений. Например,
//		СоздатьТаблицуЗначенийИзСтрок("Кол1,Кол2", "1,Истина,17,СМОЛА,,ЧЕЛОВЕК") = ТЗ:
//		Кол1	Кол2
//		"1"		"Истина"
//		"17"	"СМОЛА"
//		""		"ЧЕЛОВЕК"
Функция СоздатьТаблицуЗначенийИзСтрок(ИменаКолонок, ТекстыЗначений = "", Разделитель = ",", ПрефиксФормулы = "FRML", ПараметрыВычисления = Неопределено) Экспорт
	Результат = Новый ТаблицаЗначений;
	СтрокаКолонок = СтрЗаменить(ИменаКолонок, ",", Символы.ПС);
	ЧКол = СтрЧислоСтрок(СтрокаКолонок);
	Если ЧКол > 0 Тогда
		Для Ё = 1 По ЧКол Цикл
			Результат.Колонки.Добавить(СтрПолучитьСтроку(СтрокаКолонок, Ё))
		КонецЦикла;
		СимволХрюквы = "##ХРЮКВА__№";
		СтрокаЗначений = СтрЗаменить(СтрЗаменить(ТекстыЗначений, Символы.ПС, СимволХрюквы), Разделитель, Символы.ПС);
		ЧЗнч = СтрЧислоСтрок(СтрокаЗначений);
		ТекКол = Чкол;
		Для Ё = 1 По ЧЗнч Цикл
			Если ТекКол = ЧКол Тогда
				НоваяСтрока = Результат.Добавить();
				ТекКол = 0
			КонецЕсли;
			ТекЗнч = СтрЗаменить(СтрПолучитьСтроку(СтрокаЗначений, Ё), СимволХрюквы, Символы.ПС);
			Если Лев(ТекЗнч, СтрДлина(ПрефиксФормулы)) = ПрефиксФормулы Тогда
				ТекстКода =  Сред(ТекЗнч, СтрДлина(ПрефиксФормулы) + 1);
				НачТекст = "Результат =";
				Если Лев(ТекстКода, СтрДлина(НачТекст))<> НачТекст Тогда
					ТекстКода = НачТекст + ТекстКода;
				КонецЕсли;
				НоваяСтрока[ТекКол] = ВыполнитьКод(ТекстКода, ПараметрыВычисления, ТекстКода);
			Иначе
				НоваяСтрока[ТекКол] = ТекЗнч;
			КонецЕсли;
			ТекКол = ТекКол + 1
		КонецЦикла
	КонецЕсли;
	Возврат Результат
КонецФункции // СоздатьТаблицуЗначенийИзСтрок()

// Формирует Таблицу значений из Дерева значений
// Параметры:
//  Дерево  - ДеревоЗначений - Источник
//  Таблица  - ТаблицаЗначений - Приёмник. Можно не указывать, тогда вернёт созданную заново.
//  ИмяКолонкиИД  - Строка - Имя колонки с условными именами (ИД) строк. Если такой нет (указана пустая строка) - идентификатором служит номер строки таблицы, начиная с 1
//  ИмяКолонкиРодителя  - Строка - Имя колонки, куда будет помещён ИД родителей. По умолчанию "Родитель". Если колонки с таким именем нет, она не создаётся и все строки попадут на один уровень.
//	ЗначениеРодителя	- Число - Значение, указываемое в создаваемых подстроках текущей ветви как ИД родителя.
// Возвращаемое значение:
//   Таблица   - Таблица значений.
Функция ТаблицаЗначенийИзДерева(Дерево, Таблица = Неопределено, ИмяКолонкиИД = "", ИмяКолонкиРодителя = "Родитель", ЗначениеРодителя = 0) Экспорт
	Если Таблица = Неопределено Тогда
		Таблица = Новый ТаблицаЗначений;
		Если ТипЗнч(Дерево) = Тип("ДеревоЗначений") Тогда
			СкоррелироватьКолонкиТаблиц(Таблица, Дерево, 3);
		Иначе
			Таблица.Колонки.Добавить("Значение", ВОЛНА_ОбщегоНазначения_КлиентСервер.ВсеСсылочныеИПростыеТипы());
		КонецЕсли;
		Таблица.Колонки.Вставить(0, ИмяКолонкиРодителя);
		Если ИмяКолонкиИД <> "" Тогда
			Таблица.Колонки.Вставить(0, ИмяКолонкиИД);
		КонецЕсли; 
	КонецЕсли; 
	НетКолонкиРодителя = Таблица.Колонки.Найти(ИмяКолонкиРодителя) = Неопределено;
	НетКолонкиИД = ?(ИмяКолонкиИД = "", Истина, Таблица.Колонки.Найти(ИмяКолонкиИД) = Неопределено);
	Для каждого Строчка Из Дерево.Строки Цикл
		НоваяСтрока = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка);//Колонки ИД и родителя отсутствуют в приёмнике
		Если НЕ НетКолонкиРодителя Тогда
			НоваяСтрока.Родитель = ЗначениеРодителя;
		КонецЕсли;
		Попытка
			ТекИД = Строчка[ИмяКолонкиИД];
		Исключение
			ТекИД = Таблица.Количество();
			Если НЕ НетКолонкиИД Тогда
				НоваяСтрока[ИмяКолонкиИД] = ТекИД;
			КонецЕсли;
		КонецПопытки;
		ТаблицаЗначенийИзДерева(Строчка, Таблица, ИмяКолонкиИД, ИмяКолонкиРодителя, ТекИД);
	КонецЦикла;
	Возврат Таблица
КонецФункции // ТаблицаЗначенийИзДерева()

// Преобразует массив структур в таблицу значений. Не работает, если в первой строке есть значения "Тип" или "Описания типов" (как данные таблицы).
// Параметры:
//  ФМассив  - Массив, Фиксированный массив - Массив строк ТЗ или структур, соответствующих строкам новой таблицы
//  ВзятьДанныеНачинаяСИндекса  - Число - Индекс элемента массива, начиная с которого идут загружаемые данные. Например, если в первой структуре - типы колонок, то надо указать 1. По умолчанию 0.
//  Типизация  - Строка/Таблица значений - Вариант типизации колонок:
//		*ПоТипамСодержащимсяВПервой - по умолчанию, также любое иное значение - Типы берутся из значений первой структуры (первая строка должна содержать типы);
//		*ПоТипамЗначенийПервой - Типы определяются как типы значений первой (с индексом ВзятьДанныеНачинаяСИндекса) структуры;
//		*ПоВсем - Типы определяются по значениям ключа из всех структур, начиная с ВзятьДанныеНачинаяСИндекса;
//		*Нет - не типизируется;
//		*ТаблицаЗначений - переменная для помещения результата. Если содержит таблицу, записи будут добавлены в конец только в части уже имеющихся реквизитов
//  ДлинаСтрок  - Число - Длина строк для типизации ПоТипамЗначенийПервой:
//		*-2 - По фактическим значениям
//		*-1 - Не ограничивать (По умолчанию)
//		*Прочее - устанавливается заданное значение.
// Возвращаемое значение:
//   Таблица значений   - собранная из массива
Функция ТЗизМассиваСтруктур(ФМассив, ВзятьДанныеНачинаяСИндекса = 0, Типизация = "ПоЗначениямПервой", ДлинаСтрок = -1) Экспорт
	Колво = ФМассив.Количество();
	ТТЗ = ТипЗнч(Типизация) = Тип("ТаблицаЗначений");
	Если Колво = 0 Тогда
		Результат = ?(ТТЗ, Типизация, Новый ТаблицаЗначений);
	Иначе
		НачИндекс = ВзятьДанныеНачинаяСИндекса;
		ЕстьДанные = Колво > ВзятьДанныеНачинаяСИндекса;
		ТПоПервой = Типизация = "ПоТипамЗначенийПервой";
		ТПоВсем = Типизация = "ПоВсем";
		ТНет = Типизация = "Нет";
		Если ЕстьДанные И ТПоПервой Тогда
			Результат = ТЗизСтруктуры(ФМассив[НачИндекс], Истина, ДлинаСтрок);
			НачИндекс = НачИндекс + 1;
		ИначеЕсли ЕстьДанные И ТПоВсем Тогда
			СТипы = Новый Структура;
			Для каждого КиЗ Из ФМассив[НачИндекс] Цикл
				СТипы.Вставить(КиЗ.Ключ, ВОЛНА_ОбщегоНазначения_КлиентСервер.ПолучитьОписаниеТипаЗначения(КиЗ.Значение));
			КонецЦикла;
			Для СчСтр = НачИндекс + 1 По Колво - 1 Цикл
				Для каждого КиЗ Из ФМассив[СчСтр] Цикл
					СТипы.Вставить(КиЗ.Ключ, ВОЛНА_ОбщегоНазначения_КлиентСервер.ОбъединитьОписанияТипов(
							ВОЛНА_ОбщегоНазначения_КлиентСервер.ПолучитьОписаниеТипаЗначения(КиЗ.Значение), СТипы[КиЗ.Ключ]));
				КонецЦикла;
			КонецЦикла;
			МТипы = Новый Массив;
			МТипы.Добавить(СТипы);
			Результат = ТЗизМассиваСтруктур(МТипы, 1);
		ИначеЕсли ЕстьДанные И ТНет Тогда
			Результат = ТЗизСтруктуры(ФМассив[НачИндекс]);
			НачИндекс = НачИндекс + 1;
		ИначеЕсли ТТЗ Тогда
			Результат = Типизация;
		ИначеЕсли ТНет ИЛИ ТПоПервой ИЛИ ТПоВсем Тогда
			Результат = ТЗизСтруктуры(ФМассив[0]);
			Результат.Удалить(Результат[0]);
		Иначе
			ПерваяСтрока = ФМассив[0];
			Результат = СоздатьТаблицуЗначений(ПерваяСтрока);
		КонецЕсли;
		Для СчСтр = НачИндекс По Колво - 1 Цикл
			ЗаполнитьЗначенияСвойств(Результат.Добавить(), ФМассив[СчСтр]);
		КонецЦикла;
	КонецЕсли;
	Возврат Результат
КонецФункции // ТЗизМассиваСтруктур

// Формирует таблицу значений из списка значений ячеек
// Параметры:
//  СписокЯчеек  - ТаблицаЗначений - Колонки НомерСтроки, ИмяКолонки, ЗначениеЯчейки.
//		Или, если такие имена не заданы - берутся три первые колонки в указанном порядке. Если нет только колонки НомерСтроки, то все данные грузятся в одну строку.
//  МэппингИмёнКолонок  - Соответствие/Структура/Неопределено - соответствие имён колонок значениям из колонки ИмяКолонки. Если задано, в результате будут только колонки из значений соответствия.
// Возвращаемое значение:
//   Таблица значений   - Содержит все колонки, перечисленные в ИмяКолонки, и столько строк, сколько разных значений в колонке НомерСтроки.
//		Если в колонке НомерСтроки найдены нечисловые значения, то в результате будет и колонка НомерСтроки, по значениям которой будут отсортированы строки.
//		Отсутствующие в исходной таблице значения в результате будут представлены как Неопределено
Функция ТЗизСпискаЯчеек(СписокЯчеек, МэппингИмёнКолонок = Неопределено) Экспорт
	
	#Область КОЛОНКИ_ИСТОЧНИКА
	    //Результат области: имена колонок источника в КолонкаНС, КолонкаИК, КолонкаЗЯ, если колонки НС нет, то ПервойНет = Истина
		КолонкиСписка = СписокЯчеек.Колонки;
		ПервыеТри = Ложь;
		ПервойНет = Ложь;
		КолонкаИК = КолонкиСписка.Найти("ИмяКолонки");
		КолонкаЗЯ = КолонкиСписка.Найти("ЗначениеЯчейки");
		НетКИК = КолонкиСписка.Найти("ИмяКолонки") = Неопределено;
		НетКЗЯ = КолонкиСписка.Найти("ЗначениеЯчейки") = Неопределено;
		Если НетКИК Тогда
			ИндексИК = -1;
			ПервыеТри = Истина;
		Иначе
			ИндексИК = КолонкиСписка.Индекс(КолонкаИК);
			КолонкаИК = "ИмяКолонки";
		КонецЕсли;
		Если НетКЗЯ Тогда
			ИндексЗЯ = -1;
			ПервыеТри = Истина;
		Иначе
			ИндексЗЯ = КолонкиСписка.Индекс(КолонкаЗЯ);
			КолонкаЗЯ = "ЗначениеЯчейки";
		КонецЕсли;
		Если ПервыеТри Тогда
			ИндексНС = ?(ИндексИК = 0 ИЛИ ИндексЗЯ = 0, ?(ИндексИК = 1 ИЛИ ИндексЗЯ = 1, 2, 1), 0);
			КолонкаНС = КолонкиСписка[ИндексНС].Имя;
			Если ИндексИК = -1 Тогда
				ИндексИК = ?(КолонкаНС = 0 ИЛИ ИндексЗЯ = 0, ?(КолонкаНС = 1 ИЛИ ИндексЗЯ = 1, 2, 1), 0);
				КолонкаИК = КолонкиСписка[ИндексИК].Имя;
			КонецЕсли;
			Если ИндексЗЯ = -1 Тогда
				КолонкаЗЯ = КолонкиСписка[?(КолонкаНС = 0 ИЛИ ИндексИК = 0, ?(КолонкаНС = 1 ИЛИ ИндексИК = 1, 2, 1), 0)].Имя;
			КонецЕсли;
		Иначе
			Если КолонкиСписка.Найти("НомерСтроки") = Неопределено Тогда
				ПервойНет = Истина;
			Иначе
				КолонкаНС = "НомерСтроки";
			КонецЕсли;
		КонецЕсли;
	#КонецОбласти 
	
	Результат = Новый ТаблицаЗначений;
	#Область СТРОКИ_И_КОЛОНКИ
		Если ПервойНет Тогда
			ЕдинственнаяСтрока = Результат.Добавить();
		Иначе
			ИменаСтрок = СписокЯчеек.Скопировать(, КолонкаНС);
			ИменаСтрок.Свернуть(КолонкаНС);
			СтрокиРезультата = Новый Соответствие;
			Результат.Колонки.Добавить(КолонкаНС);
			Для каждого ИмяСтроки Из ИменаСтрок Цикл
				СтрокиРезультата.Вставить(ИмяСтроки[КолонкаНС], Результат.Добавить());
				СтрокиРезультата[ИмяСтроки[КолонкаНС]].НомерСтроки = ИмяСтроки[КолонкаНС];
			КонецЦикла;
		КонецЕсли;
		 
		ИменаКолонок = СписокЯчеек.Скопировать(, КолонкаИК);
		ИменаКолонок.Свернуть(КолонкаИК);
		Если МэппингИмёнКолонок = Неопределено Тогда
			КолонкиРезультата = Новый Соответствие;
			Для каждого ИмяКолонки Из ИменаКолонок Цикл
				НоваяКолонка = Результат.Колонки.Добавить(ИмяКолонки[КолонкаИК]);
				КолонкиРезультата.Вставить(ИмяКолонки[КолонкаИК], ИмяКолонки[КолонкаИК]);
			КонецЦикла;
		Иначе
			КолонкиРезультата = МэппингИмёнКолонок;
			Для каждого КиЗ Из КолонкиРезультата Цикл
			 	Результат.Колонки.Добавить(КиЗ.Значение);
			КонецЦикла;
		КонецЕсли;
	#КонецОбласти
	
	#Область ЗНАЧЕНИЯ_ЯЧЕЕК
		Для каждого СтрЗЯ Из СписокЯчеек Цикл
			ТекИК = КолонкиРезультата[СтрЗЯ[КолонкаИК]];
			Если ТекИК <> Неопределено Тогда
				Если ПервойНет Тогда
					ТекСтр = ЕдинственнаяСтрока;
				Иначе
					ТекСтр = СтрокиРезультата[СтрЗЯ[КолонкаНС]];
				КонецЕсли;
				ТекСтр[КолонкиРезультата[СтрЗЯ[КолонкаИК]]] = СтрЗЯ[КолонкаЗЯ];
			КонецЕсли; 
		КонецЦикла;
	#КонецОбласти 
	Если НЕ ПервойНет Тогда
		Результат.Сортировать(КолонкаНС);
		Результат.Колонки.Удалить(КолонкаНС);
	КонецЕсли; 
	
	Возврат Результат
КонецФункции // ТЗизСпискаЯчеек

// Создаёт однострочную таблицу значений из структуры
// Параметры:
//  Источник  - Структура/Соответствие - Источник данных, ключи - имена колонок
//  Типизировать  - Булево - Истина - колонки типизируются (по умолчанию Ложь)
//  ДлинаСтрок  - Число - Ограничение длин строк (12 = Пофакту; -1 = Не ограничивать(По умолчанию))
// Возвращаемое значение:
//   Таблица значений   - Первая строка содержит значения из структуры
Функция ТЗизСтруктуры(Источник, Типизировать = Ложь, ДлинаСтрок = -1) Экспорт
	Результат = Новый ТаблицаЗначений;
	ТипСтрока = Тип("Строка");
	Если Типизировать Тогда
		Для каждого КиЗ Из Источник Цикл
			МТипы = Новый Массив;
			ТекТип = ТипЗнч(КиЗ.Значение);
			МТипы.Добавить(ТекТип);
			Если ТекТип = ТипСтрока И ДлинаСтрок <> -1 Тогда
				Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МТипы,, Новый КвалификаторыСтроки(?(ДлинаСтрок = -2, СтрДлина(КиЗ.Значение), ДлинаСтрок))));
			Иначе
				Результат.Колонки.Добавить(КиЗ.Ключ, Новый ОписаниеТипов(МТипы));
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для каждого КиЗ Из Источник Цикл
			Результат.Колонки.Добавить(КиЗ.Ключ);
		КонецЦикла;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(Результат.Добавить(), Источник);
	Возврат Результат
КонецФункции // ТЗизСтруктуры

#КонецОбласти

#Область ПРЕОБРАЗОВАНИЕ_ДАННЫХ_ОДНОЙ_ТЗ
	
// В таблице значений заменяет пустые значения на значения по умолчанию из структуры
// Параметры:
//  ТабЗначений  - ТаблицаЗначений - Произвольная
//  ЗначенияПоУмолчанию  - Структура - Ключи совпадают с именами колонок, где будет замена. Значения - новые значения.
//	ПрефиксФормулы - значение, начинающееся с этой строки, считается формулой. Обращение к данным строки - Строчка.
Процедура ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию(ТабЗначений, ЗначенияПоУмолчанию, ПрефиксФормулы = "FRML") Экспорт
	ДлинаПрефикса = СтрДлина(ПрефиксФормулы);
	Для каждого Строчка Из ТабЗначений Цикл
		Для каждого КиЗ Из ЗначенияПоУмолчанию Цикл
			Если НЕ ЗначениеЗаполнено(Строчка[КиЗ.Ключ]) Тогда
				Строчка[КиЗ.Ключ] = ?(Лев(КиЗ.Значение, ДлинаПрефикса) = ПрефиксФормулы, Вычислить(Сред(КиЗ.Значение, ДлинаПрефикса + 1)), КиЗ.Значение);
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
КонецПроцедуры // ЗаменитьПустыеЗначенияЗначениямиПоУмолчанию()

//Изменяет тип колонки таблицы значений и заполняет её заданным значением
//Параметры:
//	 ТабЗнач	- Таблица значений - В которой будет заполнена колонка
//	 Значение	- Произвольное - Которым будет заполнена колонка
//	 ИмяКолонки	- Строка - имя заполняемой колонки
//Возвращаемое значение:
//	Таблица значений - с заплненной заданным значением колонкой заданного имени. Колонка типизирована. Это же значение вернётся в первом параметре
Функция ЗаполнитьЗначениеВКолонку(ТабЗнач, Значение, ИмяКолонки) Экспорт
	Если ТабЗнач.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
		ТабЗнач.Колонки.Удалить(ИмяКолонки)
	КонецЕсли;
	ТабЗнач.Колонки.Добавить(ИмяКолонки, ВОЛНА_ОбщегоНазначения_КлиентСервер.ПолучитьОписаниеТипаЗначения(Значение));
	ТабЗнач.ЗаполнитьЗначения(Значение, ИмяКолонки);
	Возврат ТабЗнач
КонецФункции

//Возвращает свёрнутую таблицу значений (удобно использовать, когда нужна именно функция, а также при автоопределении измерений и ресурсов)
//Параметры:
//	 Табличка	- Таблица значений - Которая будет свёрнута
//	 Измерения	- Строка - Имена колонок измерений через запятую. По умолчанию Неопределено, в этом случае будут автоопределены колонки, не имеющие в составе типов Число
//			(или (Если НеопределённыйТип = "Проверить") с неопределённым типом и имеющими хотя бы одно значение, не являющееся числом).
//	 Ресурсы	- Строка - Имена колонок ресурсов через запятую. По умолчанию Неопределено, в этом случае будут автоопределены колонки, имеющие в составе типов Число
//			(или (Если НеопределённыйТип = "Проверить") с неопределённым типом и значениями типа только Число).
//	 НеопределённыйТип	- Строка - Имеет смысл только для автоопределения ресурсов и измерений.
//			*"Измерение" - Колонки с неопределённым типом считаются измерениями (по умолчанию)
//			*"Исключить" - Колонки с неопределённым типом не входят ни в измерения, ни в ресурсы
//			*"Проверить" - Колонки с неопределённым типом автоопределяются
//	 Исключаемые	- Строка - Список колонок, исключаемых из измерений и ресурсов.
//Возвращаемое значение:
//	Таблица значений (Табличка) - с заполненной заданным значением колонкой заданного имени. Колонка типизирована. Это же значение вернётся в первом параметре
Функция СвернутьТаблицуЗначений(Табличка, Измерения = Неопределено, Ресурсы = Неопределено, НеопределённыйТип = "Измерение", Исключаемые = "") Экспорт
	АвтоИзмерения = Измерения = Неопределено;
	АвтоРесурсы = Ресурсы = Неопределено;
	мИсключаемые = СтрРазделить(Исключаемые, ",");
	Если АвтоИзмерения Тогда
		ТекИзмерения = ",";
	Иначе
		ТекИзмерения = "," + Измерения + ",";
		Для каждого Исключение_ Из мИсключаемые Цикл
			ТекИзмерения = СтрЗаменить(ТекИзмерения, "," + Исключение_ + ",", ",");
		КонецЦикла;
	КонецЕсли; 
	Если АвтоРесурсы Тогда
		ТекРесурсы = ",";
	Иначе
		ТекРесурсы = "," + Ресурсы + ",";
		Для каждого Исключение_ Из мИсключаемые Цикл
			ТекРесурсы = СтрЗаменить(ТекРесурсы, "," + Исключение_ + ",", ",");
		КонецЦикла;
	КонецЕсли; 
	Если АвтоИзмерения ИЛИ АвтоРесурсы Тогда
		Для каждого Колонка Из Табличка.Колонки Цикл
			ТипЧисло = Тип("Число");
			ТекИмя = Колонка.Имя;
			Это_Изм_Рес = "";
			Если (мИсключаемые.Найти(ТекИмя) = Неопределено)
					И ?(АвтоИзмерения, ИСТИНА, Найти(ТекИзмерения, "," + ТекИмя + ",") = 0)
					И ?(АвтоРесурсы, ИСТИНА, Найти(ТекРесурсы, "," + ТекИмя + ",") = 0)
					Тогда
				ТекТип = Колонка.ТипЗначения;
				Если ТекТип.Типы().Количество() = 0 Тогда
					Если НеопределённыйТип = "Проверить" Тогда
						Это_Изм_Рес = "Р";
						Для каждого Строчка Из Табличка Цикл
							Если ТипЗнч(Строчка[ТекИмя]) <> ТипЧисло Тогда
								Это_Изм_Рес = "И";
								Прервать;
							КонецЕсли; 
						КонецЦикла;
					ИначеЕсли НеопределённыйТип = "Измерение" Тогда
						Это_Изм_Рес = "И";
					КонецЕсли;
				ИначеЕсли ТекТип.СодержитТип(ТипЧисло) Тогда
					Это_Изм_Рес = "Р";
				Иначе
					Это_Изм_Рес = "И";
				КонецЕсли; 
			КонецЕсли;
			Если Это_Изм_Рес = "Р" Тогда
				Если АвтоРесурсы Тогда
					ТекРесурсы = ТекРесурсы + ТекИмя + ",";
				КонецЕсли;
			ИначеЕсли Это_Изм_Рес = "И" Тогда
				Если АвтоИзмерения Тогда
					ТекИзмерения = ТекИзмерения + ТекИмя + ",";
				КонецЕсли;
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли;
	ТекИзмерения = Сред(ТекИзмерения, 2, СтрДлина(ТекИзмерения) - 2);
	ТекРесурсы = Сред(ТекРесурсы, 2, СтрДлина(ТекРесурсы) - 2);
	Табличка.Свернуть(ТекИзмерения, ТекРесурсы);
	Возврат Табличка
КонецФункции // ()

// Свёртывает таблицу значений с расширенными возможностями агрегатных функций. Колонки ресурса должны допускать тип результата агрегирования.
// В реквизитах остаётся одно из значений, в неопознанных ресурсах - Неопределено.
// Параметры:
//  ТабЗн  - ТаблицаЗначений - Сворачиваемая таблица
//  КолонкиИзмерений  - Строка - Колонки измерений через запятую
//  КолонкиРесурсов  - Структура - Ключи = Имена колонк, значения = агрегатные функции:
//			*ЗНАЧЕНИЯ - Упаковка в значения списка значений
//			*МАКСИМУМ - Максимум
//			*МАССИВ - Упаковка значений в массив
//			*МИНИМУМ - Минимум
//			*ПРОИЗВ - Произведение
//			*Результат =  - Выполнение произввольного кода с переменными:
//				*ВсеИтоги (структура с текущими значениями итогов и ключами - именами ресурсов),
//				*Результат - текущий итог текущего ресурса. Стартовый итог = Неопределено.
//				*ТекЗначение - Текущее значение текущего ресурса строки таблицы,
//				*СтрокаТЗ - текущая строка таблицы значений.
//			*СООТВЕТСТВИЕ - Упаковка в ключи соответствия
//			*СТРУКТУРА - Упаковка в ключи структуры
//			*Структура - ключи Число,Ограничение,Разделитель,КонецОбрезанный - конкатенация указанного числа символов строк
//				(отрицательное - правых, ноль - полностью), общая длина на больше Ограничение, обрезанная итоговая строка заканчивается на указанный конец
//			*СУМКВ - Сумма квадратов
//			*СУММ - Сумма
// Возвращаемое значение:
//   Таблица значений   - Параметр1 свёрнутый
Функция СвернутьТабЗначенийРасширенно(ТабЗн, КолонкиИзмерений, КолонкиРесурсов) Экспорт
	Результат = ТабЗн;
	Итоги = Новый Структура;
	Колво = Результат.Количество();
	КУдалению = Новый Массив;
	КУдалению.Добавить(Результат.Добавить());//Техническая строка
	мИзмерения = СтрРазделить(КолонкиИзмерений, ",", Ложь);
	ТипСтруктура = Тип("Структура");
	ТипЧисло = Тип("Число");
	ЭтоДубль = Ложь;
	Результат.Сортировать(КолонкиИзмерений);
	Для каждого КиЗ Из КолонкиРесурсов Цикл
		Итоги.Вставить(КиЗ.Ключ, Неопределено);
	КонецЦикла;
	ТекСтрока = 0;
	Для Сч = 0 По Колво Цикл
		ПрошлаяСтрока = ТекСтрока;
		ТекСтрока = Результат[Сч];
		//ЗАПИСЬ АГРЕГАТОВ
		Если ЭтоДубль Тогда
			Если Сч = Колво Тогда
				ЭтоДубль = Ложь;
			Иначе
				Для каждого Измерение Из мИзмерения Цикл
					Если ТекСтрока[Измерение] <> ПрошлаяСтрока[Измерение] Тогда
						ЭтоДубль = Ложь;
						Прервать;
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли; 
			Если ЭтоДубль Тогда
				КУдалению.Добавить(ПрошлаяСтрока);
			Иначе
				Для каждого КиЗ Из Итоги Цикл
					ПрошлаяСтрока[КиЗ.Ключ] = КиЗ. Значение;
					Итоги[КиЗ.Ключ] = Неопределено;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли;
		//АГРЕГИРОВАНИЕ
		Для каждого КиЗРесурс Из КолонкиРесурсов Цикл
			Если КиЗРесурс.Значение = "ЗНАЧЕНИЯ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = Новый СписокЗначений;
				КонецЕсли;
				Итоги[КиЗ.Ключ].Добавить().Значение = ТекСтрока[КиЗ.Ключ];
			ИначеЕсли ТипЗнч(КиЗРесурс.Значение) = ТипСтруктура Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = "";
				КонецЕсли;
				Если КиЗРесурс.Значение.Число = 0 Тогда
					Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + КиЗРесурс.Значение.Разделитель + ТекСтрока[КиЗ.Ключ];
				ИначеЕсли КиЗРесурс.Значение.Число < 0 Тогда
					Итоги[КиЗ.Ключ] = Прав(ТекСтрока[КиЗ.Ключ], КиЗРесурс.Значение.Число) + КиЗРесурс.Значение.Разделитель + Итоги[КиЗ.Ключ];
				Иначе
					Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + КиЗРесурс.Значение.Разделитель + Лев(ТекСтрока[КиЗ.Ключ], КиЗРесурс.Значение.Число);
				КонецЕсли;
				Если СтрДлина(Итоги[КиЗ.Ключ]) > КиЗРесурс.Значение.Ограничение Тогда
					Итоги[КиЗ.Ключ] = Лев(Итоги[КиЗ.Ключ], КиЗРесурс.Значение.Ограничение - СтрДлина(КиЗРесурс.Значение.КонецОбрезанный)) + КиЗРесурс.Значение.КонецОбрезанный;
				КонецЕсли;
			ИначеЕсли КиЗРесурс.Значение = "МАССИВ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = Новый Массив;
				КонецЕсли;
				Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ]);
			ИначеЕсли КиЗРесурс.Значение = "МАКСИМУМ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = NULL;
				КонецЕсли;
				#Область ТЕКСТ_ЗАПРОСА
					Запрос = Новый Запрос(
							"ВЫБРАТЬ
							|	&Итог КАК Поле
							|
							|ОБЪЕДИНИТЬ ВСЕ
							|
							|ВЫБРАТЬ
							|	&ТекЗначение
							|
							|УПОРЯДОЧИТЬ ПО
							|	Поле УБЫВ");
				#КонецОбласти 
				Запрос.УстановитьПараметр("Итог", Итоги[КиЗ.Ключ]);
				Запрос.УстановитьПараметр("ТекЗначение", ТекСтрока[КиЗ.Ключ]);
				Выборка = Запрос.Выполнить().Выбрать();
				Выборка.Следующий();
				Итоги[КиЗ.Ключ] = Выборка.Поле;
			ИначеЕсли КиЗРесурс.Значение = "МИНИМУМ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = ТекСтрока[КиЗ.Ключ];
				КонецЕсли;
				#Область ТЕКСТ_ЗАПРОСА
					Запрос = Новый Запрос(
							"ВЫБРАТЬ
							|	&Итог КАК Поле
							|
							|ОБЪЕДИНИТЬ ВСЕ
							|
							|ВЫБРАТЬ
							|	&ТекЗначение
							|
							|УПОРЯДОЧИТЬ ПО
							|	Поле");
				#КонецОбласти 
				Запрос.УстановитьПараметр("Итог", Итоги[КиЗ.Ключ]);
				Запрос.УстановитьПараметр("ТекЗначение", ТекСтрока[КиЗ.Ключ]);
				Выборка = Запрос.Выполнить().Выбрать();
				Выборка.Следующий();
				Итоги[КиЗ.Ключ] = Выборка.Поле;
			ИначеЕсли КиЗРесурс.Значение = "ПРОИЗВ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = 1;
				КонецЕсли;
				Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] * ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ], 1);
			ИначеЕсли КиЗРесурс.Значение = "СУММ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = 1;
				КонецЕсли;
				Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ], 0);
			ИначеЕсли КиЗРесурс.Значение = "СУМКВ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = 1;
				КонецЕсли;
				Итоги[КиЗ.Ключ] = Итоги[КиЗ.Ключ] + ?(ТипЗнч(ТекСтрока[КиЗ.Ключ]) = ТипЧисло, ТекСтрока[КиЗ.Ключ] * ТекСтрока[КиЗ.Ключ], 0);
			ИначеЕсли КиЗРесурс.Значение = "СООТВЕТСТВИЕ" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = Новый Соответствие;
				КонецЕсли;
				Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ], Неопределено);
			ИначеЕсли КиЗРесурс.Значение = "СТРУКТУРА" Тогда
				Если Итоги[КиЗ.Ключ] = Неопределено Тогда
					Итоги[КиЗ.Ключ] = Новый Структура;
				КонецЕсли;
				Итоги[КиЗ.Ключ].Добавить(ТекСтрока[КиЗ.Ключ], Неопределено);
			ИначеЕсли Лев(КиЗРесурс.Значение, 12) = "Результат = " Тогда
				Итоги[КиЗ.Ключ] = ВыполнитьКод(КиЗРесурс.Значение, Новый Структура("ВсеИтоги,ТекЗначение,СтрокаТЗ", Итоги, ТекСтрока[КиЗ.Ключ], ТекСтрока), Итоги[КиЗ.Ключ]);
			КонецЕсли;
		КонецЦикла;
		ЭтоДубль = Истина;
	КонецЦикла;
	ВОЛНА_ОбщегоНазначения_КлиентСервер.УдалитьЛишниеСтроки(Результат, КУдалению);
	Возврат Результат
КонецФункции // СвернутьТабЗначенийРасширенно

//Возвращает свёрнутую с использованием запросных аггрегатных функций таблицу значений.
//Параметры:
//	ТабЗначений - Таблица значений - сворачиваемая таблица, типизированная под запрос
//	КолонкиИзмерений - Строка - Список имён колонок измерений с разделителем строго "," или ", "
//	КолонкиРесурсов - Строка - Список имён колонок всех ресурсов с разделителем строго "," или ", "
//	КолонкиМаксимум - Строка - Список имён колонок ресурсов, аггрегируемых максимумом,
//			с разделителем ",". По умолчанию "".
//	КолонкиМинимум - Строка - Список имён колонок ресурсов, аггрегируемых минимумом,
//			с разделителем ",". По умолчанию "".
//	КолонкиКоличество - Строка - Список имён колонок ресурсов, аггрегируемых количеством,
//			с разделителем ",". По умолчанию "".
//	КолонкиКР - Строка - Список имён колонок ресурсов, аггрегируемых количеством различных,
//			с разделителем ",". По умолчанию "".
//	КолонкиСреднее - Строка - Список имён колонок ресурсов, аггрегируемых средним,
//			с разделителем ",". По умолчанию "". Остальные ресурсы будут аггрегированы суммой.
//Возвращаемое значение
//	Таблица значений - свёрнутая.
Функция СвернутьТЗЗапросом(ТабЗначений, КолонкиИзмерений, КолонкиРесурсов, КолонкиМаксимум = "", КолонкиМинимум = "", КолонкиКоличество = "", КолонкиКР = "", КолонкиСреднее = "") Экспорт
	СтрокаИзмерений = ?(КолонкиИзмерений = "", """ИТОГ""",
			"Источник." + СтрЗаменить(СтрЗаменить(КолонкиИзмерений,
			", ", "," + Символы.ПС + "Источник."), ",", "," + Символы.ПС + "Источник."));
	СтрокаРесурсов = ?(КолонкиРесурсов = "", "0",
			"Источник." + СтрЗаменить(СтрЗаменить(КолонкиРесурсов,
			", ", "," + Символы.ПС + "Источник."), ",", "," + Символы.ПС + "Источник."));
	СтрокаАггрегированныхРесурсов = "";
	ТМП = СтрЗаменить(КолонкиРесурсов, ",", Символы.ПС);
	Для Ё = 1 По СтрЧислоСтрок(ТМП) Цикл
		ТекИмя = СтрПолучитьСтроку(ТМП, Ё);
		Аггрегат =?(ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(КолонкиМаксимум, ТекИмя) > 0, "МАКСИМУМ(",
				?(ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(КолонкиМинимум, ТекИмя) > 0, "МИНИМУМ(", ?(ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(КолонкиКР, ТекИмя) > 0, "КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ",
				?(ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(КолонкиКоличество, ТекИмя) > 0, "КОЛИЧЕСТВО(", ?(ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(КолонкиСреднее, ТекИмя) > 0, "СРЕДНЕЕ(", "СУММА(")))));
		СтрокаАггрегированныхРесурсов = СтрокаАггрегированныхРесурсов + "," + Символы.ПС + Аггрегат + "Источник." + ТекИмя + ") КАК " + ТекИмя;
	КонецЦикла; 
	Запрос = Новый Запрос(СтрЗаменить(СтрЗаменить(СтрЗаменить(
			"ВЫБРАТЬ
			|	Источник.Измерение1,
			|	Источник.Измерение2,
			|	Источник.Ресурс1 КАК Ресурс1,
			|	Источник.Ресурс2 КАК Ресурс2
			|ПОМЕСТИТЬ ВТ__Источник
			|ИЗ
			|	&Источник КАК Источник
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	Источник.Измерение1,
			|	Источник.Измерение2,
			|	СУММА(Источник.Ресурс1) КАК Ресурс1,
			|	СУММА(Источник.Ресурс2) КАК Ресурс2
			|ИЗ
			|	ВТ__Источник КАК Источник
			|
			|СГРУППИРОВАТЬ ПО
			|	Источник.Измерение1,
			|	Источник.Измерение2
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|УНИЧТОЖИТЬ ВТ__Источник", "Источник.Измерение1,
			|	Источник.Измерение2", СтрокаИзмерений), "СУММА(Источник.Ресурс1) КАК Ресурс1,
			|	СУММА(Источник.Ресурс2) КАК Ресурс2", Сред(СтрокаАггрегированныхРесурсов, 3)),
			"Источник.Ресурс1 КАК Ресурс1,
			|	Источник.Ресурс2 КАК Ресурс2", СтрокаРесурсов));
	Запрос.УстановитьПараметр("Источник", ТабЗначений);
	Возврат Запрос.Выполнить().Выгрузить();
КонецФункции // СвернутьТЗЗапросом

//Устанавливает на заданную колонку тип по всем её значениям
//(допустимый тип колонки становится суммарным типом значений колонки)
//Параметры:
//	ТабЗн - Таблица значений, содержащая колонку
//	ИмяКолонки - Имя типизируемой колонки
//	ИмяКолонкиТипов - Имя колонки, по значениям которой определяются типы. По умолчанию "", в этом случае тип определяется по колонке данных
Процедура ТипизироватьКолонку(ТабЗн, Знач ИмяКолонки, ИмяКолонкиТипов = "") Экспорт
	Если ТабЗн.Количество() > 0 Тогда
		Если ИмяКолонкиТипов = "" Тогда
			ИмяКолонкиТипов = ИмяКолонки;
		КонецЕсли;
		ЭтиКолонки = ТабЗн.Колонки;
		МВыгрузка = ТабЗн.ВыгрузитьКолонку(ИмяКолонкиТипов);
		НоваяКолонка = ЭтиКолонки.Добавить("Временное__Имя__Этой__Колонки",
				ВОЛНА_ОбщегоНазначения_КлиентСервер.ОписаниеТиповКоллекции(МВыгрузка),
				ЭтиКолонки[ИмяКолонки].Заголовок, ЭтиКолонки[ИмяКолонки].Ширина);
		Если ИмяКолонкиТипов <> ИмяКолонки Тогда
			МВыгрузка = ТабЗн.ВыгрузитьКолонку(ИмяКолонки);
		КонецЕсли;
		ТабЗн.ЗагрузитьКолонку(МВыгрузка, "Временное__Имя__Этой__Колонки");
		ЭтиКолонки.Удалить(ИмяКолонки);
		ЭтиКолонки.Временное__Имя__Этой__Колонки.Имя = ИмяКолонки
	КонецЕсли
КонецПроцедуры

//Типизирует колонки таблицы значений по содержимому (допустимый тип колонки становится суммарным типом значений колонки)
//Параметры:
//	ТабЗначений - Таблица значений - типизируемая таблица
Процедура ТипизироватьТаблицу(ТабЗначений_) Экспорт
	МассивКолонок = Новый Массив;
	Для Каждого Колонка Из ТабЗначений_.Колонки Цикл
		МассивКолонок.Добавить(Колонка.Имя);
	КонецЦикла;
	Для Каждого Колонка Из МассивКолонок Цикл
		ТипизироватьКолонку(ТабЗначений_, Колонка)
	КонецЦикла;
КонецПроцедуры

//Приводит сумму колонки таблицы к нужному значению
//Параметры:
//	Таблица - таблица значений, строки дерева значений - коллекция, по колонке которой надо перераспределит сумму
//	Реквизит - Строка - Имя колонки, по которой распределяется сумма
//	Сумма - Число - распределяемая сумма
//	Точность - Число - количество знаков после запятой в рассчитанных суммах
Процедура ПривестиТабКСумме(Таблица, Реквизит, Сумма, Знач Точность = 2) Экспорт
	Если Сумма = 0 Тогда
		Таблица.ЗаполнитьЗначения(Сумма, Реквизит);
	ИначеЕсли Таблица.Итог(Реквизит) <> 0 Тогда
		Таблица.ЗагрузитьКолонку(ВОЛНА_ОбщегоНазначения_КлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(Сумма, Таблица.ВыгрузитьКолонку(Реквизит), Точность));
	КонецЕсли;
КонецПроцедуры

// Возвращает таблицу значений с пронумерованными строками. Может использоваться как процедура.
// Параметры:
//  Таблица  - Таблица значений - подлежит нумерации
//  ИмяКолонки  - Строка - Имя колонки с номером
//  ПервыйНомер  - Число - номер первой строки
// Возвращаемое значение:
//   Таблица значений   - Та же, что и передана, но с колонкой номера строки.
Функция ПронумероватьТаблицуЗначений(Таблица, ИмяКолонки = "НомерСтроки", ПервыйНомер = 1) Экспорт
	Результат = Таблица;
	Результат.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Число"));
	Ё = ПервыйНомер;
	Для каждого СтрокаТ Из Результат Цикл
		СтрокаТ[ИмяКолонки] = Ё;
		Ё = Ё + 1;
	КонецЦикла; 
	Возврат Результат
КонецФункции // ПронумероватьТаблицуЗначений

// Объединяет "смежные" интервалы дат из таблицы значений. Считается, что в таблице есть колонки начала периода, конца периода и измерения
// Параметры:
//  ТабЗн - Таблица значений - С колонками дат и измерений
//  ИмяКолонкиНачалаПериода - Строка - Имя колонки, в которой содержатся начала периодов
//  ИмяКолонкиОкончанияПериода - Строка - Имя колонки, в которой содержатся начала периодов
Процедура СвернутьПериоды(ТабЗн, ИмяКолонкиНачалаПериода, ИмяКолонкиОкончанияПериода) Экспорт
	ИменаКолонок = СписокКолонок(ТабЗн, "Массив");
	Индекс_ = ИменаКолонок.Найти(ИмяКолонкиНачалаПериода);
	Если Индекс_ <> Неопределено Тогда
		ИменаКолонок.Удалить(Индекс_);
	КонецЕсли;
	Индекс_ = ИменаКолонок.Найти(ИмяКолонкиОкончанияПериода);
	Если Индекс_ <> Неопределено Тогда
		ИменаКолонок.Удалить(Индекс_);
	КонецЕсли;
	Имена_Колонок = СтрСоединить(ИменаКолонок, ",");
	ТабЗн.Сортировать(?(Имена_Колонок = "", "", Имена_Колонок + ",") + ИмяКолонкиНачалаПериода);
	ПрошлаяСтрока = ТабЗн[0];
	МассивКУдалению = Новый Массив;
	Для Ё = 1 По ТабЗн.Количество() - 1 Цикл
		ЭтаСтрока = ТабЗн[Ё];
		Если ВОЛНА_ОбщегоНазначения_КлиентСервер.ПореквизитноРавны(ПрошлаяСтрока, ЭтаСтрока, ИменаКолонок) И (ПрошлаяСтрока.Дата2 >= ЭтаСтрока.Дата1 - 1) Тогда
			Если ПрошлаяСтрока.Дата2 < ЭтаСтрока.Дата2 Тогда
				ПрошлаяСтрока.Дата2 = ЭтаСтрока.Дата2;
			КонецЕсли;
			МассивКУдалению.Добавить(ЭтаСтрока);
		Иначе
			ПрошлаяСтрока = ЭтаСтрока;
		КонецЕсли;
	КонецЦикла;
	ВОЛНА_ОбщегоНазначения_КлиентСервер.УдалитьЛишниеСтроки(ТабЗн, МассивКУдалению);
КонецПроцедуры // СвернутьПериоды

#КонецОбласти 

#Область ОПЕРАЦИИ_С_ДВУМЯ_ТЗ
	
//Добавляет записи из ТабИсточник в конец ТабПриёмник.
//Одноимённые поля скопируются автоматически. Если копируется что-то лишнее, можно подкорректировать структурами или исключением. Поля, не попавшие в структуры и исключения, копируются "один в один".
//Если объединяем несколько таблиц, или проблемы с типами (например, таблицы по результатам запроса), надо использовать ОбъединитьТаблицы
//Параметры:
//	ТабИсточник - ТаблицаЗначений или иная коллекция - поддерживающая Добавить и  обращение к элементу коллекции через []
//	ТабПриёмник - ТаблицаЗначений или иная коллекция - поддерживающая обращение к элементу коллекции через []
//	СтруктураКопируемыхКолонок - структура - описывающая копирование (Ключ - имя колонки приёмника, Значение - имя колонки источника). Необязательна.
//	СтруктураВычисляемыхКолонок - структура - поля приёмника (Ключ), которые вычисляются формулой для функции Вычислить (Значение); Можно применять имена Строка и СтрокаНовая, а также имена параметров процедуры. Необязательна.
//	Исключаемые поля - список полей, не подлежащих копированию, через запятую. Необязательны.
Процедура ДобавитьЗаписиИзТаблицыВТаблицу(ТабИсточник, ТабПриёмник, СтруктураКопируемыхКолонок = Неопределено, СтруктураВычисляемыхКолонок = Неопределено, ИсключаемыеПоля = "") Экспорт
	ЕстьСКК = СтруктураКопируемыхКолонок <> Неопределено;
	ЕстьСВК = СтруктураВычисляемыхКолонок <> Неопределено;
	КолонкиПриёмника = ?(ЕстьСКК или ЕстьСВК, ТабПриёмник.Колонки, Неопределено);
	Если ЕстьСКК Тогда
		Для каждого КиЗ Из СтруктураКопируемыхКолонок Цикл
			Если КолонкиПриёмника.Найти(КиЗ.Ключ) = Неопределено Тогда
				КолонкиПриёмника.Добавить(КиЗ.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если ЕстьСВК Тогда
		Для каждого КиЗ Из СтруктураВычисляемыхКолонок Цикл
			Если КолонкиПриёмника.Найти(КиЗ.Ключ) = Неопределено Тогда
				КолонкиПриёмника.Добавить(КиЗ.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Для каждого Строка из ТабИсточник Цикл
		СтрокаНовая = ТабПриёмник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаНовая, Строка,, ИсключаемыеПоля);
		Если ЕстьСКК Тогда
			Для каждого Колонка из СтруктураКопируемыхКолонок Цикл
				СтрокаНовая[Колонка.Ключ] = Строка[Колонка.Значение]
			КонецЦикла;
		КонецЕсли;
		Если ЕстьСВК Тогда
			Для каждого Колонка из СтруктураВычисляемыхКолонок Цикл
				СтрокаНовая[Колонка.Ключ] = Вычислить(Колонка.Значение)
			КонецЦикла
		КонецЕсли; 
	КонецЦикла
КонецПроцедуры //ДобавитьЗаписиИзТаблицыВТаблицу

// Возвращает массив имён общих колонок двух таблиц
// Параметры:
//  Таб1  - ТаблицаЗначений, ДеревоЗначений, Структура с коллекцией объектов со строковым свойством "Имя" в ключе "Колонки" - Первая таблица
//  Таб2  - ТаблицаЗначений, ДеревоЗначений, Структура с массивом строк в ключе "Колонки" - Вторая таблица
//  ВключатьНомерСтроки  - Булево - Обрабатывать колонку с именем "НомерСтроки". По умолчанию Ложь.
// Возвращаемое значение:
//   Массив   - Строки - имена общих колонкок таблиц
Функция ОбщиеКолонки(Таб1, Таб2, ВключатьНомерСтроки = Ложь) Экспорт
	Результат = Новый Массив;
	Для Каждого Колонка Из Таб1.Колонки Цикл
		ТекИмя = Колонка.Имя;
		Если (ТекИмя <> "НомерСтроки") ИЛИ ВключатьНомерСтроки Тогда
			Если Таб2.Колонки.Найти(ТекИмя) <> Неопределено Тогда
				Результат.Добавить(ТекИмя);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат
КонецФункции // ОбщиеКолонки

//Формирует разность двух таблиц с одинаковыми структурами колонок. Колонки сопоставляются по порядку в таблице (НЕ по имени!).
//Параметры:
//	ТаблицаВычитаемое - Таблица значений - строки которой считаются "Вычитаемыми"
//	ТаблицаУменьшаемое - Таблица значений - строки которой считаются "Положительными"
//	Сортировка - Строка - Имена колонко для сортировки результата
//	КПлюс - Число - Значение, которое возвратится в колонке "Знак" "положительных" строк
//Возвращаемое значение:
//	Таблица значений	- включает строки, встречающиеся только один раз в одной таблице. В добавленной колонке "Знак" в строках из "Вычитаемой" таблицы будет 0, "Уменьшаемой" - параметр КПлюс.
Функция РазницаТаблицЗначений(ТаблицаВычитаемое, ТаблицаУменьшаемое, Сортировка, КПлюс = 1) Экспорт
	ВсеКолонки = СписокКолонок(ТаблицаУменьшаемое);
	Результат = ТаблицаУменьшаемое.Скопировать();    
	Результат.Колонки.Добавить("Знак", Новый ОписаниеТипов("Число"));
	Результат.ЗаполнитьЗначения(КПлюс, "Знак");
	Для Счетчик = 1 По ТаблицаВычитаемое.Количество() Цикл 
		Результат.Вставить(0) 
	КонецЦикла;
	Для Счетчик = 0 По ТаблицаВычитаемое.Колонки.Количество() - 1 Цикл 
		Результат.ЗагрузитьКолонку(ТаблицаВычитаемое.ВыгрузитьКолонку(Счетчик), Счетчик) 
	КонецЦикла;
	Результат.Колонки.Добавить("Счёт");
	Результат.ЗаполнитьЗначения(1, "Счёт");
	Результат.Свернуть(ВсеКолонки, "Знак, Счёт");
	Результат = Результат.Скопировать(Новый Структура("Счёт", 1), ВсеКолонки + ", Знак");
	Результат.Сортировать(Сортировка);
	Возврат Результат;
КонецФункции

// Распределяет суммы из строк таблицы пропорционально базе из другой таблицы. Общие колонки являются измерениями, по ним идёт поиск базы. Различные - ресурсы, все они будут присутствовать в финальной строке.
// Параметры:
//  Суммы  - ТаблицаЗначений - Таблица, содержащая распределяемые суммы
//  База  - ТаблицаЗначений - Таблица, содержащая значения базы
//  КолонкиСумм  - Массив/Строка - Массив имён колонок, содержащих распределяемые суммы. По умолчанию "Сумма".
//  КолонкаБазы  - Строка - Имя колонки, содержащей базу. По умолчанию "База".
//  Обработчик  - "Менеджер" - Обработчик, выполняемый в момент, когда найдена строка и база к ней.
//			Использует ключи структуры Прм: РаспределяемаяСтрока (Строка из Суммы), КолонкиСумм, База (отбранные строки из База), ПолнаяБаза (База), КолонкаБазы, Параметры.
//  ПараметрыОбработчика  - Структура/Неопределено - Параметры, доступные в обработчике. По умолчанию Неопределено.
//	ПоместитьЗначенияБазыВРезультат - Строка - Вапиант переноса значения базы в результат. По умолчанию "Нет".
//			Возможные варианты:
//			*"Нет" - колонки КолонкаБазы в результате не будет
//			*"Пустая" - в колонку будут занесены нули.
//			*"КакЕсть" - в колонку будут занесены применённые коэффициенты, что будет наглядно. Итог по базе будет задублирован.
//			*Имя колонки сумм - Базу распределить пропорционально результату из указанной колонки. Медленнее, не наглядно, но итог по базе сойдётся.
//	ТочностьСумм - Число/Массив чисел - Число цифр после запятой в суммах. По умолчанию 2. 
//	ТочностьБазы - Число - Число цифр после запятой в базе. По умолчанию 3. 
// Возвращаемое значение:
//   Таблица значений   - Таблица - соединение со всеми колонками таблиц сумм и базы и с суммами, распределёнными пропорционально базе.
Функция РаспределитьПоБазе(Суммы, База, КолонкиСумм = "Сумма", КолонкаБазы = "База", Обработчик = "",
		ПараметрыОбработчика = Неопределено, ПоместитьЗначенияБазыВРезультат = "Нет", ТочностьСумм = 2, ТочностьБазы = 3, РаспределятьНаНулевуюБазуЕслиОднаСтрока = Ложь) Экспорт

	#Область ИНИЦИАЛИЗАЦИЯ
		ЕстьОбработчик = ЗначениеЗаполнено(Обработчик);
		Если ТипЗнч(КолонкиСумм) = Тип("Строка") Тогда
			ИменаКолонокСумм = СтрРазделить(КолонкиСумм, ",");
		Иначе
			ИменаКолонокСумм = ВОЛНА_ОбщегоНазначения_КлиентСервер.ПреобразоватьВМассив(КолонкиСумм, Истина,, Истина);
		КонецЕсли;
		Точности = Новый Структура;
		ПараметрТочностиМассивом = ТипЗнч(ТочностьСумм) = Тип("Массив");
		Ё = 0;
		Для каждого ИмяКС Из ИменаКолонокСумм Цикл
			//Если База.Колонки.Найти(ИмяКС) <> Неопределено Тогда
			//	ИКССтрокой = ИКССтрокой + "," + ИмяКС;
			//КонецЕсли;
			Точности.Вставить(ИмяКС, ?(ПараметрТочностиМассивом, ТочностьСумм[Ё], ТочностьСумм));
			Ё = Ё + 1;
		КонецЦикла;
		//ИКССтрокой = Сред(ИКССтрокой, 2);
		Результат = ВыгрузитьКолонкиГрупповая(Новый Структура("Таб1,Таб2", Суммы, База));
		ИменаКолонокСумм.Добавить(КолонкаБазы);//Временно
		ИзмеренияРезультата = ВОЛНА_ОбщегоНазначения_КлиентСервер.РазностьМассивов(СписокКолонок(Результат, "Массив"), ИменаКолонокСумм);
		КолонкиПоиска = ВОЛНА_ОбщегоНазначения_КлиентСервер.РазностьМассивов(ОбщиеКолонки(База, Суммы), ИменаКолонокСумм);
		ИменаКолонокСумм.Удалить(ИменаКолонокСумм.ВГраница());
		ПараметрыКПередачеВОбработчик = Новый Структура("РаспределяемаяСтрока,КолонкиСумм,База,ПолнаяБаза,КолонкаБазы,Параметры",
				"", ИменаКолонокСумм, "", База, КолонкаБазы, ПараметрыОбработчика);
	#КонецОбласти 
	
	#Область РАСПРЕДЕЛЕНИЕ_СУММ
	    ОбратноеСоответствие = Новый Соответствие;
		Для Каждого СтрокаСумм из Суммы Цикл
			СтруктураОтбора = Новый Структура;
			Для Каждого ИмяКолонки Из КолонкиПоиска Цикл
				Если ЗначениеЗаполнено(СтрокаСумм[ИмяКолонки]) Тогда
					СтруктураОтбора.Вставить(ИмяКолонки, СтрокаСумм[ИмяКолонки]);
				КонецЕсли;
			КонецЦикла;
			ТекБаза = База.НайтиСтроки(СтруктураОтбора);
			Если ЕстьОбработчик Тогда
				ПараметрыКПередачеВОбработчик.Вставить("РаспределяемаяСтрока", СтрокаСумм);
				ПараметрыКПередачеВОбработчик.Вставить("База", ТекБаза);
				ВыполнитьКод(Обработчик, ПараметрыКПередачеВОбработчик);
			КонецЕсли; 
			МассивБазы = Новый Массив;
			Для каждого ТекСтр Из ТекБаза Цикл
				МассивБазы.Добавить(ТекСтр[КолонкаБазы]);
				Если ОбратноеСоответствие[ТекСтр] = Неопределено Тогда
					ОбратноеСоответствие.Вставить(ТекСтр, Новый Массив);
				КонецЕсли;
			КонецЦикла;
			Распределённые = Новый Структура;
			Если РаспределятьНаНулевуюБазуЕслиОднаСтрока И (МассивБазы.Количество() = 1) И (МассивБазы[0] = 0) Тогда
				МассивБазы[0] = 1;
			КонецЕсли;
			Для каждого ИмяКолонкиСуммы Из ИменаКолонокСумм Цикл
				Если СтрокаСумм[ИмяКолонкиСуммы] <> 0 Тогда
					ТекРезультат = ВОЛНА_ОбщегоНазначения_КлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(СтрокаСумм[ИмяКолонкиСуммы], МассивБазы, Точности[ИмяКолонкиСуммы]);
					Если ТекРезультат = Неопределено Тогда
						НоваяЗапись = Результат.Добавить();
						ЗаполнитьЗначенияСвойств(НоваяЗапись, СтрокаСумм);
						Для каждого ТекСтр Из ТекБаза Цикл
							ОбратноеСоответствие[ТекСтр].Добавить(НоваяЗапись);
						КонецЦикла;
						Прервать;
					Иначе
						Распределённые.Вставить(ИмяКолонкиСуммы, ТекРезультат);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла; 
			Если Распределённые.Количество() > 0 Тогда
				Для ЁЖЖ = 0 По Распределённые[ИменаКолонокСумм[0]].ВГраница() Цикл
					НадоДобавитьЗапись = Ложь;
					Для каждого КиЗ Из Распределённые Цикл
						Если КиЗ.Значение[ЁЖЖ] <> 0 Тогда
							НадоДобавитьЗапись = Истина;
							Прервать;
						КонецЕсли; 
					КонецЦикла; 
					Если НадоДобавитьЗапись Тогда
						НоваяЗапись = Результат.Добавить();
//						Для каждого ТекСтр Из ТекБаза Цикл
						ОбратноеСоответствие[ТекБаза[ЁЖЖ]].Добавить(НоваяЗапись); //ТекСтр
//						КонецЦикла;
						ЗаполнитьЗначенияСвойств(НоваяЗапись, СтрокаСумм);
						ЗаполнитьЗначенияСвойств(НоваяЗапись, ТекБаза[ЁЖЖ]);
						Для каждого ИмяКолонкиСуммы Из ИменаКолонокСумм Цикл
							НоваяЗапись[ИмяКолонкиСуммы] = 0;
						КонецЦикла; 
						Для каждого КиЗ Из Распределённые Цикл
							НоваяЗапись[КиЗ.Ключ] = КиЗ.Значение[ЁЖЖ];
						КонецЦикла; 
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЦикла;
	#КонецОбласти 
	ИКСВсеСтрокой = СтрСоединить(ИменаКолонокСумм);
	#Область БАЗУ_В_РЕЗУЛЬТАТ
		ПоследнийРесурс = КолонкаБазы;
		//Базы заносятся отдельными строками, т.к. если заносить базы вместе с распределёнными суммами, то при повторном использовании строки базы её сумма попадёт в результат повторно.
		Если ПоместитьЗначенияБазыВРезультат = "КакЕсть" Тогда
		ИначеЕсли ПоместитьЗначенияБазыВРезультат = "Нет" Тогда
			Результат.Колонки.Удалить(КолонкаБазы);
			ПоследнийРесурс = "";
		Иначе
			Результат.ЗаполнитьЗначения(0, КолонкаБазы);
			Если ПоместитьЗначенияБазыВРезультат <> "Пустая" Тогда
				Для каждого КиЗ Из ОбратноеСоответствие Цикл
					Если КиЗ.Ключ[КолонкаБазы] <> 0 Тогда
						НужнаНоваяЗаписьРезультатаТолькоСБазой = Ложь;
						Если КиЗ.Значение.Количество() = 0 Тогда
							НужнаНоваяЗаписьРезультатаТолькоСБазой = Истина;
						Иначе
							МассивБазы = Новый Массив;
							Для каждого СтрСуммы Из КиЗ.Значение Цикл
								МассивБазы.Добавить(СтрСуммы[ПоместитьЗначенияБазыВРезультат]);
							КонецЦикла; 
							ТекРезультат = ВОЛНА_ОбщегоНазначения_КлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(КиЗ.Ключ[КолонкаБазы], МассивБазы, ТочностьБазы);
							Если ТекРезультат = Неопределено Тогда
								НужнаНоваяЗаписьРезультатаТолькоСБазой = Истина;
								Прервать;
							Иначе
								Для СчХ = 0 По ТекРезультат.ВГраница() Цикл
									КиЗ.Значение[СчХ][КолонкаБазы] = КиЗ.Значение[СчХ][КолонкаБазы] + ТекРезультат[СчХ];
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
						Если НужнаНоваяЗаписьРезультатаТолькоСБазой Тогда
							НоваяЗапись = Результат.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяЗапись, КиЗ.Ключ);
						КонецЕсли;
					КонецЕсли;
				КонецЦикла; 
				
				//СтекСумм = Новый Структура;
				//Для каждого ИмяКолонки Из ИменаКолонокСумм Цикл
				//	Если ИмяКолонки <> ПоместитьЗначенияБазыВРезультат Тогда
				//		СтекСумм.Вставить(ИмяКолонки, Суммы.ВыгрузитьКолонку(ИмяКолонки));
				//		Суммы.ЗаполнитьЗначения(0, ИмяКолонки);
				//	КонецЕсли;
				//КонецЦикла; 
				//ДобавитьЗаписиИзТаблицыВТаблицу(РаспределитьПоБазе(База, Суммы, КолонкаБазы, ПоместитьЗначенияБазыВРезультат,,, "Пустая", ТочностьБазы), Результат);
				//Для каждого КиЗ Из СтекСумм Цикл
				//	Суммы.ЗагрузитьКолонку(КиЗ.Значение, КиЗ.Ключ);
				//КонецЦикла; 
				//Для каждого Строчка Из База Цикл
				//	НоваяСтрока = Результат.Добавить();
				//	ЗаполнитьЗначенияСвойств(НоваяСтрока, Строчка,, ИКССтрокой);
				//КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	#КонецОбласти
	
	Результат.Свернуть(СтрСоединить(ИзмеренияРезультата), ИКСВсеСтрокой + ?((ИКСВсеСтрокой = "") ИЛИ (ПоследнийРесурс = ""), "", ",") + ПоследнийРесурс);
	Возврат Результат
КонецФункции // РаспределитьПоБазе

// Приводит колонки одной таблицы в соответствие другой.
// Параметры:
//  Приёмник  - Таблица значений или дерево значений - колонки которой меняются
//  Источник  - Таблица значений или дерево значений - колонки которой переносятся
//  Метод  - Число - метод переноса:
//			* 0 - Считать, что колонок источника заведомо нет в приёмнике и переносить без проверок;
//			* 1 - Добавить только недостающие колонки из источника;
//			* 2 - Удалить совпадающие по именам колонки в приёмнике и перенести все колонки источника;
//			* 3 - Удалить вообще все колонки приёмника и перенести все колонки источника. Используется, когда нельзя присвоить значение в источник (например, в реквизите формы).
//			* 4 - Проверять наличие колонки источника в приёмнике. Если колонка там есть, колонка источника будет добавлена под корректным сгенерированным именем.
//  НеДобавлятьКолонки  - Структура или Неопределено - Список колонок источника, не переносимых в приёмник. По умолчанию пустая строка.
//  СтруктураСоответствияКолонок  - Структура или Неопределено - Структура, в которой при Метод = 4 возвращается соответствие имён колонок (Ключ - имя в источнике, Значение - в приёмнике)
Процедура СкоррелироватьКолонкиТаблиц(Приёмник, Источник, Метод = 3, НеДобавлятьКолонки = "", СтруктураСоответствияКолонок = Неопределено) Экспорт
	Если (Метод = 4) И (СтруктураСоответствияКолонок = Неопределено) Тогда
		СтруктураСоответствияКолонок = Новый Структура;
	КонецЕсли;
	Если Метод = 3 Тогда
		Приёмник.Колонки.Очистить();
	КонецЕсли;
	Для каждого Колонка Из Источник.Колонки Цикл
		Если ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодстроку(НеДобавлятьКолонки, Колонка.Имя, ",") = 0 Тогда
			НовоеИмя = СкопироватьКолонку(Приёмник.Колонки, Колонка,, Метод);
			Если Метод = 4 Тогда
				СтруктураСоответствияКолонок.Вставить(Колонка.Имя, НовоеИмя);
			КонецЕсли;
		КонецЕсли; 
	КонецЦикла; 
КонецПроцедуры // СкоррелироватьКолонкиТаблиц()

#КонецОбласти 

//Возвращает список имён колонок таблицы или дерева значений через запятую
//Параметры:
//	ТабИлиДерево - Таблица, Временная таблица или дерево значений - Источник данных
//	СтрокаМассивСписок - Строка - "Строка", "Массив" или "Список" - тип возвращаемого значения
//	Разделитель - Строка - раделитель для результата-строки. По умолчанию ",".
//Возвращаемое значение:
//	Строка, Масси в или Список значений - Список имён колонок. Строка - через запятую, список - с заголовками в представлениях.
Функция СписокКолонок(ТабИлиДерево, СтрокаМассивСписок = "Строка", Разделитель = ",") Экспорт
	Если СтрокаМассивСписок = "Массив" Тогда
		Результат = Новый Массив;
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат.Добавить(Колонка.Имя);
		КонецЦикла; 
	ИначеЕсли СтрокаМассивСписок = "Список" Тогда
		Результат = Новый СписокЗначений;
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат.Добавить(Колонка.Имя, Колонка.Заголовок);
		КонецЦикла; 
	Иначе
		Результат = "";
		Для каждого Колонка Из ТабИлиДерево.Колонки Цикл
			Результат = Результат + Разделитель + Колонка.Имя;
		КонецЦикла; 
		Результат = Сред(Результат, СтрДлина(Разделитель) + 1);
	КонецЕсли;
	Возврат Результат
КонецФункции // СписокКолонок()
 
#КонецОбласти

// Подводит итоги по строкам ветки дерева
// Параметры:
//  Ёлка  - Строка дерева значений - Ветка, строки которой надо итожить
//  Колонки  - Структура - Ключи = колонки, Значения = агрегатные функции:
//			*КОЛИЧЕСТВОНЕПУСТЫХ
//			*КОЛИЧЕСТВОРАЗЛИЧНЫХ
//			*МИНИМУМ
//			*МАКСИМУМ
//			*ПРОИЗВ
//			*СУММА
//			*СУММКВ
//		По умолчанию 1 колонка с именем = "Флаг" и значением = "Минимум"
//	ИтожитьПодчинённые - Булево - подводить итог подчинённых строк. По умолчанию Истина
Процедура ИтогСтрокДерева(Ёлка, Колонки = Неопределено, ИтожитьПодчинённые = Истина) Экспорт
	Если Ёлка.Строки.Количество() Тогда
		Если ИтожитьПодчинённые Тогда
			Для каждого Дочка Из Ёлка.Строки Цикл
				ИтогСтрокДерева(Дочка, Колонки, Истина);
			КонецЦикла;
		КонецЕсли;
		Если Колонки = Неопределено Тогда
			Колонки = Новый Структура("Флаг", "МИНИМУМ");
		КонецЕсли;
		Для каждого КиЗ Из Колонки Цикл
			Если КиЗ.Значение = "КОЛИЧЕСТВОНЕПУСТЫХ" Тогда
				Ёлка[КиЗ.Ключ] = 0;
				Для каждого Дочка Из Ёлка.Строки Цикл
					Если ЗначениеЗаполнено(Дочка[КиЗ.Ключ]) Тогда
						Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + 1;
					КонецЕсли;
				КонецЦикла;
			ИначеЕсли КиЗ.Значение = "КОЛИЧЕСТВОРАЗЛИЧНЫХ" Тогда
				ТМП = Новый Соответствие;
				Для каждого Дочка Из Ёлка.Строки Цикл
					ТМП.Вставить(Дочка[КиЗ.Ключ], 0);
				КонецЦикла;
				Ёлка[КиЗ.Ключ] = ТМП.Количество();
			ИначеЕсли КиЗ.Значение = "МИНИМУМ" ИЛИ КиЗ.Значение = "МАКСИМУМ" Тогда
				Порядок_ = ?(КиЗ.Значение = "МАКСИМУМ", " УБЫВ", "");
				Умолчание = NULL;
				ТМП = Новый ТаблицаЗначений;
				ТМП.Колонки.Добавить("Первая");
				Для каждого Дочка Из Ёлка.Строки Цикл
					ТМП.Добавить().Первая = Дочка[КиЗ.Ключ];
				КонецЦикла;
				ТМП.Сортировать("Первая" + Порядок_);
				Ёлка[КиЗ.Ключ] = ?(ТМП.Количество(), ТМП[0].Первая, Умолчание);
			ИначеЕсли КиЗ.Значение = "ПРОИЗВ" Тогда
				Ёлка[КиЗ.Ключ] = 1;
				Для каждого Дочка Из Ёлка.Строки Цикл
					Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] * Дочка[КиЗ.Ключ];
				КонецЦикла;
			ИначеЕсли КиЗ.Значение = "СУММА" Тогда
				Ёлка[КиЗ.Ключ] = 0;
				Для каждого Дочка Из Ёлка.Строки Цикл
					Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + Дочка[КиЗ.Ключ];
				КонецЦикла;
			ИначеЕсли КиЗ.Значение = "СУММКВ" Тогда
				Ёлка[КиЗ.Ключ] = 0;
				Для каждого Дочка Из Ёлка.Строки Цикл
					Ёлка[КиЗ.Ключ] = Ёлка[КиЗ.Ключ] + Дочка[КиЗ.Ключ] * Дочка[КиЗ.Ключ];
				КонецЦикла;
			КонецЕсли;;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры // ИтогСтрокДерева

// Копирует содержимое одного дерева в другое, существующее
// Параметры:
//  Приёмник  - Дерево значений - Дерево значений, в которое будут добавлены новые данные
//  Источник  - Дерево значений - Дерево значений, из которого будут взяты данные
//  ИменаКлючевыхКолонок  - Строка - Имена колонок для поиска соответствующих строк. Если пустая (по умолчанию), считается, что соответствующих строк нет. Если найдено несколько строк, первая считается найденной.
//  СкоррелироватьКолонки  - Булево - Надо приводить в соответстввие колонки. По умолчанию Истина. Для ветвей приёмника и источника обязательно Ложь.
Процедура СкопироватьДерево(Приёмник, Источник, ИменаКлючевыхКолонок = "", СкоррелироватьКолонки = Истина) Экспорт
	Если СкоррелироватьКолонки Тогда
		СкоррелироватьКолонкиТаблиц(Приёмник, Источник, 1);
	КонецЕсли;
	ЭтиСтроки = Приёмник.Строки;
	Для каждого СтрокаДЗ Из Источник.Строки Цикл
		СтрокаПриёмник = "";
		Если ИменаКлючевыхКолонок <> "" Тогда
			СтруктураПоиска = Новый Структура(ИменаКлючевыхКолонок);
			ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаДЗ);
			МассивНайденныхСтрок = ЭтиСтроки.НайтиСтроки(СтруктураПоиска);
			Если МассивНайденныхСтрок.Количество() > 0 Тогда
				СтрокаПриёмник = МассивНайденныхСтрок[0];
			КонецЕсли; 
		КонецЕсли; 
		Если СтрокаПриёмник = "" Тогда
			СтрокаПриёмник = ЭтиСтроки.Добавить();
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(СтрокаПриёмник, СтрокаДЗ);
		СкопироватьДерево(СтрокаПриёмник, СтрокаДЗ, ИменаКлючевыхКолонок, Ложь);
	КонецЦикла; 
КонецПроцедуры // СкопироватьДерево

#КонецОбласти

#Область СТРОКОВЫЕ

//Создаёт тестер маски.
//Параметры:
//	Маска - Строка - Маска для проверки. По умолчанию - маска проверки даты. Описание синтаксиса маски в функции ПроверитьСтроку
Функция ЗначениеXDTOдляПроВеркиСтроки(Маска = "\d{2}\.\d{2}\.\d{4}") Экспорт
    Чтение = Новый ЧтениеXML;
    Чтение.УстановитьСтроку(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>" + Маска + "</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>");

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
    Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Возврат МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));
КонецФункции // XDTOдляПроВеркиСтроки()
 
// Возврщает дерево процедур и функций модуля с учётом областей
// Параметры:
//  ТекстМодуля - Строка - Текст модуля, в котором ищутся методы
//  ТолькоЭкспорт - Булево - Выбирать только экспортные процедуры
//  ОбластьРодитель - Строка - Имя области, внутри которой ищутся процедуры. Допускается, что в модуле м.б. несколько областей с этим именем. Сам родитель в дерево не попадает. По умолчанию "" - обрабатывается весь модуль.
//  ТегМеню - Строка - Префикс строки (после знака комментария), идентифицирующий в модуле строку представления в дереве. Эта строка может быть в любом месте метода и не включается в другие тексты. По умолчанию "МЕНЮ:".
// Возвращаемое значение:
//   Дерево значений   - Список методов модуля с колонками "Представление", "Имя", "Описание", "ПолноеОписание", "Текст", "Вид", "Экспорт" и "Параметры"
Функция ДеревоМетодовМодуля(ТекстМодуля, ТолькоЭкспорт = Истина, ОбластьРодитель = "", ТегМеню = "МЕНЮ:") Экспорт
	Результат = Новый ДеревоЗначений;
	#Область КОЛОНКИ
		Результат.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("ПолноеОписание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Вид", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
		Результат.Колонки.Добавить("Экспорт", Новый ОписаниеТипов("Булево")); 
		Результат.Колонки.Добавить("Параметры", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная))); 
	#КонецОбласти
	
	Стек = Новый Массив;
	Коммент = Ложь; //Строка в теле комментария перед функцией
	Сброс = Истина; //Перед обработкой следующей строки обнулить данные записи
	Тело = Ложь; //Строка в теле функции
	СложныйКоммент = ""; //Комментарий, включающий область
	Заголовок = 0; //0 - это не заголовок, 1 - обработка заголовка до первой скобки, 2 - до второй скобки, 3 - после второй скобки
	Ветка = Результат;
	ДлТМ = СтрДлина(ТегМеню);
	РазрешеноЧтение = ОбластьРодитель = ""; //Строка внутри разрешённой области-родителя
	ИменаКолонок = СписокКолонок(Результат);
	Для Ё = 1 По СтрЧислоСтрок(ТекстМодуля) Цикл
		Если Сброс Тогда
			Сброс = Ложь;
			Тело = Ложь;
			Заготовка = Новый Структура(ИменаКолонок);
			//Если СложныйКоммент <> "" Тогда
				Заготовка.Вставить("ПолноеОписание", СложныйКоммент);
			//КонецЕсли;
			Заготовка.Вставить("Текст", "");
			Заготовка.Вставить("Экспорт", Ложь);
			СложныйКоммент = "";
		КонецЕсли;
		ТекСтрока = СокрЛП(СтрПолучитьСтроку(ТекстМодуля, Ё));
		Готово = Ложь; //Создать строку дерева после обработки строки модуля
		ВТекст = Ложь; //Вставить строку в текст метода
		ВКоммент = Ложь; // Вставить строку в текст комментария
		Если Лев(ТекСтрока, 2) = "//" Тогда
			ТекКоммент = СокрЛП(Сред(ТекСтрока, 3));
			Если Лев(ТекКоммент, ДлТМ) = ТегМеню Тогда
				Заготовка.Вставить("Представление", Сред(ТекКоммент, ДлТМ + 1));
			ИначеЕсли НЕ Тело Тогда
				Если НЕ Коммент Тогда
					Коммент = Истина;
					Заготовка.Вставить("ПолноеОписание", "");
				КонецЕсли;
				Если Лев(ТекКоммент, 9) = "Параметры" Тогда
					Заготовка.Вставить("Описание", Сред(Заготовка.ПолноеОписание, 2));
				КонецЕсли;
				ВКоммент = Истина;
			Иначе
				ВТекст = Истина;
			КонецЕсли; 
		ИначеЕсли Лев(ТекСтрока, 1) = "&" Тогда
			ВТекст = Тело;
		Иначе
			ЭтоПроц = НРег(Лев(ТекСтрока, 9)) = "процедура";
			ЭтоФ = НРег(Лев(ТекСтрока, 7)) = "функция";
			ЭтоОбл = НРег(Лев(ТекСтрока, 8)) = "#область";
			ЭтоКПроц = НРег(Лев(ТекСтрока, 14)) = "конецпроцедуры";
			ЭтоКФ = НРег(Лев(ТекСтрока, 12)) = "конецфункции";
			ЭтоКОбл = НРег(Лев(ТекСтрока, 13)) = "#конецобласти";
			Если ЭтоПроц ИЛИ ЭтоФ ИЛИ (Заголовок > 0) Тогда
				Тело = Истина;
				Если ЭтоПроц Или ЭтоФ Тогда
					Заготовка.Вставить("Текст", ТекСтрока);
					Заготовка.Вставить("Вид", ?(ЭтоФ, "Функция", "Процедура"));
					Квант = СокрЛП(Сред(ТекСтрока, ?(ЭтоФ, 9, 11)));
					Заголовок = 1;
					ПроверитьДругиеВарианты = Ложь;
				Иначе
					ПроверитьДругиеВарианты = Заголовок = 3; //Новая строка после скобки может быть новым оператором
					ВТекст = Истина;
					Квант = ТекСтрока;
				КонецЕсли;
				ВКоммент = НЕ ПроверитьДругиеВарианты; //Если нет других вариантов - это заголовок метода, он должен попадать в полный коммент
				//Имя метода
				Если Заголовок = 1 Тогда
					ПСкобки = Найти(Квант, "(");
					Если ПСкобки = 0 Тогда
						Если НЕ ПустаяСтрока(Квант) Тогда
							Сброс = Истина;
						КонецЕсли;
					Иначе
						Заготовка.Вставить("Имя", Лев(Квант, ПСкобки - 1));
						Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
						Заголовок = 2;
					КонецЕсли;
				КонецЕсли;
				Если Заголовок = 2 Тогда
					ПСкобки = Найти(Квант, ")");
					Если ПСкобки = 0 Тогда
						Если НЕ ПустаяСтрока(Квант) Тогда
							Сброс = Истина;
						КонецЕсли;
					Иначе
						Заготовка.Вставить("Параметры", Лев(Квант, ПСкобки - 1));
						Квант = СокрЛП(Сред(Квант, ПСкобки + 1));
						Заголовок = 3;
					КонецЕсли;
				КонецЕсли;
				Если Заголовок = 3 Тогда
					Заголовок = 0;
					Заготовка.Вставить("Экспорт", НРег(Лев(Квант, 7)) = "экспорт");
				КонецЕсли;
			Иначе
				ПроверитьДругиеВарианты = Истина;
			КонецЕсли;
			Если ПроверитьДругиеВарианты Тогда
				ВТекст = Тело;
				Если ЭтоОбл Тогда
					Сброс = Истина;
					Готово = РазрешеноЧтение;
					Заготовка.Вставить("Вид", "Подменю");
					Заготовка.Вставить("Имя", СокрЛП(Сред(ТекСтрока, 10)));
					Если (Заготовка.Имя = ОбластьРодитель) И (ОбластьРодитель <> "") Тогда
						РазрешеноЧтение = Истина;
					КонецЕсли;
				ИначеЕсли ЭтоКОбл Тогда
					Сброс = Истина;
					Если Стек.Количество() = 0 Тогда
						РазрешеноЧтение = Ложь;
					Иначе
						Колво = Ветка.Строки.Количество();
						КомментВОбласти = "";
						УдалитьПодменю = (Колво = 0) ИЛИ ((Колво = 1) И ТолькоЭкспорт);
						УдаляемоеПодменю = Ветка;
						КомментВнутриОбласти = Заготовка.ПолноеОписание;
						Ветка = Стек[Стек.ВГраница()];
						Стек.Удалить(Стек.ВГраница());
						Если УдалитьПодменю Тогда
							СложныйКоммент = "" + УдаляемоеПодменю.ПолноеОписание + Символы.ПС + "#Область" + УдаляемоеПодменю.Имя + Символы.ПС + КомментВнутриОбласти + Символы.ПС + ТекСтрока;
							Если Колво = 1 Тогда
								ЗаполнитьЗначенияСвойств(Ветка.Строки.Добавить(), УдаляемоеПодменю.Строки[0]);
							КонецЕсли;
							Ветка.Строки.Удалить(УдаляемоеПодменю);
						КонецЕсли;
					КонецЕсли; 
				ИначеЕсли ЭтоКПроц ИЛИ ЭтоКФ Тогда
					Готово = Истина;
					Сброс = Истина;
				КонецЕсли;
			КонецЕсли;
			Если Коммент И НЕ Тело Тогда
				Заготовка.Вставить("ПолноеОписание", "");
				Заготовка.Вставить("Описание", "");
			КонецЕсли;
			Коммент = Ложь;
		КонецЕсли;
		Если ВКоммент Тогда
			Заготовка.Вставить("ПолноеОписание", Заготовка.ПолноеОписание + Символы.ПС + ТекСтрока);
		КонецЕсли;
		Если ВТекст Тогда
			Заготовка.Вставить("Текст", Заготовка.Текст + Символы.ПС + ТекСтрока);
		КонецЕсли;
		Если Готово Тогда
			Если РазрешеноЧтение Тогда
				ЭтоПодменю = Заготовка.Вид = "Подменю";
				Если ЭтоПодменю ИЛИ Заготовка.Экспорт ИЛИ НЕ ТолькоЭкспорт Тогда
					Если ПустаяСтрока(Заготовка.Представление) Тогда
						Заготовка.Вставить("Представление", Заготовка.Имя);
					КонецЕсли;
					НоваяСтрока = Ветка.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Заготовка);
					Если ЭтоПодменю Тогда
						Стек.Добавить(Ветка);
						Ветка = НоваяСтрока;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Готово = Ложь;
		КонецЕсли;
	КонецЦикла; 
	Возврат Результат
КонецФункции // ДеревоМетодовМодуля

#КонецОбласти

#Область ЗАПРОСЫ

#Область ТЕКСТЫ_ЗАПРОСОВ

// Возвращает текст запроса к таблице регистра с фильтрацией
// Параметры:
//  ИмяМенеджераРегистра  - Строка - Имя регистра в формате РегистрыСведений.АдресныеСведения
//  Фильтр  - Строка - Фильтр ТабРегистра с ГДЕ.
//  ИмяВТ  - Строка - Имя ВТ результата. По умолчанию выборка данных.
//  ПоляВзять  - Строка - Через запятую имена полей результата. По умолчанию все поля.
//  ПоляНеБрать  - Строка - Через запятую поля, исключаемые из результата. По умолчанию без исключений.
// Возвращаемое значение:
//   Строка   - Текст запроса
Функция ТекстЗапросаДанныеРегистра(ИмяМенеджераРегистра, Фильтр = "", ИмяВТ = "", ПоляВзять = "", ПоляНеБрать = "") Экспорт
	Результат = "ВЫБРАТЬ" + Символы.ПС;
	ПоляВсе = СтруктураЗаписиРегистра(ИмяМенеджераРегистра);
	ЕстьВзять = ЗначениеЗаполнено(ПоляВзять);
	ЕстьНеБрать = ЗначениеЗаполнено(ПоляНеБрать);
	Для каждого КиЗ_Поле Из ПоляВсе Цикл
		Если ЕстьВзять Тогда
			Если ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(ПоляВзять, КиЗ_Поле.Ключ) = 0 Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Если ЕстьНеБрать Тогда
			Если ВОЛНА_ОбщегоНазначения_КлиентСервер.НайтиПодСтроку(ПоляНеБрать, КиЗ_Поле.Ключ) <> 0 Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Результат = Результат + "	ТабРегистра." + КиЗ_Поле.Ключ + "," + Символы.ПС;
	КонецЦикла;
	Результат = Лев(Результат, СтрДлина(Результат) - 2) + Символы.ПС + ?(ЗначениеЗаполнено(ИмяВТ), "ПОМЕСТИТЬ " + ИмяВТ + Символы.ПС, "")
			+ "ИЗ " + СтрЗаменить(ИмяМенеджераРегистра, "Регистры", "Регистр") + " КАК ТабРегистра" + Символы.ПС + Фильтр;
	Возврат Результат
КонецФункции // ТекстЗапросаДанныеРегистра

// Создаёт текст запроса, возвращающего числа от А до Б включительно в ВТ Числа
// Параметры:
//  ЧислоА  - Число - Первое число возвращаемого интервала
//  ЧислоБ  - Число - Последнее число возвращаемого интервала
// Возвращаемое значение:
//   Строка   - Текст запроса
Функция ТекстЗапросаСчётчик(ЧислоА, ЧислоБ) Экспорт
	Чисел = ЧислоБ - ЧислоА + 1;
	Степень = Цел(Log10(Чисел)) + 1;
	Соединения = "Цифры" + Степень + Символы.ПС;
	Вычисления = "";
	Множитель = 1;
	
	Для Ё = 1 По Степень Цикл
		Вычисления = Вычисления + " + " + Множитель + " * Цифры" + Ё + ".Цифра";
		Множитель = Множитель * 10;
	КонецЦикла;
	Для Ё = 1 По Степень - 1 Цикл
		Соединения = Соединения + "ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры" + (Степень - Ё) + "
				|		ПО (ИСТИНА)
				|";
		Множитель = Множитель * 10;
	КонецЦикла;
	
	Результат = "ВЫБРАТЬ
	            |	0 КАК Цифра
	            |ПОМЕСТИТЬ Цифры
	            |";
	Для Ё = 1 По 9 Цикл
		Результат = Результат + "ОБЪЕДИНИТЬ ВСЕ
	            |
	            |ВЫБРАТЬ
	            |	" + Ё + "
	            |
	            |"
	КонецЦикла;
	Результат = Результат + ";
	            |
	            |////////////////////////////////////////////////////////////////////////////////
	            |" + 
				СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(
				"ВЫБРАТЬ
                |	&ЧислоА + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра КАК Число
                |ПОМЕСТИТЬ Числа
                |ИЗ
                |	(ВЫБРАТЬ
                |		Цифры.Цифра КАК Цифра
                |	ИЗ
                |		Цифры КАК Цифры
                |	ГДЕ
                |		Цифры.Цифра <= &ПерваяЦифраБ) КАК Цифры3
                |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры2
                |		ПО (ИСТИНА)
                |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры1
                |		ПО (ИСТИНА)
                |ГДЕ
                |	&ЧислоА + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра <= &ЧислоБ",
				"&ЧислоА", ЧислоА),
				"&ЧислоБ", ЧислоБ),
				"&ПерваяЦифраБ", Лев(Чисел, 1)),
				"Цифры3
					|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры2
					|		ПО (ИСТИНА)
					|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Цифры КАК Цифры1
					|		ПО (ИСТИНА)", Соединения),
				" + Цифры1.Цифра + 10 * Цифры2.Цифра + 100 * Цифры3.Цифра", Вычисления) +
				";
				|
				|////////////////////////////////////////////////////////////////////////////////
				|УНИЧТОЖИТЬ Цифры
				|;";
	Возврат Результат
КонецФункции // ТекстЗапросаСчётчик

#КонецОбласти

// Заполняет незаданные параметры запроса заданными значениями
// Параметры:
//  Запрос_  - Запрос - с установленным текстом, в котором будут проверяться и устанавливаться параметры
//  Значения  - Любое значение - значение, по которому будут задаваться параметры.
//		*Структура - Имя параметра с ключом будет заполнено значением (только для незаполненных). Ненайденные будут заполнены значением по умолчанию (из ключа "ОСТАЛЬНЫЕ" или общего)
//		*Любое другое значение - будет непосредственно помещено во все незаполненные параметры
//		*Строка "#№#№#" (по умолчанию) - во все параметры будет помещён пустой массив
Процедура ЗаполнитьНезаполненныеПараметрыЗапроса(Запрос_, Значения = "#№#№#") Экспорт
	ПоУмолчанию = Новый Массив;
	Если Значения = "#№#№#" Тогда
		Значения = ПоУмолчанию;
		ТипСтр = Ложь;
	Иначе
		ТипЗн = ТипЗнч(Значения);
		ТипСтр = (ТипЗн = Тип("Структура")) ИЛИ (ТипЗн = Тип("ФиксированнаяСтруктура"));
	КонецЕсли;
	ПараметрыТекущегоЗапроса = Запрос_.НайтиПараметры();
	Для каждого ПараметрЗапроса Из ПараметрыТекущегоЗапроса Цикл
		ИмяПараметра =  ПараметрЗапроса.Имя;
		Если НЕ Запрос_.Параметры.Свойство(ИмяПараметра) Тогда
			Запрос_.УстановитьПараметр(ИмяПараметра, ?(ТипСтр, ?(Значения.Свойство(ИмяПараметра), Значения[ИмяПараметра], ?(Значения.Свойство("ОСТАЛЬНЫЕ"), Значения.ОСТАЛЬНЫЕ, ПоУмолчанию)), Значения));
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры // ЗаполнитьНезаполненныеПараметрыЗапроса

// Выполняет запрос, пока не будет соблюдено условие равенства нулю итога по заданной колонке.
// Параметры:
//  Запрос_  - Запрос - Запрос, повторяемый в цикле и готовый к выполнению.
//			Если ТабПараметр - строка, то в запросе д.б. задан МВТ.
//				В этом случае для ускорения  рекомендуется для контроля завершения использовать маленькую таблицу из одной строки, где итоги уже посчитаны запросом,
//				и указать её имя в следующем параметре. В запрос не имеет смысла помещать выборку данных - она не используется внутри функции.
//			Если ТабПараметр - таблица значений, МВТ не нужен, запрос должен содержать выборку данных, выгружающую контрольную таблицу.
//  ТабПараметр  - Строка/Таблица значений - Имя ВТ, выгружаемой для контроля завершения/Таблица, помещаемая в параметр (по ней же производится контроль завершения).
//  ИмяКонтрольнойКолонки  - Строка - Имя контрольной колонки. По умолчанию "НеГотово".  Цикл завершится, когда итог по колонке станет нулевым. 
//  ИмяПараметра  - Строка - Имя параметра, куда помещается таблица. По умолчанию "ТабПараметр". Не используется при работе с временной таблицей.
//  ОграничениеПовтора  - Число - Ограничение проходов цикла во избежание зацикливания. По умолчанию 100.
//Возвращаемое значение
//	Таблица значений	- выгрузка результата запроса/контрольная таблица. Контрольная колонка не удаляется для контроля оверцикла.
Функция ЗапросВЦикле(Запрос_, ТабПараметр = "ТабРезультат", ИмяКонтрольнойКолонки = "НеГотово", ИмяПараметра = "ТабПараметр", ОграничениеПовтора = 100) Экспорт
	ПройденоПовторов = 0;
	ЧерезВТ = ТипЗнч(ТабПараметр) = Тип("Строка");
	ТабКонтроль = ТабПараметр;
	Контроль = ?(ЧерезВТ, 1, ТабКонтроль.Итог(ИмяКонтрольнойКолонки));
	Пока (Контроль <> 0) И (ПройденоПовторов < ОграничениеПовтора) Цикл
		ПройденоПовторов = ПройденоПовторов + 1;
		Если ЧерезВТ Тогда
			Запрос_.Выполнить();
			ТабКонтроль = Запрос_.МенеджерВременныхТаблиц.Таблицы[ТабПараметр].ПолучитьДанные().Выгрузить();
		Иначе
			Запрос_.УстановитьПараметр(ИмяПараметра, ТабКонтроль);
			ТабКонтроль = Запрос_.Выполнить().Выгрузить();
		КонецЕсли;
		Контроль = ТабКонтроль.Итог(ИмяКонтрольнойКолонки);
	КонецЦикла;
	Возврат ТабКонтроль
КонецФункции // ЗапросВЦикле
 
//Выполняет запрос и возвращает значение из первой его ячейки
//Параметры:
//	Запрос_ - Запрос - Готовый к выполнению запрос
//	ЕслиНеНайдено - Произвольный - Значение, возвращаемое, если запрос вернул пустой результат
//Возвращаемое значение:
//	Произвольный - значение из первой ячейки запроса
Функция ПолучитьЕдинственноеЗначениеЗапроса(Запрос_, ЕслиНеНайдено = Неопределено) Экспорт
	ТабХ = Запрос_.Выполнить().Выгрузить();
	Возврат ?(ТабХ.Количество() = 0, ЕслиНеНайдено, ТабХ[0][0])
КонецФункции

//Создаёт запрос с заданным текстом. Удобно для применения в длинных выражениях с точками, где Новый не прокатит
//Параметры:
//	ТекстЗапроса - строка - текст запроса
//	Параметры - структура - параметры запроса (необязательный)
//	МВТ - менеджер временных таблиц - для установки в запрос (необязательный)
//Возвращаемое значение:
//	Запрос - сформированный запрос.
Функция СоздатьЗапрос(ТекстЗапроса_, Параметры = Неопределено, МВТ = Неопределено) Экспорт
	Результат = Новый Запрос(ТекстЗапроса_);
	Если НЕ (Параметры = Неопределено) Тогда
		Для Каждого КиЗ из Параметры Цикл
			Результат.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение)
		КонецЦикла
	КонецЕсли;
	Если НЕ (МВТ = Неопределено) Тогда
		Результат.МенеджерВременныхТаблиц = МВТ
	КонецЕсли;
	Возврат Результат
КонецФункции

// Возвращает по тексту запроса и параметрам запрос или готовый результат
// Параметры:
//  ТекстЗапроса_  - Строка/Запрос - Текст запроса или запрос
//	ОписаниеРезультата - Строка -
//		*Выборка - Выполнить запрос и вернуть выборку
//		*Выгрузка (по умолчанию) - Выполнить запрос и вернуть выгрузку
//		*Выполненный - Выполнить запрос и вернуть его
//		*Запрос - Создать запрос и вернуть без выполнения
//		*Значение - Вернуть первое значение из результата. При отсутствии - NULL.
//		*Массив - Вернуть выгрузку первой колонки
//		*Пакет - Вернуть результат выполнения пакета
//		*Результат - Вернуть результат запроса
//		*СПромежуточными - Вернуть ВыполнитьПакетСПромежуточнымиДанными.
//	Параметры - Структура - Параметры в запрос. Необязательный.
//	МВТ - Менеджер ВТ - для вставки в запрос. По умолчанию Неопределено = Без ВТ
//	ЗагрузитьВТ - Строка - описывает дополнительную загрузку ВТ. ИМена создаваемых ВТ и параметров, из которых ВТ загружаются, будут совпадать.
//		*Загрузить - Создать тексты и фактически загрузить в запрос все таблицы значений из параметров. Текст запроса не менять.
//		*Ничего (по умолчанию) - Не менять текст запроса и не загружать ВТ. Если в тексте запроса уже есть загрузки, они будут выполнены при выпонении запроса в общем порядке.
//		*ТекстВЗапрос - Добавить в начало запроса загрузку ВТ
// Возвращаемое значение:
//   Произвольный - возможные типы:
//		*Запрос - сконструированный запрос
//		*Результат запроса - результат запроса после его выполнения
//		*Выборка из результата запроса - выборка из результата запроса после его выполнения
//		*Таблица значений - выгрузка из результата запроса после его выполнения
//		*Дерево значений - выгрузка из результата запроса после его выполнения
//		*Массив - выгрузка колонки таблицы значений, полученной из результата запроса после его выполнения, либо результат выполнения пакета
//		*Строка - описание ошибки
//		*Прочие значения - как единственное значение, полученное в результате запроса (NULL при пустом результате).
Функция РезультатЗапроса(ТекстЗапроса_, ОписаниеРезультата = "Выгрузка", Параметры = Неопределено, МВТ = Неопределено, ЗагрузитьВТ = "Ничего") Экспорт
	Результат = NULL;
	Попытка
		СформироватьТекстыЗагрузчиков = (ЗагрузитьВТ = "Загрузить") ИЛИ (ЗагрузитьВТ = "ТекстВЗапрос");
		Если ТипЗнч(Параметры) = Тип("Структура") Тогда
			стрПараметров = Параметры;
		Иначе
			стрПараметров = Новый Структура;
		КонецЕсли;
		ТипТЗ = Тип("ТаблицаЗначений");
		Запрос_ = ?(ТипЗнч(ТекстЗапроса_) = Тип("Запрос"), ТекстЗапроса_, Новый Запрос(ТекстЗапроса_));
		Если МВТ <> Неопределено Тогда
			Запрос_.МенеджерВременныхТаблиц = МВТ;
		КонецЕсли;
		ТекстПредварительногоЗапроса = "";
		Для каждого КиЗ Из стрПараметров Цикл
			Если СформироватьТекстыЗагрузчиков И (ТипЗнч(КиЗ.Значение) = ТипТЗ) Тогда
				ТекстПредварительногоЗапроса = ТекстПредварительногоЗапроса + ТаблицуЗначенийВоВременнуюТаблицуТекст(КиЗ.Значение, КиЗ.Ключ,,, КиЗ.Ключ);
			КонецЕсли;
			Запрос_.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение);
		КонецЦикла;
		Если ЗагрузитьВТ = "Загрузить" Тогда
			Стек = Запрос_.Текст;
			Запрос_.Текст = ТекстПредварительногоЗапроса;
			Запрос_.Выполнить();
			Запрос_.Текст = Стек;
		ИначеЕсли ЗагрузитьВТ = "ТекстВЗапрос" Тогда
			Запрос_.Текст = ТекстПредварительногоЗапроса + Запрос_.Текст;
		КонецЕсли;
		Если ОписаниеРезультата = "Запрос" Тогда
			Результат = Запрос_;
		Иначе
			Результат = Запрос_.Выполнить();
			Если ОписаниеРезультата = "Выборка" Тогда
				Результат = Результат.Выбрать();
			ИначеЕсли ОписаниеРезультата = "Выполненный" Тогда
				Результат = Запрос_;
			ИначеЕсли ОписаниеРезультата = "Пакет" Тогда
				Результат = Запрос_.ВыполнитьПакет();
			ИначеЕсли ОписаниеРезультата = "Результат" Тогда
			ИначеЕсли ОписаниеРезультата = "СПромежуточными" Тогда
				Результат = Запрос_.ВыполнитьПакетСПромежуточнымиДанными();
			Иначе
				Результат = Результат.Выгрузить();
				Если ОписаниеРезультата = "Значение" Тогда
					Если Результат.Количество() Тогда
						Результат = Результат[0][0];
					Иначе
						Результат = NULL;
					КонецЕсли;
				ИначеЕсли ОписаниеРезультата = "Массив" Тогда
					Результат = Результат.ВыгрузитьКолонку(Результат.Колонки[0].Имя);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Исключение
		ООШ = ОписаниеОшибки();
		Результат = "#ОШИБКА: " + ООШ;
	КонецПопытки;
	Возврат Результат
КонецФункции // РезультатЗапроса

//Помещает таблицу значений во временную таблицу
//	Таблица = таблица значений
//	Менеджер = менеджер временных таблиц. Сюда и попадает таблица.
//	ИмяВТ = строка, имя временной таблицы
//	Выразить = Типизировать в запросе колонки таблицы
Процедура ТаблицуЗначенийВоВременнуюТаблицу(Таблица, Менеджер, ИмяВТ, Выразить = Ложь) Экспорт
	ТекстЗапроса = ТаблицуЗначенийВоВременнуюТаблицуТекст(Таблица, ИмяВТ, Выразить, Ложь);
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = Менеджер;
	Запрос.УстановитьПараметр("ТабПараметр", Таблица);
	Запрос.Выполнить()
КонецПроцедуры

//Возвращает текст запроса, размещающего таблицу значений во временную таблицу
//Параметры:
//	Таблица - таблица значений - источник данных.
//	Выразить - Булево - Типизировать в запросе колонки таблицы. По умолчанию Ложь.
//	ИмяВТ - строка - имя временной таблицы, куда будет загружена таблица
//	ВПакете - Булево - добавляет разделитель для вставки в пакет запросов, по умолчанию Истина
//	ИмяПараметра - Строка - Имя параметра, куда будет помещена таблица
//Возвращаемое значение:
//	Строка - Текст запроса, помещающего таблицу значений во временную таблицу.
Функция ТаблицуЗначенийВоВременнуюТаблицуТекст(Таблица, ИмяВТ, Выразить = Ложь, ВПакете = Истина, ИмяПараметра = "ТабПараметр") Экспорт
	ТекстЗапроса = "";
	Для каждого Колонка из Таблица.Колонки Цикл
		ТекстЗапроса = ТекстЗапроса + "," + Символы.ПС + ?(Выразить, "	ВЫРАЗИТЬ(Таб." + Колонка.Имя + " КАК " +
				ТипДляЗапроса(ВОЛНА_ОбщегоНазначения_КлиентСервер.ОписаниеТиповКоллекции(Таблица.ВыгрузитьКолонку(Колонка))) + ") КАК ",
				"	Таб.") + Колонка.Имя
	КонецЦикла;
	Возврат "ВЫБРАТЬ" + Сред(ТекстЗапроса, 2) + Символы.ПС + "ПОМЕСТИТЬ " + ИмяВТ + Символы.ПС + "ИЗ" +
			Символы.ПС + "	&ТабПараметр КАК Таб" + ?(ВПакете, ВОЛНА_ОбщегоНазначения_КлиентСервер.РазделительЗапросов(), "")
КонецФункции

//Возвращает строку - имя типа в виде, подходящем для запроса. Если тип - сложный, возвращается описание первого.
//Параметры:
//	ОписаниеТипа - описание типа,  по которому надо получить полное имя метаданных
//Возвращаемое значение:
//	Строка - Полное имя метаданных, пригодное для запроса
Функция ТипДляЗапроса(ОписаниеТипа) Экспорт
	Если ТипЗнч(ОписаниеТипа) = Тип("ОписаниеТипов") Тогда
		Описание = ОписаниеТипа;
		Тип_ = ОписаниеТипа.Типы()[0];
		Если Тип_ = Тип("Строка") Тогда
			Возврат "СТРОКА(" + ОписаниеТипа.КвалификаторыСтроки.Длина + ")"
		ИначеЕсли Тип_ = Тип("Число") Тогда
			Возврат "ЧИСЛО(" + ОписаниеТипа.КвалификаторыЧисла.Разрядность + ", " + ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти + ")"
		КонецЕсли
	ИначеЕсли ТипЗнч(ОписаниеТипа) = Тип("Тип") Тогда
		МТипов = Новый Массив;
		МТипов.Добавить(ОписаниеТипа);
		Описание = Новый ОписаниеТипов(МТипов)
	Иначе
		Возврат Строка(ОписаниеТипа)
	КонецЕсли;
	Попытка
		Возврат Описание.ПривестиЗначение(0).Метаданные().ПолноеИмя()
	Исключение
		Возврат СокрЛП(ОписаниеТипа)
	КонецПопытки
КонецФункции

#КонецОбласти

#Область ССЫЛКИ_УИДЫ
	
#Область ЗАМЕНА_ССЫЛОК

//Вспомогательная для функций замены. Выводит сообщение об ошибке.
//Параметры:
//	Информация - Соответствие - с ключом Описание или Причина.Описание
//	Контекст - Произвольный - Дополнение для вывода после описания причины.
Процедура СообщитьОбОшибкеПриЗаписи(Информация, Контекст)
	Причина = ?(Информация.Причина = Неопределено, Информация, Информация.Причина);
	Сообщить(Причина.Описание + Контекст, СтатусСообщения.Важное);
КонецПроцедуры

//Вспомогательная для следующей экспортной процедуры. Выполняет разовую замену.
//Параметры:
//	ГдеМенять - Произвольный, поддерживающий изменяемые реквизиты - Объект, в котором будет произведена замена
//	Реквизит - Строка - Имя реквизита, в котором будет произведена замена
//	Замены - [Фиксированное] соответствие - Соответствие правильных значений (значения) заменяемым (ключи)
//	Лог - Строка - Комментарий о проделанной работе. По умолчанию "-" - не комментировать
//Возвращаемое значение:
//	Произвольный - значение после замены
Функция ЗаменитьСсылку(ГдеМенять, Реквизит, Замены, Лог = "-")
	ТекЗнч = ГдеМенять[Реквизит];
	ПравильныйЭлемент = Замены[ТекЗнч];
	Если ПравильныйЭлемент <> Неопределено Тогда
		ГдеМенять[Реквизит] = ПравильныйЭлемент;
		Если Лог <> "" Тогда
			Попытка
				ГдеМенятьСтрокой = "" + ГдеМенять;
			Исключение
				ГдеМенятьСтрокой = "" + ТипЗнч(ГдеМенять);
			КонецПопытки;
			Лог = Лог + "В " + Реквизит + " объекта " + ГдеМенятьСтрокой + " " + ТекЗнч + " заменён на " + ПравильныйЭлемент;
		КонецЕсли; 
	КонецЕсли;
	Возврат ПравильныйЭлемент
КонецФункции // ЗаменитьСсылку()
 
//Заменяет значения по таблице замен и помечает на удаление заменяемые значения.
//Параметры:
//	ЗаменяемыеЗначения - Таблица значений - с колонками ЧтоЗаменять, НаЧтоЗаменять, Пометка (флаг необходимости замены) и ПометитьНаУдаление.
//	НайденныеСсылки - Таблица значений - с колонками "Данные" (изменяемые объекты), "Ссылка" (Заменяемые значения)
//										и "Включено" (булево, обрабатывать строку), см. НайтиСсылкиПоМассиву
//	ВТранзакции - Булево - Выполнять в единой транзакции все замены.
//	БезКонтроля - Булево - Включает режим записи "Загрузка", отменяющий многие контроли при записи и ускоряющий её.
//	ОтменитьРегистрациюВОбменах - Булево - Устанавливает у объектов допсвойство, в типовых конфигурациях блокирующее регистрацию в планах обмена.
//	Лог				-	Строка	-	отчёт о проделанной работе. Дополняется в ходе процедеуры. По умолчанию "-" - не комментировать.
//Возвращаемое значение:
//	Булево - Замена завершена без ошибок
Функция ЗаменитьСсылкиПоТаблицеИПометитьНаУдаление(ЗаменяемыеЗначения, НайденныеСсылки, ВТранзакции = Истина, БезКонтроля = Ложь, ОтменитьРегистрациюВОбменах = Истина, Лог = "-") Экспорт
	Заменяемые = Новый Соответствие;
	Для каждого Стр Из ЗаменяемыеЗначения Цикл
		Если Стр.Пометка Тогда
			Заменяемые.Вставить(Стр.ЧтоЗаменять, Стр.НаЧтоЗаменять);
		КонецЕсли;
	КонецЦикла;
	БезОшибок = ЗаменитьСсылкиПоСоответствию(Заменяемые, НайденныеСсылки, ВТранзакции, БезКонтроля, ОтменитьРегистрациюВОбменах, Лог);
	Для каждого Стр Из ЗаменяемыеЗначения Цикл
		Если Стр.ПометитьНаУдаление Тогда
			Объект_ = Стр.ЧтоЗаменять.ПолучитьОбъект();
			Если НЕ Объект_.ПометкаУдаления Тогда
				Объект_.ПометкаУдаления = Истина;
				Объект_.ОбменДанными.Загрузка = БезКонтроля;
				Попытка
					Объект_.Записать();
					Если Лог <> "-" Тогда
						Лог = Лог + "Помечен на удаление " + Объект_;
					КонецЕсли; 
				Исключение
					СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при пометке на удаление)");
					БезОшибок = Ложь;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат БезОшибок
КонецФункции // ЗаменитьСсылкиПоТаблицеИПометитьНаУдаление()

//Заменяет ссылки из таблицы по заданным соответствиям
//Параметры:
//	Заменяемые		-	Соответствие		-	Ключ - заменяемое, Значение - замещающее значение
//	ТаблицаСсылок		-	Таблица значений	-	с колонками "Данные" (изменяемые объекты), "Ссылка" (Заменяемые значения)
//										и "Включено" (булево, обрабатывать строку), см. НайтиСсылкиПоМассиву
//	ВыполнятьВТранзакции			-	Булево	-	Если Истина (по умолчанию), то одна общая транзакция,
//										Ложь - транзакции по каждому объекту данных.
//										Истина - быстрее и сохраняет целостность, Ложь - помехоустойчивей и надёжнее.
//	ОтключатьКонтрольЗаписи		-	Булево	-	Записывать в режиме загрузки. По умолчанию Истина.
//	ОтменитьРегистрациюВОбменах	-	Булево	-	Записывать без регистрации в обменах данных. По умолчанию Истина.
//	Лог				-	Строка	-	отчёт о проделанной работе. Дополняется в ходе процедеуры. По умолчанию "-" - не комментировать.
//Возвращаемое значение:
//	Булево - Замены выполнены без ошибок
Функция ЗаменитьСсылкиПоСоответствию(Заменяемые, ТаблицаСсылок, ВыполнятьВТранзакции = Истина, ОтключатьКонтрольЗаписи = Истина, ОтменитьРегистрациюВОбменах = Истина, Лог = "-") Экспорт
	МетаВсё = Метаданные;
	МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
	Непериод = МетаСвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
	ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
	РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
	АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	БылиИсключения = Ложь;
	МетаРБ = МетаВсё.РегистрыБухгалтерии;
	МетаРС = МетаВсё.РегистрыСведений;
	МетаРР = МетаВсё.РегистрыРасчета;
	МетаРН = МетаВсё.РегистрыНакопления;
	МетаСпр = МетаВсё.Справочники;
	МетаДок = МетаВсё.Документы;
	МетаПВХ = МетаВсё.ПланыВидовХарактеристик;
	МетаПВР = МетаВсё.ПланыВидовРасчета;
	МетаПСЧ = МетаВсё.ПланыСчетов;
	МетаПОБ = МетаВсё.ПланыОбмена;
	МетаБПР = МетаВсё.БизнесПроцессы;
	МетаЗад = МетаВсё.Задачи;
	МетаКон = МетаВсё.Константы;
	МетаПос = МетаВсё.Последовательности;
	МетаОРе = МетаВсё.ОбщиеРеквизиты;
	Если ВыполнятьВТранзакции Тогда
		НачатьТранзакцию();
	КонецЕсли;
	ОбрабатываемаяСсылка = Неопределено;
	ПараметрыХ = Новый Структура;
	Для Каждого РегистрБухгалтерии ИЗ МетаРБ Цикл
		ПараметрыХ.Вставить(РегистрБухгалтерии.Имя + "Субконто", РегистрБухгалтерии.ПланСчетов.МаксКоличествоСубконто);
		ПараметрыХ.Вставить(РегистрБухгалтерии.Имя + "Корреспонденция", РегистрБухгалтерии.Корреспонденция);		
	КонецЦикла;
	//ПараметрыХ.Вставить("Объект", Неопределено);	
	ТабЗамен = ТаблицаСсылок.Скопировать(ТаблицаССылок.НайтиСтроки(Новый Структура("Включено", Истина)), "Данные,Ссылка");
	ТабЗамен.Свернуть("Данные,Ссылка");
	ТабЗамен.Сортировать("Данные,Ссылка");
	ТабЗамен.Индексы.Добавить("Данные,Ссылка");
	ТабДанных = ТабЗамен.Скопировать(,"Данные");
	ТабДанных.Свернуть("Данные");
	ИнфоМД = Новый Соответствие;
	ИнфоОР = Новый Соответствие;
	Данных = ТабДанных.Количество();
	Сч = 0;
	Для каждого СтрокаДанных Из ТабДанных Цикл
		Если Лог <> "-" Тогда
			Сч = Сч + 1;
			Лог = Лог + "Строка " + Сч + " из " + Данных;
		КонецЕсли; 
		Замены = ТабЗамен.НайтиСтроки(Новый Структура("Данные", СтрокаДанных.Данные));
		//Построить соответствие замен для конкретных данных
		ТекЗамены = Новый Соответствие;
		Для каждого СтрокаЗамен Из Замены Цикл
			ТекЗамены.Вставить(СтрокаЗамен.Ссылка, Заменяемые[СтрокаЗамен.Ссылка]);
		КонецЦикла;
		//И перебор по реквизитам данных
		СтроковыйТип = СтрЗаменить(СтрокаДанных.Данные, ".", Символы.ПС);
		МетаХ = ?(СтрПолучитьСтроку(СтроковыйТип, 1) = "РегистрСведенийКлючЗаписи",
				МетаРС.Найти(СтрПолучитьСтроку(СтроковыйТип, 2)), СтрокаДанных.Данные.Метаданные());
		ИнфоЭтиМД = ИнфоМД[МетаХ];
		Если ИнфоЭтиМД = Неопределено Тогда
			ИнфоЭтиМД = Новый Структура;
			ИнфоЭтиМД.Вставить("ЭтоСпр",  МетаСпр.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоДок",  МетаДок.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоБПлан",  МетаПВХ.Содержит(МетаХ)
					  ИЛИ МетаПСЧ.Содержит(МетаХ)
					  ИЛИ МетаПВР.Содержит(МетаХ)
					  ИЛИ МетаБПР.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоЗадача",  МетаЗад.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоРС",  МетаРС.Содержит(МетаХ));
			ИнфоЭтиМД.Вставить("ЭтоКонст",  МетаКон.Содержит(МетаХ));
			ИнфоПослед = Новый Соответствие;
			ИнфоЭтиМД.Вставить("Послед", ИнфоПослед);
			ИнфоЭтиМД.Вставить("Движения", Новый Соответствие);
		Иначе
			ИнфоПослед = ИнфоЭтиМД.Послед;
		КонецЕсли; 
		Если ИнфоЭтиМД.ЭтоКонст Тогда
			Константы[МетаХ.Имя].Установить(Заменяемые[ТекЗамены[0].Ссылка]);
		ИначеЕсли ИнфоЭтиМД.ЭтоРС Тогда
			СтруктураИзмерений = Новый Структура;
			НаборЗаписей = РегистрыСведений[МетаХ.Имя].СоздатьНаборЗаписей();
			Для Каждого Измерение ИЗ МетаХ.Измерения Цикл
				НаборЗаписей.Отбор[Измерение.Имя].Установить(СтрокаДанных.Данные[Измерение.Имя]);
				СтруктураИзмерений.Вставить(Измерение.Имя);
			КонецЦикла;
			Если МетаХ.ПериодичностьРегистраСведений <> Непериод Тогда
				НаборЗаписей.Отбор["Период"].Установить(СтрокаДанных.Данные.Период);
			КонецЕсли;
			НаборЗаписей.Прочитать();
			Если НаборЗаписей.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			ТаблицаНабора = НаборЗаписей.Выгрузить();
			НаборЗаписей.Очистить();
			Если ОтключатьКонтрольЗаписи Тогда
				НаборЗаписей.ОбменДанными.Загрузка = Истина;
			КонецЕсли;
			Если Не ВыполнятьВТранзакции Тогда
				НачатьТранзакцию();
			КонецЕсли;
			Попытка
				НаборЗаписей.Записать();
				Для каждого СтрокаНабора Из ТаблицаНабора Цикл
					Для Каждого Колонка ИЗ ТаблицаНабора.Колонки Цикл
						ПравильныйЭЛемент = ЗаменитьСсылку(СтрокаНабора, Колонка.Имя, ТекЗамены, Лог);
						Если СтруктураИзмерений.Свойство(Колонка.Имя) И (ПравильныйЭЛемент <> Неопределено) Тогда
							НаборЗаписей.Отбор[Колонка.Имя].Установить(ПравильныйЭЛемент);
						КонецЕсли;
					КонецЦикла; 
				КонецЦикла;
				НаборЗаписей.Загрузить(ТаблицаНабора);
				НаборЗаписей.Записать();
				Если Не ВыполнятьВТранзакции Тогда
					ЗафиксироватьТранзакцию();
				КонецЕсли; 
			Исключение
				СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при записи регистра сведений)");
				БылиИсключения = Истина;
				Если ВыполнятьВТранзакции Тогда
					Прервать; //На откат
				Иначе
					ОтменитьТранзакцию();
				КонецЕсли;
			КонецПопытки;
		ИначеЕсли ИнфоЭтиМД.ЭтоСпр ИЛИ ИнфоЭтиМД.ЭтоДок ИЛИ ИнфоЭтиМД.ЭтоБПлан ИЛИ ИнфоЭтиМД.ЭтоЗадача Тогда
			ИсключенияВДанных = Ложь;
			Попытка
				ТекОбъект = СтрокаДанных.Данные.ПолучитьОбъект();
				Если ОтменитьРегистрациюВОбменах Тогда
					ТекОбъект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
				КонецЕсли; 
				//Для каждого Замена Из Заменяемые Цикл //ТекЗамены Цикл
				//	Ссылка = Замена.Ключ;
				//	ПравильныйЭлемент = Замена.Значение;
				Если ИнфоЭтиМД.ЭтоСпр Тогда //А здесь 80000
					//Если МетаХ.Владельцы.Содержит(Ссылка.Метаданные()) И ТекОбъект.Владелец = Ссылка Тогда
					ЗаменитьСсылку(ТекОбъект, "Владелец", ТекЗамены, Лог);
					Если МетаХ.Иерархический Тогда
						ЗаменитьСсылку(ТекОбъект, "Родитель", ТекЗамены, Лог);
					КонецЕсли;
				КонецЕсли;
				Для Каждого Реквизит Из МетаОРе Цикл //Замедляет, часто запускается! 300 тыс раз при 2000 данных и 3000 пар замен!
					Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
						ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
					КонецЕсли; 
				КонецЦикла;
				Для Каждого Реквизит Из МетаХ.Реквизиты Цикл
					//Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда //2,7 млн, 5%
					ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
				КонецЦикла;
				Для Каждого ТЧ ИЗ МетаХ.ТабличныеЧасти Цикл
					Если ТекОбъект[ТЧ.Имя].Количество() < 200 Тогда
						//Маленькие ТЧ проще перебрать, избавившись от проверок типов и доп. цикла
						Для каждого Строка_ТЧ_ Из ТекОбъект[ТЧ.Имя] Цикл
							Для Каждого Реквизит Из ТЧ.Реквизиты Цикл
								ЗаменитьСсылку(Строка_ТЧ_, Реквизит.Имя, ТекЗамены, Лог);
							КонецЦикла; 
						КонецЦикла;
					Иначе
						//В больших ТЧ лучше ограничить число колонок
						Для каждого КиЗ Из ТекЗамены Цикл
							ПравильныйЭлемент = КиЗ.Значение;
							Ссылка = КиЗ.Ключ;
							ТипСсылки = ТипЗнч(Ссылка);
							Для Каждого Реквизит Из ТЧ.Реквизиты Цикл //5 млн 7%
								Если Реквизит.Тип.СодержитТип(ТипСсылки) Тогда //10 млн, 10%
									СтрокаТабЧасти = ТекОбъект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
									Пока СтрокаТабЧасти <> Неопределено Цикл
										СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
										СтрокаТабЧасти = ТекОбъект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
									КонецЦикла;
								КонецЕсли; //2%
							КонецЦикла;
						КонецЦикла; 
					КонецЕсли;
				КонецЦикла;
				Если ИнфоЭтиМД.ЭтоЗадача Тогда
					Для Каждого Реквизит Из МетаХ.РеквизитыАдресации Цикл
						//Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ТекОбъект[Реквизит.Имя] = Ссылка Тогда
						ЗаменитьСсылку(ТекОбъект, Реквизит.Имя, ТекЗамены, Лог);
					КонецЦикла;
				КонецЕсли;
			Исключение
				СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при заполнении реквизитов объекта)");
				БылиИсключения = Истина;
				Если ВыполнятьВТранзакции Тогда
					Прервать; //На откат
				Иначе
					ИсключенияВДанных = Истина;
				КонецЕсли;
			КонецПопытки;
			Если НЕ ИсключенияВДанных Тогда
				КЗаписи = Новый Массив;
				Попытка
					Если ИнфоЭтиМД.ЭтоДок Тогда
						Для Каждого Движение ИЗ МетаХ.Движения Цикл
							ТекВидДвиж = ИнфоЭтиМД.Движения[Движение];
							Если ТекВидДвиж = Неопределено Тогда
								Если МетаРС.Содержит(Движение) Тогда
									ЭтоДвижениеРегистраБухгалтерии = Ложь;
									ЭтоДвижениеРегистраРасчета = Ложь;
									ЭтоДвижениеРегистраСведений = Истина;
									ТекВидДвиж = "РС";
								ИначеЕсли МетаРН.Содержит(Движение) Тогда
									ЭтоДвижениеРегистраБухгалтерии = Ложь;
									ЭтоДвижениеРегистраРасчета = Ложь;
									ЭтоДвижениеРегистраСведений = Ложь;
									ТекВидДвиж = "РН";
								ИначеЕсли МетаРБ.Содержит(Движение) Тогда
									ЭтоДвижениеРегистраБухгалтерии = Истина;
									ЭтоДвижениеРегистраРасчета = Ложь;
									ЭтоДвижениеРегистраСведений = Ложь;
									ТекВидДвиж = "РБ";
								Иначе
									ЭтоДвижениеРегистраБухгалтерии = Ложь;
									ЭтоДвижениеРегистраРасчета = Истина;
									ЭтоДвижениеРегистраСведений = Ложь;
									ТекВидДвиж = "РР";
								КонецЕсли; 
								ИнфоЭтиМД.Движения.Вставить(Движение, ТекВидДвиж);
							Иначе
								ЭтоДвижениеРегистраБухгалтерии = ТекВидДвиж = "РБ";
								ЭтоДвижениеРегистраРасчета = ТекВидДвиж = "РР";
								ЭтоДвижениеРегистраСведений = ТекВидДвиж = "РС";
							КонецЕсли;
							ЕстьКорреспонденция = ЭтоДвижениеРегистраБухгалтерии и ПараметрыХ[Движение.Имя + "Корреспонденция"];
							НаборЗаписей  = ТекОбъект.Движения[Движение.Имя];
							НаборЗаписей.Прочитать(); //1698 запусков 4%
							НадоЗаписывать = Ложь;
							ТаблицаНабора = НаборЗаписей.Выгрузить();
							ТеККолво = ТаблицаНабора.Количество();
							Если ТеККолво = 0 Тогда
								Продолжить;
							ИначеЕсли ТекКолво < 200 Тогда
								Для каждого ТекЗапись Из ТаблицаНабора Цикл
									Для Каждого Измерение ИЗ Движение.Измерения Цикл
										Если ЕстьКорреспонденция И НЕ Измерение.Балансовый Тогда // (Измерение.ПризнакУчета <> Неопределено) Тогда
											ИмяРекв = Измерение.Имя + "Дт";
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
											ИмяРекв = Измерение.Имя + "Кт";
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										Иначе
											ИмяРекв = Измерение.Имя;
											Если ЗаменитьСсылку(ТекЗапись, ИмяРекв, ТекЗамены, Лог) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										КонецЕсли;
									КонецЦикла;
									// Получим имена ресурсов, которые могут содержать ссылку
									Если ЭтоДвижениеРегистраСведений Тогда
										Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
											//Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											Если ЗаменитьСсылку(ТекЗапись, Ресурс.Имя, ТекЗамены, Лог) <> Неопределено Тогда
												НадоЗаписывать = Истина;
											КонецЕсли;	
										КонецЦикла;
									КонецЕсли;
									// Получим имена ресурсов, которые могут содержать ссылку
									Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
										Если ЗаменитьСсылку(ТекЗапись, Реквизит.Имя, ТекЗамены, Лог) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
									КонецЦикла;
									Если ЭтоДвижениеРегистраБухгалтерии Тогда
										Для ИндексСубконто = 1 по ПараметрыХ[Движение.Имя + "Субконто"] Цикл
											Если ЕстьКорреспонденция Тогда
												СубДт = "СубконтоДт" + ИндексСубконто;
												СубКт = "СубконтоКт" + ИндексСубконто;
												Если ЗаменитьСсылку(ТекЗапись, СубДт, ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
												Если ЗаменитьСсылку(ТекЗапись, СубКт, ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											Иначе							
												СубКт = "Субконто" + ИндексСубконто;
												Если ЗаменитьСсылку(ТекЗапись, СубКт, ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											КонецЕсли;						
										КонецЦикла;
										//Если Ссылка.Метаданные() = Движение.ПланСчетов Тогда
											Если ЕстьКорреспонденция Тогда
												Если ЗаменитьСсылку(ТекЗапись, "СчетДт", ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
												Если ЗаменитьСсылку(ТекЗапись, "СчетКт", ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											Иначе
												Если ЗаменитьСсылку(ТекЗапись, "Счет", ТекЗамены, Лог) <> Неопределено Тогда
													НадоЗаписывать = Истина;
												КонецЕсли;	
											КонецЕсли;
										//КонецЕсли;
									КонецЕсли;
									Если ЭтоДвижениеРегистраРасчета Тогда
										Если ЗаменитьСсылку(ТекЗапись, "ВидРасчета", ТекЗамены, Лог) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
									КонецЕсли;
								КонецЦикла; 
							Иначе
								Для каждого КиЗ Из ТекЗамены Цикл
									ПравильныйЭлемент = КиЗ.Значение;
									Ссылка = КиЗ.Ключ;
									масИменКолонок = Новый Массив;
									// Получим имена измерений, которые могут содержать ссылку
									Для Каждого Измерение ИЗ Движение.Измерения Цикл
										Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											Если ЕстьКорреспонденция И (Измерение.ПризнакУчета <> Неопределено) Тогда
												масИменКолонок.Добавить(Измерение.Имя + "Дт");
												масИменКолонок.Добавить(Измерение.Имя + "Кт");
											Иначе
												масИменКолонок.Добавить(Измерение.Имя);
											КонецЕсли;
										КонецЕсли;
									КонецЦикла;
									// Получим имена ресурсов, которые могут содержать ссылку
									Если ЭтоДвижениеРегистраСведений Тогда
										Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
											Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
												масИменКолонок.Добавить(Ресурс.Имя);
											КонецЕсли;
										КонецЦикла;
									КонецЕсли;
									// Получим имена ресурсов, которые могут содержать ссылку
									Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
										Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
											масИменКолонок.Добавить(Реквизит.Имя);
										КонецЕсли;
									КонецЦикла;
									// Произведем замены в таблице
									Для Каждого ИмяКолонки Из масИменКолонок Цикл //4 млн 3%
										СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, ИмяКолонки); //3,7 млн, 8%
										Пока СтрокаТабЧасти <> Неопределено Цикл //3,7 млн 2%
											СтрокаТабЧасти[ИмяКолонки] = ПравильныйЭлемент;
											НадоЗаписывать = Истина;
											СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, ИмяКолонки);
										КонецЦикла;
									КонецЦикла;
									Если ЭтоДвижениеРегистраБухгалтерии Тогда
										Для ИндексСубконто = 1 по ПараметрыХ[Движение.Имя + "Субконто"] Цикл
											Если ЕстьКорреспонденция Тогда
												СубДт = "СубконтоДт" + ИндексСубконто;
												СубКт = "СубконтоКт" + ИндексСубконто;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубДт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												КонецЦикла;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубКт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубКт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубКт);
												КонецЦикла;								
											Иначе							
												СубДт = "Субконто" + ИндексСубконто;
												СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												Пока СтрокаТабЧасти <> Неопределено Цикл
													СтрокаТабЧасти[СубДт] = ПравильныйЭлемент;
													НадоЗаписывать = Истина;
													СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, СубДт);
												КонецЦикла;							
											КонецЕсли;						
										КонецЦикла;
										Если Ссылка.Метаданные() = Движение.ПланСчетов Тогда
											Для Каждого СтрокаТабЧасти Из ТаблицаНабора Цикл
												Если ЕстьКорреспонденция Тогда
													Если СтрокаТабЧасти.СчетДт = Ссылка Тогда
														СтрокаТабЧасти.СчетДт = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
													Если СтрокаТабЧасти.СчетКт = Ссылка Тогда
														СтрокаТабЧасти.СчетКт = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
												Иначе
													Если СтрокаТабЧасти.Счет = Ссылка Тогда
														СтрокаТабЧасти.Счет = ПравильныйЭлемент;
														НадоЗаписывать = Истина;
													КонецЕсли;
												КонецЕсли;
											КонецЦикла;
										КонецЕсли;
									КонецЕсли;
									Если ЭтоДвижениеРегистраРасчета Тогда //2% 600000
										СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "ВидРасчета");
										Пока СтрокаТабЧасти <> Неопределено Цикл
											СтрокаТабЧасти["ВидРасчета"] = ПравильныйЭлемент;
											НадоЗаписывать = Истина;
											СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "ВидРасчета");
										КонецЦикла;
									КонецЕсли;
								КонецЦикла; 
							КонецЕсли;
							Если НадоЗаписывать Тогда
								НаборЗаписей.Загрузить(ТаблицаНабора);
								Если ОтключатьКонтрольЗаписи Тогда
									НаборЗаписей.ОбменДанными.Загрузка = Истина;
								КонецЕсли;
								КЗаписи.Добавить(НаборЗаписей);
								//НаборЗаписей.Записать();
							КонецЕсли;
						КонецЦикла;
						Для Каждого Последовательность ИЗ МетаПос Цикл
							//Последовательностей мало, а по уму тоже надо в массив выностить
							ТекПослед = ИнфоПослед[Последовательность];
							Если ТекПослед = Неопределено Тогда
								ТекПослед = Последовательность.Документы.Содержит(МетаХ);
								ИнфоПослед.Вставить(Последовательность, ТекПослед);
								НадоЗаписывать = Ложь;
								НаборЗаписи = Последовательности[Последовательность.Имя].СоздатьНаборЗаписей();
								НаборЗаписи.Отбор.Регистратор.Установить(СтрокаДанных.Данные);
								НаборЗаписи.Прочитать();
								Если НаборЗаписи.Количество() > 0 Тогда
									Для Каждого Измерение ИЗ Последовательность.Измерения Цикл
										Если ЗаменитьСсылку(НаборЗаписи[0], Измерение.Имя, ТекЗамены, Лог) <> Неопределено Тогда
											НадоЗаписывать = Истина;
										КонецЕсли;	
										//Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) И НаборЗаписи[0][Измерение.Имя]=Ссылка Тогда
										Если НадоЗаписывать Тогда
											Если ОтключатьКонтрольЗаписи Тогда
												НаборЗаписи.ОбменДанными.Загрузка = Истина;
											КонецЕсли;
											КЗаписи.Добавить(НаборЗаписей);
											//НаборЗаписи.Записать();
										КонецЕсли;
									КонецЦикла; 
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли; 
				Исключение	
					СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при заполнении реквизитов движений)");
					БылиИсключения = Истина;
					Если ВыполнятьВТранзакции Тогда
						Прервать; //На откат
					Иначе
						ИсключенияВДанных = Истина;
					КонецЕсли;
				КонецПопытки;
				Если НЕ ИсключенияВДанных Тогда
					Если ОтключатьКонтрольЗаписи Тогда
						ТекОбъект.ОбменДанными.Загрузка = Истина;
					КонецЕсли;
					Если Не ВыполнятьВТранзакции Тогда
						НачатьТранзакцию();
					КонецЕсли;
					Попытка
						Для каждого ТекЗапись Из КЗаписи Цикл
							ТекЗапись.Записать();
						КонецЦикла; 
						ТекОбъект.Записать();
						Если Не ВыполнятьВТранзакции Тогда
							ЗафиксироватьТранзакцию();
						КонецЕсли; 
					Исключение
						СообщитьОбОшибкеПриЗаписи(ИнформацияОбОшибке(), " (при записи движений или объекта)");
						БылиИсключения = Истина;
						Если ВыполнятьВТранзакции Тогда
							Прервать; //На откат
						Иначе
							ОтменитьТранзакцию();
						КонецЕсли;
					КонецПопытки;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Сообщить("Ссылки типа " + МетаХ + " не заменяются!!");
		КонецЕсли; 
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя(); //Надо (А надо ли?) реализовать с переходом на сервер
		#КонецЕсли
	КонецЦикла;
	Если ВыполнятьВТранзакции Тогда
		Если БылиИсключения Тогда
			ОтменитьТранзакцию();
		Иначе
			ЗафиксироватьТранзакцию();
		КонецЕсли;	
	КонецЕсли;
	Возврат Не БылиИсключения;
КонецФункции //ЗаменитьСсылкиПоСоответствию

#КонецОбласти 

//Возвращает ссылку по строке УИД
//Параметры:
//	УУИД - Строка - 36 значный УИД
//	НайтиВсе - Булево - Найти все ссылки и вернуть массив. При Ложь будет возвращена первая найденная.
//Возвращаемое значение:
//	Массив/Ссылка/Неопределено - Если НайтиВсе - будет массив, иначеесли найдена ссылка - найденная ссылка, если не найдено ничего - неопределено.
Функция UUIDToСсылка(УУИД, НайтиВсе = Ложь) Экспорт
	Результат = Новый Массив;
	ГдеИщем = Новый Соответствие;
	ГдеИщем.Вставить(Справочники, Метаданные.Справочники);
	ГдеИщем.Вставить(Документы, Метаданные.Документы);
	ГдеИщем.Вставить(ПланыВидовХарактеристик, Метаданные.ПланыВидовХарактеристик);
	ГдеИщем.Вставить(ПланыСчетов, Метаданные.ПланыСчетов);
	ГдеИщем.Вставить(ПланыВидовРасчета, Метаданные.ПланыВидовРасчета);
	ГдеИщем.Вставить(БизнесПроцессы, Метаданные.БизнесПроцессы);
	ГдеИщем.Вставить(Задачи, Метаданные.Задачи);
	ГдеИщем.Вставить(ПланыОбмена, Метаданные.ПланыОбмена);
	НУИД = Новый УникальныйИдентификатор(УУИД);
	Для Каждого ВидМетаданных Из ГдеИщем Цикл
		Для каждого л_Менеджер из ВидМетаданных.Значение Цикл
			л_Ссылка = ВидМетаданных.Ключ[л_Менеджер.Имя].ПолучитьСсылку(НУИД);
			//Элементы.ГруппаСсылки.Заголовок = ТипЗнч(л_Ссылка);
			Если л_Ссылка.ПолучитьОбъект() <> Неопределено Тогда
				Если НайтиВсе Тогда
					Результат.Добавить(л_Ссылка);
				Иначе
					Возврат л_Ссылка
				КонецЕсли; 
			КонецЕсли
		КонецЦикла
	КонецЦикла;
	Возврат ?(НайтиВсе, Результат, Неопределено)
КонецФункции

// Возвращает ссылки по УИД, но поиск происходит только по заданным типам
// Параметры:
//  УУИДы  - Строка или Массив строк - УИДы, по которым надо найти ссылку
//  ГдеИскать  - Массив - Допустимые типы ссылки-
// Возвращаемое значение:
//   Массив   - Найденные ссылки или Неопределено
Функция СсылкиЗаданногоТипаПоУИД(УИДы, ГдеИскать) Экспорт
	ЧтоИскать = ВОЛНА_ОбщегоНазначения_КлиентСервер.ПреобразоватьВМассив(УИДы);
	мГдеИскать = Новый Массив;
	Для каждого ТекТип Из ГдеИскать Цикл
		мГдеИскать.Добавить(ИмяТаблицыОбъектаПоТипу(ТекТип, "Менеджер").Менеджер);//ВОЛНА_ОбщегоНазначения_ВСПовтИспСеанс.
	КонецЦикла;
	Результат = Новый Массив;
	Для каждого УИД Из ЧтоИскать Цикл
		ТекСсылка = Неопределено;
		Для каждого Менеджер Из мГдеИскать Цикл
			ТекСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(УИД));
			Если ТекСсылка <> Неопределено Тогда
				Прервать;
			КонецЕсли;
			Результат.Добавить(ТекСсылка);
		КонецЦикла; 
	КонецЦикла;
	Возврат Результат
КонецФункции // СсылкиЗаданногоТипаПоУИД()
 
// Возвращает таблицу найденных ссылок по массиву искомых ссылок. Также является вспомогательной для функций замены.
// Параметры:
//  Ссылки  - Массив, список значений или ссылка - искомые ссылки
// Возвращаемое значение:
//   Таблица значений   - с колонками "Включено" (булево) - для последующей замены, всегда Истина,
//		"Ссылка" (найденная ссылка), "Данные" (ссылка на объект, содержащий искомую ссылку) и "Метаданные".
Функция НайтиСсылкиПоМассиву(Ссылки) Экспорт
	Если ТипЗнч(Ссылки) = Тип("СписокЗначений") Тогда
		МассивЗаменяемых = Ссылки.ВыгрузитьЗначения();
	Иначе
		МассивЗаменяемых = Ссылки;
		ВОЛНА_ОбщегоНазначения_КлиентСервер.ПреобразоватьВМассив(МассивЗаменяемых, Истина);
	КонецЕсли;
	НайденныеСсылки = НайтиПоСсылкам(МассивЗаменяемых);
	НайденныеСсылки.Колонки[0].Имя = "Ссылка";
	НайденныеСсылки.Колонки[1].Имя = "Данные";
	НайденныеСсылки.Колонки[2].Имя = "Метаданные";
	НайденныеСсылки.Колонки.Добавить("Включено", Новый ОписаниеТипов("Булево"));
	НайденныеСсылки.ЗаполнитьЗначения(Истина, "Включено");
	Возврат НайденныеСсылки;
КонецФункции // НайтиСсылкиПоМассиву()
 
// Возвращает таблицу найденных ссылок по таблице замен с колонками ЧтоЗаменять и Пометка
// Параметры:
//	ТабЗамен - Таблица значений - с колонками Пометка и ЧтоЗаменять
// Возвращаемое значение:
//   Таблица значений   - с колонками "Включено" (булево) - для последующей замены, всегда Истина,
//		"Ссылка" (найденная ссылка), "Данные" (ссылка на объект, содержащий искомую ссылку) и "Метаданные".
Функция НайтиСсылкиПоТаблицеЗамен(ТабЗамен) Экспорт
	ТабЗаменяемых = ТабЗамен.Скопировать(ТабЗамен.НайтиСтроки(Новый Структура("Пометка", Истина)), "ЧтоЗаменять");
	ТабЗаменяемых.Свернуть("ЧтоЗаменять");
	МассивЗаменяемых = ТабЗаменяемых.ВыгрузитьКолонку("ЧтоЗаменять");
	Если МассивЗаменяемых.Количество() = 0 Тогда
		Сообщить("Не выбрано ни одного значения для поиска!");
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	Возврат НайтиСсылкиПоМассиву(МассивЗаменяемых)
КонецФункции

// Получает ссылку нового или существующего объекта, а если она пустая, то устанавливает её и возвращает новую ссылку.
// Параметры:
//  ПроверяемыйОбъект  - Объект: СправочникОбъект, ДокументОбъект, и т.д. - ссылка на который проверяется
// Возвращаемое значение:
//   Ссылка   -  на объект
Функция СсылкаНаОбъект(ПроверяемыйОбъект) Экспорт
	Если ПроверяемыйОбъект.ЭтоНовый() Тогда
		Результат = ПроверяемыйОбъект.ПолучитьСсылкуНового();
		Если СокрЛП(Результат.УникальныйИдентификатор()) = "00000000-0000-0000-0000-000000000000" Тогда
			Результат = ИмяТаблицыОбъектаПоТипу(ТипЗнч(Результат), "Менеджер").ПолучитьСсылку(Новый УникальныйИдентификатор);//ВОЛНА_ОбщегоНазначения_ВСПовтИспСеанс.
			ПроверяемыйОбъект.УстановитьСсылкуНового(Результат);
		КонецЕсли; 
	Иначе
		Результат = ПроверяемыйОбъект.Ссылка;
	КонецЕсли; 
	Возврат Результат
КонецФункции // СсылкаНаОбъект

#КонецОбласти 

#Область РЕКВИЗИТЫ_ОБЪЕКТОВ
	
// Возвращает запрос с временной таблицей, содержащей заданные колонки
// Параметры:
//  МассивОбъектов  - Массив или одиночный объект или соответствие - У кого брать реквизиты. Соответствие д.б. в формате (Тип -> Массив объектов)
//  СписокКолонок  - Строка с разделителем "," или Массив - список имён колонок таблицы-результата
//  Мэппинг  - Соответствие или Строка - (Тип -> Структура(Имя колонки таблицы -> ИмяРеквизита) или Текст запроса для объекта заданного типа). ИмяРеквизита м.б. в формате "ЗНАЧ = [Фиксированное значение или параметр]"
//  ДопПараметры  - Структура - Будет добавлена к параметрам запроса, по умолчанию Неопределено - параметры не добавляются.
// Возвращаемое значение:
//   Запрос   - Запрос со сформированной временной таблицей ВТ_Ответ
Функция РеквизитыРазнотипныхОбъектов(МассивОбъектов, СписокКолонок = "Номер,Дата", Мэппинг = Неопределено, ДопПараметры = Неопределено) Экспорт
	СоответствиеТипов = ?(ТипЗнч(МассивОбъектов) = Тип("Соответствие"), МассивОбъектов, ВОЛНА_ОбщегоНазначения_КлиентСервер.РазбитьПоТипам(ВОЛНА_ОбщегоНазначения_КлиентСервер.ПреобразоватьВМассив(МассивОбъектов)));
	Колонки = ?(ТипЗнч(СписокКолонок) = Тип("Строка"), СтрРазделить(СписокКолонок, ",", Ложь), СписокКолонок);
	ТекстЗапроса = "";
	Для каждого ИмяКолонки Из Колонки Цикл
		ТекстЗапроса = ТекстЗапроса + ", NULL КАК " + ИмяКолонки;
	КонецЦикла; 
	ТекстЗапроса = "ВЫБРАТЬ" + Сред(ТекстЗапроса, 2) + " ПОМЕСТИТЬ ВТ_Ответ ГДЕ ЛОЖЬ" + Символы.ПС;
	Запрос = Новый Запрос(ТекстЗапроса);
	СчПараметров = 0;
	Для каждого КиЗ Из СоответствиеТипов Цикл
		Попытка
			МетаХ = КиЗ.Значение[0].Метаданные();
			ТипОбъекта = ?(Вычислить("ОбщегоНазначения.ЭтоДокумент(МетаХ)"), "Документ", ?(Вычислить("ОбщегоНазначения.ЭтоСправочник(МетаХ)"), "Справочник", ?(Вычислить("ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаХ)"), "ПланВидовХарактеристик", "Прочее")));
		Исключение
			МетаХ = Неопределено;
			ТипОбъекта = "Прочее";
			//ЭтоДокумент = Ложь;
		КонецПопытки;
		ТекМэппинг = ?(Мэппинг = Неопределено, Неопределено, Мэппинг[ТипЗнч(КиЗ.Значение[0])]);
		Если ТипЗнч(ТекМэппинг) = Тип("Строка") Тогда
			ИмяПараметра = "Параметр_" + СчПараметров;
			ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ " + СтрЗаменить(ТекМэппинг, "[СсылкиНаОбъекты]", ИмяПараметра) + Символы.ПС;
			Запрос.УстановитьПараметр(ИмяПараметра, КиЗ.Значение);
			СчПараметров = СчПараметров + 1;
		ИначеЕсли ТипОбъекта = "Прочее" Тогда
			Если ТекМэппинг = Неопределено Тогда
				Если Колонки.Найти("Ссылка") <> Неопределено Тогда
					Для каждого СтранноеЗначение Из КиЗ.Значение Цикл
						ЧастныйТекст = "";
						Для каждого Колонка Из Колонки Цикл
							Если Колонка = "Ссылка" Тогда
								ЧастныйТекст = ЧастныйТекст + ", " + "&Параметр_" + СчПараметров;
								Запрос.УстановитьПараметр("Параметр_" + СчПараметров, СтранноеЗначение);
								СчПараметров = СчПараметров + 1;
							Иначе
								ЧастныйТекст = ЧастныйТекст + ", NULL";
							КонецЕсли; 
						КонецЦикла; 
						ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2);
					КонецЦикла; 
				КонецЕсли; 
			Иначе
				Для каждого СтранноеЗначение Из КиЗ.Значение Цикл
					ЧастныйТекст = "";
					Для каждого Колонка Из Колонки Цикл
						Если ?(ТекМэппинг = Неопределено, Истина, НЕ ТекМэппинг.Свойство(Колонка)) Тогда
							ЧастныйТекст = ЧастныйТекст + ", NULL";
						ИначеЕсли Лев(ТекМэппинг[Колонка], 7) = "ЗНАЧ = " Тогда
							ЧастныйТекст = ЧастныйТекст + ", " + Сред(ТекМэппинг[Колонка], 8);
						Иначе
							ЧастныйТекст = ЧастныйТекст + ", " + "&Параметр_" + СчПараметров;
							Запрос.УстановитьПараметр("Параметр_" + СчПараметров, СтранноеЗначение[ТекМэппинг[Колонка]]);
							СчПараметров = СчПараметров + 1;
						КонецЕсли; 
					КонецЦикла; 
					ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2);
				КонецЦикла; 
			КонецЕсли; 
		Иначе
			ЧастныйТекст = "";
			Для каждого Колонка Из Колонки Цикл
				Если ?(ТекМэппинг = Неопределено, Истина, НЕ ТекМэппинг.Свойство(Колонка)) Тогда
					ЧастныйТекст = ЧастныйТекст + ", Док." + Колонка;
				ИначеЕсли Лев(ТекМэппинг[Колонка], 7) = "ЗНАЧ = " Тогда
					ЧастныйТекст = ЧастныйТекст + ", " + Сред(ТекМэппинг[Колонка], 8);
				Иначе
					ЧастныйТекст = ЧастныйТекст + ", Док." + ТекМэппинг[Колонка];
				КонецЕсли; 
			КонецЦикла; 
			ТекстЗапроса = ТекстЗапроса + " ОБЪЕДИНИТЬ ВСЕ ВЫБРАТЬ " + Сред(ЧастныйТекст, 2) + " ИЗ " + ТипОбъекта + "." + МетаХ.Имя + " КАК Док ГДЕ Док.Ссылка В(&Параметр_" + СчПараметров + ")" + Символы.ПС;
			Запрос.УстановитьПараметр("Параметр_" + СчПараметров, КиЗ.Значение);
			СчПараметров = СчПараметров + 1;
		КонецЕсли;
	КонецЦикла;
	Запрос.Текст = ТекстЗапроса;
	Если ДопПараметры <> Неопределено Тогда
		Для каждого КиЗ Из ДопПараметры Цикл
			Запрос.УстановитьПараметр(КиЗ.Ключ, КиЗ.Значение);
		КонецЦикла; 
	КонецЕсли; 
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.Выполнить();
	Возврат Запрос
КонецФункции // РеквизитыРазнотипныхОбъектов()

// Возвращает структуру реквизитов регистра, где ключ - имя реквизита, а значение - вид реквизита
// Параметры:
//  Регистр  - Строка - Строка вида "РегистрыСведений.АдресныеСведения" или объект регистра, по которому нужна структура.
//  Фильтр  - Строка - "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты" (по умолчанию) или только часть её в том же формате.
//  РазделятьВиды  - Булево - При Истина ключами будут "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты", а значениями = структуры с ключами=именами м значениями=видами,
//			а при ЛОЖЬ (по умолчанию) - одна структура с ключами=именами и значениями=видами.
//  ЗначениеКлючей  - Произвольный - Значение, которое будет подставляться вместо видов. Если NULL или не обозначено - см.РазделятьВиды.
// Возвращаемое значение:
//   Структура   - Структура с ключами - имена реквизитов.
Функция СтруктураЗаписиРегистра(Регистр, Фильтр = "", РазделятьВиды = Ложь, ЗначениеКлючей = NULL) Экспорт
	Результат = Новый Структура;
	МетаДашка = Метаданные;
	МетаНепериодРС = МетаДашка.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
	МетаМесяцРР = Неопределено;
	МетаНепериодРС = МетаДашка.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
	МетаДашка = Вычислить("МетаДашка." + Регистр);
	СтруктураВозврата = Новый Структура(?(Фильтр = "", "Измерения,Ресурсы,Реквизиты,СтандартныеРеквизиты", Фильтр));
	Для каждого КиЗ Из СтруктураВозврата Цикл
		Для каждого Реквизит Из МетаДашка[КиЗ.Ключ] Цикл
			Результат.Вставить(Реквизит.Имя, ?(ЗначениеКлючей = NULL, КиЗ.Ключ, ЗначениеКлючей));
		КонецЦикла;
		Если РазделятьВиды Тогда
			СтруктураВозврата[КиЗ.Ключ] = Результат;
			Результат = Новый Структура;
		КонецЕсли;
	КонецЦикла;
	Если РазделятьВиды Тогда
		Результат = СтруктураВозврата;
	КонецЕсли;
	Возврат Результат
КонецФункции // СтруктураЗаписиРегистра

// Загоняет в структуру все реквизиты объекта
// Параметры:
//  Чьих  - любая ссылка - ссылка на объект для чтения в структуру
//  Табчасти  - Булево - считывать ли табчасти
//  ТабчастиПредставлением  - <Тип.Вид> - <описание параметра>
// Возвращаемое значение:
//   Структура   - ключ - имя реквизита, значение - значение реквизита. Если Чьих не ссылка - ключ "Предмет", а значение - Чьих.
Функция СформироватьСтруктуруВсехРеквизитов(Чьих, Табчасти = Ложь, ТабчастиПредставлением = Ложь, Общие = Истина) Экспорт
	Попытка
		МетаХ = Чьих.Метаданные();
	Исключение
		МетаХ = Неопределено;
	КонецПопытки;
	Если МетаХ = Неопределено Тогда
		Возврат Новый Структура("Предмет", Чьих);
	Иначе
		Результат = Новый Структура;
		Для каждого Реквизит Из МетаХ.Реквизиты Цикл
			Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
		КонецЦикла; 
		Для каждого Реквизит Из МетаХ.СтандартныеРеквизиты Цикл
			Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
		КонецЦикла;
		Если Общие Тогда
			МетаВсё = Метаданные;
			МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
			ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
			РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
			АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
			ИнфоОР = Неопределено;
			Для Каждого Реквизит Из МетаВсё.ОбщиеРеквизиты Цикл
				//ЭлементР = Реквизит.Состав.Найти(МетаХ);
				Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
					//?(ЭлементР = Неопределено, Ложь, (ЭлементР.Использование = ИОР.Авто) ИЛИ (ЭлементР.Использование = ИОР.Использовать)) Тогда
					Результат.Вставить(Реквизит.Имя, Чьих[Реквизит.Имя]);
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
		Если ТабЧасти Тогда
			Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
				Результат.Вставить(ТЧ.Имя, ?(ТабчастиПредставлением, "Табличная часть", Чьих[Реквизит.Имя]));
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли;
	Возврат Результат;
КонецФункции //  СформироватьСтруктуруВсехРеквизитов()

#Область РеквизитыОбъектаПоТипамИлиЗначениям
	
// Возвращает соответствие, где ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
// Параметры:
//  Источник  - Объект или ссылка, допускающие применение Метаданные() - Объект, в котором ищутся типы или значения
//  ТипыИлиЗначения  - Массив - Типы или значения, которые ищутся.
//  ИскатьВСтандартных  - Булево - Надо ли искать в стандартных реквизитах. По умолчанию Истина.
//  ИскатьВОбщих  - Булево - Надо ли искать в общих реквизитах. По умолчанию Истина.
//  ИскатьВТабЧастях  - Булево - Надо ли искать в табчастях. По умолчанию Истина.
// Возвращаемое значение:
//   Соответствие   - ключ - тип (или иное значение), а значение - массив имён реквизитов, допускающих использование этого типа (или содержащих это значение)
Функция РеквизитыОбъектаПоТипамИлиЗначениям(Источник, ТипыИлиЗначения, ИскатьВСтандартных = Истина, ИскатьВОбщих = Истина, ИскатьВТабЧастях = Истина) Экспорт
	ТипТип = Тип("Тип");
	Результат = Новый Соответствие;
	Для каждого ТекЗнч Из ТипыИлиЗначения Цикл
		Результат.Вставить(ТекЗнч, Новый Массив);
	КонецЦикла; 
	МетаХ = Источник.Метаданные();
	РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.Реквизиты, ТипТип);
	Если ИскатьВСтандартных Тогда
		РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, МетаХ.СтандартныеРеквизиты, ТипТип);
	КонецЕсли;
	Если ИскатьВОбщих Тогда
		МетаВсё = Метаданные;
		МетаСвойстваОбъектов = МетаВсё.СвойстваОбъектов;
		ИОР = МетаСвойстваОбъектов.ИспользованиеОбщегоРеквизита;
		РДОРР = МетаСвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять;
		АИОРИ = МетаСвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
		ИнфоОР = Неопределено;
		Для Каждого Реквизит Из МетаВсё.ОбщиеРеквизиты Цикл
			//ЭлементР = Реквизит.Состав.Найти(МетаХ);
			Если ОбщийРеквизитИспользуется(МетаХ, Реквизит, ИнфоОР, ИОР, АИОРИ, РДОРР) Тогда
				РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ВОЛНА_ОбщегоНазначения_КлиентСервер.ПреобразоватьВМассив(Реквизит), ТипТип);
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	Если ИскатьВТабЧастях Тогда
		Для каждого ТЧ Из МетаХ.ТабличныеЧасти Цикл
			РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Результат, Источник, ТЧ.Реквизиты, ТипТип, ТЧ.Имя + ".");
		КонецЦикла; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // РеквизитыОбъектаПоТипамИлиЗначениям
 
//Вспомогательная для РеквизитыОбъектаПоТипамИлиЗначениям
// Параметры:
//  Приёмник  - Соответствие - Ключ = обрабатываемое значение, значение - массив имён реквизитов, найденных по значению
//  Источник  - Объект или ссылка - Объект, в котором ищутся значения
//  МетаКоллекция  - Коллекция объектов метаданных - Коллекция, по которой ищутся типы или значения
//  ТипТип  - Тип - Тип("Тип") - уже вычисленный
//  Префикс  - Строка - префикс имени реквизита (путь к родителю)
Процедура РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям(Приёмник, Источник, МетаКоллекция, ТипТип, Префикс = "")
	Для каждого Реквизит Из МетаКоллекция Цикл
		Для каждого КиЗ Из Приёмник Цикл
			ТекЗнч = КиЗ.Ключ;
			ЭтоТип = ТекЗнч = ТипТип;
			Если ?(ЭтоТип, Реквизит.Тип.СодержитТип(ТекЗнч), Источник[Реквизит.Имя] = ТекЗнч) Тогда
				КиЗ.Значение.Добавить(Префикс + Реквизит.Имя);
			КонецЕсли;
		КонецЦикла; 
	КонецЦикла;
КонецПроцедуры // РеквизитыНепосредственноОбъектаПоТипамИлиЗначениям

// Возвращает, применяется ли общий реквизит для объекта метаданных
// Параметры:
//  МетаХ  - Объект метаданных - для которого проверяется использование общего реквизита
//  ОРеквизит  - Объект метаданных Общий реквизит - для которого проверяется использование общего реквизита
//  ИспользованияОР  - Соответствие - Соответствие, где ключ - ОР, а значение - соответствие, где ключ - метаданные, а значение - булево, использование. Если Неопределено, рассчитывается и возвращается при необходимости.
//  ИОР  - Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
//  АИОРИ  - Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
//  РДОРР  - Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять - чтобы не вычислять повторно. Если Неопределено, рассчитывается и возвращается при необходимости.
// Возвращаемое значение:
//   Булево   - Истина, если реквизит используется
Функция ОбщийРеквизитИспользуется(МетаХ, ОРеквизит, ИспользованияОР = Неопределено, ИОР = Неопределено,
		АИОРИ = Неопределено, РДОРР = Неопределено) Экспорт
	Если (РДОРР = Неопределено) ИЛИ (ИОР = Неопределено) ИЛИ (АИОРИ = Неопределено) Тогда
		МСО = Метаданные.СвойстваОбъектов;
		РДОРР = МСО.РазделениеДанныхОбщегоРеквизита.Разделять;
		ИОР = МСО.ИспользованиеОбщегоРеквизита;
		АИОРИ = МСО.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли; 
	Если ИспользованияОР = Неопределено Тогда
		ИспользованияОР = Новый Соответствие;
	КонецЕсли; 
	Получен = Ложь;
	Использование_ = ИспользованияОР[ОРеквизит];
	Если Использование_ = Неопределено Тогда
		Использование_ = Новый Соответствие;
		ИспользованияОР.Вставить(ОРеквизит, Использование_);
		Результат = Неопределено;
	Иначе
		Результат = Использование_[МетаХ];
		Получен = Результат <> Неопределено;
	КонецЕсли;
	Если НЕ Получен Тогда
		ЭлементР = ОРеквизит.Состав.Найти(МетаХ);//Замедляет!!!!!! 40% при 250 тыс. запусках (а откуда столько? 250К Общих реквизитов????)
		Результат = Ложь;
		Если ЭлементР <> Неопределено Тогда
			ТекИсп = ЭлементР.Использование;
			Если ТекИсп = ИОР.Авто Тогда
				Если ОРеквизит.АвтоИспользование = АИОРИ Тогда //200000 запусков
					Результат = Истина;
				КонецЕсли; 
			ИначеЕсли ТекИсп = ИОР.Использовать Тогда
				Результат = Истина;
			КонецЕсли; 
			Если ОРеквизит.РазделениеДанных = РДОРР Тогда
				Если Строка(ОРеквизит.УсловноеРазделение) <> "" Тогда
					Попытка
						Результат = Результат И Константы[ОРеквизит.УсловноеРазделение.Имя].Получить();
					Исключение
						
					КонецПопытки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Использование_.Вставить(МетаХ, Результат);
	Возврат Результат
КонецФункции // ОбщийРеквизитИспользуется

#КонецОбласти 
 
#КонецОбласти 

#Область СКД
	
//Возвращает таблицу значений - результат выполнения СКД
//Параметры:
//	СКД - СхемаКомпоновкиДанных - 
//	НастройкиСКД - Настройки СДК - применяемые при выполнении 
//	ВозможностьПрерыванияПользователем - Булево - Параметр запуска процессора вывода, разрешающий прерывание пользователем
//	НаборыОбъекты - Структура - Источники данных для подстановки в НаборДанныхОбъект. По умолчанию Неопределено.
//	МВТ - МенеджерВременныхТаблиц - Для процессора компоновки. По умолчанию Неопределено.
//Возвращаемое значение:
//	ТаблицаЗначений - Результат выполнения СКД
Функция ТаблицаСКД(СКД, НастройкиСКД = Неопределено, ВозможностьПрерыванияПользователем = Ложь, НаборыОбъекты = Неопределено, МВТ = Неопределено) Экспорт
	Если НастройкиСКД = Неопределено Тогда
		НастройкиСКД = СКД.НастройкиПоУмолчанию;
	КонецЕсли; 
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СКД, НастройкиСКД,,, Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	ПроцессорКомпоновкиДанных_ = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных_.Инициализировать(МакетКомпоновки, НаборыОбъекты,,Истина,, МВТ);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	Результат = Новый ТаблицаЗначений;
	ПроцессорВывода.УстановитьОбъект(Результат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных_, ВозможностьПрерыванияПользователем);
	Возврат Результат
КонецФункции

//Возвращает элементы структуры настроек схемы компоновки данных по их именам
//Параметры:
//  СтруктураСКД  - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных - головной элемент структуры СКД (структура, таблица, строки или колонки),  в которой будет поиск
//  Имена  - Строка или Массив (массив изменяется в процессе!) - Через запятую или в массиве - имена элементов, которые надо найти. Имена у искомых элементов д.б. настроены в конфигураторе.
//  Результат  - Структура - Если структура уже есть, и в неё надо добавить элементы, то она передаётся в этом параметре. Она же будет возвращена.
//Возвращаемое значение:
//   Структура   - ключи - переданные имена, разобранные из строки, значения - найденные элементы
Функция НайтиЭлементыСтруктурыКДПоИменам(СтруктураСКД, Имена, Результат = Неопределено) Экспорт
	Если Результат = Неопределено Тогда
		Результат = Новый Структура;
	КонецЕсли;
	МассивХ = ?(ТипЗнч(Имена) = Тип("Массив"), Имена, СтрРазделить(Имена, ",", Ложь));
	Для каждого СтрокаСтруктуры Из СтруктураСКД Цикл
		Индех = МассивХ.Найти(СтрокаСтруктуры.Имя);
		Если Индех <> Неопределено Тогда
			Результат.Вставить(СтрокаСтруктуры.Имя, СтрокаСтруктуры);
			МассивХ.Удалить(Индех);
		КонецЕсли; 
		//Если Флаги.Свойство(СтрокаСтруктуры.Идентификатор) Тогда
		//	СтрокаСтруктуры.Использование = Флаги[СтрокаСтруктуры.Идентификатор];
		//КонецЕсли;
		Если МассивХ.Количество() Тогда
			Тест = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
			ЗаполнитьЗначенияСвойств(Тест, СтрокаСтруктуры);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Колонки, МассивХ, Результат);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Строки, МассивХ, Результат);
			НайтиЭлементыСтруктурыКДПоИменам(Тест.Структура, МассивХ, Результат);
		КонецЕсли; 
	КонецЦикла; 
	Возврат Результат
КонецФункции // НайтиЭлементыСтруктурыКДПоИменам
 
#Область КОПИРОВАНИЕ_ГРУППИРОВКИ_СКД
	
//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию выбранных полей
//Параметры:
//	СтруктураПриёмник - ВыбранныеПоляКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ВыбранноеПолеКомпоновкиДанных или АвтоВыбранноеПолеКомпоновкиДанных или ГруппаВыбранныхПолейКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьВыбранныеПоля(СтруктураПриёмник, Элемент) Экспорт
	Если Тип(Элемент) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Заголовок = Элемент.Заголовок; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Поле = Элемент.Поле; 
	ИначеЕсли Тип(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
	ИначеЕсли Тип(Элемент) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Заголовок = Элемент.Заголовок; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Расположение = Элемент.Расположение; 
		НовЭлемент.Поле = Элемент.Поле; 
		Для каждого Элемент Из Элемент.Выбор.Элементы Цикл 
			ДобавитьВыбранныеПоля(НовЭлемент.Выбор.Элементы, Элемент); 
		КонецЦикла; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции 

//Переносит свойства переданного элемента в соответствующий элемент параметров вывода приёмника.
//Параметры:
//	СтруктураПриёмник - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЗначениеПараметраКомпоновкиДанных или ЗначениеПараметраНастроекКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьПараметрыВывода(СтруктураПриёмник, Элемент) Экспорт 
	НовЭлемент = СтруктураПриёмник.Найти(Строка(Элемент.Параметр)); 
	НовЭлемент.Значение = Элемент.Значение; 
	НовЭлемент.Использование = Элемент.Использование; 
	Для каждого Элемент Из Элемент.ЗначенияВложенныхПараметров Цикл 
		ДобавитьПараметрыВывода(НовЭлемент.ЗначенияВложенныхПараметров, Элемент); 
	КонецЦикла; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию отборов
//Параметры:
//	СтруктураПриёмник - ОтборКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементОтбораКомпоновкиДанных или ГруппаЭлементовОтбораКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьОтбор(СтруктураПриёмник, Элемент) Экспорт 
	Если Тип(Элемент) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.ВидСравнения = Элемент.ВидСравнения; 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.ЛевоеЗначение = Элемент.ЛевоеЗначение; 
		НовЭлемент.ПравоеЗначение = Элемент.ПравоеЗначение; 
		НовЭлемент.Представление = Элемент.Представление; 
		НовЭлемент.Применение = Элемент.Применение; 
		НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
	ИначеЕсли Тип(Элемент) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Представление = Элемент.Представление; 
		НовЭлемент.Применение = Элемент.Применение; 
		НовЭлемент.РежимОтображения = Элемент.РежимОтображения; 
		НовЭлемент.ТипГруппы = Элемент.ТипГруппы; 
		Для каждого ЭлементОтбора Из Элемент.Элементы Цикл 
			ДобавитьОтбор(НовЭлемент.Отбор.Элементы, ЭлементОтбора); 
		КонецЦикла; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию условного оформления
//Параметры:
//	СтруктураПриёмник - УсловноеОформлениеКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементУсловногоОформленияКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьУсловноеОформление(СтруктураПриёмник, Элемент) Экспорт 
	НовЭлемент = СтруктураПриёмник.Добавить(); 
	НовЭлемент.Представление = Элемент.Представление; 
	НовЭлемент.Использование = Элемент.Использование; 
	//отбор 
	Для каждого ЭлементОтбор Из Элемент.Отбор.Элементы Цикл 
		ДобавитьОтбор(НовЭлемент.Отбор.Элементы,ЭлементОтбор); 
	КонецЦикла; 
	//оформление 
	Для каждого ЭлементОформление Из Элемент.Оформление.Элементы Цикл 
		ДобавитьПараметрыВывода(НовЭлемент.Оформление.Элементы,ЭлементОформление); 
	КонецЦикла; 
	//поля 
	Для каждого ЭлементПоле Из Элемент.Поля.Элементы Цикл 
		НовЭлементПоле = НовЭлемент.Поля.Элементы.Добавить(); 
		НовЭлементПоле.Использование = ЭлементПоле.Использование; 
		НовЭлементПоле.Поле = ЭлементПоле.Поле; 
	КонецЦикла; 
	Возврат НовЭлемент
КонецФункции 

//Добавляет элемент со свойствами, как у заданного, в переданную коллекцию порядка
//Параметры:
//	СтруктураПриёмник - ПорядокКомпоновкиДанных - Коллекция-приёмник;
//	Элемент - ЭлементПорядкаКомпоновкиДанных или АвтоЭлементПорядкаКомпоновкиДанных - элемент-источник, свойства которого будут скопированы.
//Возвращаемое значение:
//	Тип как у Элемент - Добавленный элемент
Функция ДобавитьПорядок(СтруктураПриёмник, Элемент) Экспорт 
	Если Тип(Элемент) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
		НовЭлемент.Поле = Элемент.Поле; 
		НовЭлемент.ТипУпорядочивания = Элемент.ТипУпорядочивания; 
	ИначеЕсли Тип(Элемент) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда 
		НовЭлемент = СтруктураПриёмник.Добавить(Тип(Элемент)); 
		НовЭлемент.Использование = Элемент.Использование; 
	КонецЕсли; 
	Возврат НовЭлемент
КонецФункции

//Копирует элемент структуры СКД в другую (или эту же) структуру СКД.
//Содрана https://forum.infostart.ru/forum9/topic47305/
//Параметры:
//	СтруктураПриёмник - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных или КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - куда будет помещён новый элемент
//	ЭлементИсточник - ГруппировкаКомпоновкиДанных, ТаблицаКомпоновкиДанных, ДиаграммаКомпоновкиДанных или НастройкиВложенногоОбъектаКомпоновкиДанных - Копируемый элемент структуры настроек СКД.
//			Для некоторых типов м.б. не проверено :(
//	ОткудаУдалитьНаСтаромМесте - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных или КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных - Коллекция, из которой надо удалять старый элемент (Неопределено по умолчанию - не удалять).
//Возвращаемое значение:
//	Того же типа, что и ЭлементИсточник - Добавленный элемент
Функция СкопироватьЭлементВСтруктуруСКД(СтруктураПриёмник, ЭлементИсточник, ОткудаУдалитьНаСтаромМесте = Неопределено) Экспорт 
	
	ЭтоВТаблице = ТипЗнч(СтруктураПриёмник) = Тип("КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных");
	Результат = ?(ЭтоВТаблице, СтруктураПриёмник.Добавить(), СтруктураПриёмник.Добавить(ТипЗнч(ЭлементИсточник)));
	
	//выбор 
	Для каждого Элемент Из ЭлементИсточник.Выбор.Элементы Цикл 
		ДобавитьВыбранныеПоля(Результат.Выбор.Элементы, Элемент) 
	КонецЦикла; 
	//использование 
	Результат.Использование = ЭлементИсточник.Использование; 
	//имя 
	Результат.Имя = ЭлементИсточник.Имя; 
	//отбор 
	Для каждого Элемент Из ЭлементИсточник.Отбор.Элементы Цикл 
		ДобавитьОтбор(Результат.Отбор.Элементы, Элемент); 
	КонецЦикла; 
	// параметры вывода 
	Для каждого Элемент Из ЭлементИсточник.ПараметрыВывода.Элементы Цикл 
		ДобавитьПараметрыВывода(Результат.ПараметрыВывода.Элементы,Элемент); 
	КонецЦикла; 
	//поля группировки 
	Для каждого Элемент Из ЭлементИсточник.ПоляГруппировки.Элементы Цикл 
		Если ТипЗнч(Элемент) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда 
			НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
			НовЭлемент.Использование = Элемент.Использование; 
			НовЭлемент.КонецПериода = Элемент.КонецПериода; 
			НовЭлемент.НачалоПериода = Элемент.НачалоПериода; 
			НовЭлемент.Поле = Элемент.Поле; 
			НовЭлемент.ТипГруппировки = Элемент.ТипГруппировки; 
			НовЭлемент.ТипДополнения = Элемент.ТипДополнения; 
		ИначеЕсли ТипЗнч(Элемент) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда 
			НовЭлемент = Результат.ПоляГруппировки.Элементы.Добавить(ТипЗнч(Элемент)); 
			НовЭлемент.Использование = Элемент.Использование; 
		КонецЕсли; 
	КонецЦикла; 
	//порядок 
	Для каждого Элемент Из ЭлементИсточник.Порядок.Элементы Цикл 
		ДобавитьПорядок(Результат.Порядок.Элементы, Элемент); 
	КонецЦикла; 
	//условное оформление 
	Для каждого Элемент Из ЭлементИсточник.УсловноеОформление.Элементы Цикл 
		ДобавитьУсловноеОформление(Результат.УсловноеОформление.Элементы, Элемент); 
	КонецЦикла; 
	
	//обход структуры рекурсивно 
	ТМП = Новый Структура("Колонки,Строки,Структура", Новый СписокЗначений, Новый СписокЗначений, Новый СписокЗначений);
	ЗаполнитьЗначенияСвойств(ТМП, ЭлементИсточник);
	Для каждого Подчинённый Из ТМП.Структура Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Структура, Подчинённый) 
	КонецЦикла; 
	Для каждого Подчинённый Из ТМП.Строки Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Строки, Подчинённый) 
	КонецЦикла; 
	Для каждого Подчинённый Из ТМП.Колонки Цикл 
		СкопироватьЭлементВСтруктуруСКД(Результат.Колонки, Подчинённый) 
	КонецЦикла; 
	
	Если ОткудаУдалитьНаСтаромМесте <> Неопределено Тогда
		ОткудаУдалитьНаСтаромМесте.Удалить(ЭлементИсточник);
	КонецЕсли;
	Возврат Результат
КонецФункции 

#КонецОбласти 

#КонецОбласти

#Область ТАБЛИЧНЫЙ_ДОКУМЕНТ

// Получает табличный документ из двоичных данных Excel или Excel
// Параметры:
//  ДДилиФайл  - ДвоичныеДанные/Строка - ДД, полученные, например, из хранилища или макета/путь к файлу
//  Расширение  - Строка - расширение Excel (нужно только для ДД), по умолчанию xlsx
// Возвращаемое значение:
//   Табличный документ   - Прочитанный из Excel
Функция ТДизExcel(ДДилиФайл, Расширение = "xlsx") Экспорт
	ТекТип = ТипЗнч(ДДилиФайл);
	ЭтоДД = ТекТип = Тип("ДвоичныеДанные");
	Если ТекТип = Тип("Строка") Тогда
		ПутьКФайлуИсточнику = ДДилиФайл;
	ИначеЕсли ЭтоДД Тогда
		ПутьКФайлуИсточнику = ПолучитьИмяВременногоФайла(Расширение);
		ДДилиФайл.Записать(ПутьКФайлуИсточнику);
		ФайлГотов = Истина;
	Иначе
		ПутьКФайлуИсточнику = ДДилиФайл;
	КонецЕсли;
	Результат = Новый ТабличныйДокумент;
	Если ЗначениеЗаполнено(ПутьКФайлуИсточнику) Тогда
		Результат.ИспользуемоеИмяФайла = ПутьКФайлуИсточнику;
		Результат.Прочитать(ПутьКФайлуИсточнику);
	КонецЕсли;
	Если ЭтоДД Тогда
		УдалитьФайлы(ПутьКФайлуИсточнику);
	КонецЕсли;
	Возврат Результат
КонецФункции // ТДизExcel

#Область РАСШИФРОВКА

// Возвращает структуру полей расшифровки ячейки
// Параметры:
//	ИР  - Идентификатор расшифровки КД - ИД для получения данных
//	ДанныеРасшифровки  - Адрес данных расшифровки КД во временном хранилище/ДанныеРасшифровки - Источник получения данных
//	ВключитьНастройки  - Булево - Включить в объект ключ Настройки_ = Структура настроек пасшифровки. Включает только верхний уровень.
//	ВключитьДРО  - Булево - Включить в объект ключ ДРО_ = Данные расшифровки
// Возвращаемое значение:
//	Структура   - Ключи = имена полей, значения = значения полей 
Функция ПоляТекущейРасшифровки(ИР, ДанныеРасшифровки, ВключитьНастройки = Истина, ВключитьДРО = Ложь) Экспорт
	Результат_ = Новый Структура;
	Если ИР <> Неопределено Тогда
		_ДРО = ?(ТипЗнч(ДанныеРасшифровки) = Тип("Строка"), ПолучитьИзВременногоХранилища(ДанныеРасшифровки), ДанныеРасшифровки);
		эДРО = ?(ТипЗнч(ДанныеРасшифровки) = Тип("Строка"), ПолучитьИзВременногоХранилища(ДанныеРасшифровки), ДанныеРасшифровки).Элементы[ИР];
		ПоляРасшифровкиВСтруктуруРекурсивно(Результат_, эДРО);
		Если эДРО.ПолучитьПоля()[0].Поле = "Результат" Тогда
			//ПолучитьИзВременногоХранилища(ДанныеРасшифровки).Элементы[ИР].ПолучитьРодителей()[0].ПолучитьПоля()[1].Значение
			Для каждого Родитель_ Из эДРО.ПолучитьРодителей() Цикл
				Для каждого ПолеРодителя Из Родитель_.ПолучитьПоля() Цикл
					Результат_.Вставить(ПолеРодителя.Поле, ПолеРодителя.Значение);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		Если ВключитьДРО Тогда
			Результат_.Вставить("ДРО_", _ДРО);
		КонецЕсли;
		Если ВключитьНастройки Тогда
			ТекНастройки = Новый Структура;
			Для каждого ТекЭлемент Из _ДРО.Настройки.ПараметрыДанных.Элементы Цикл
				ТекНастройки.Вставить(СокрЛП(ТекЭлемент.Параметр), ТекЭлемент.Значение);
			КонецЦикла;
			Результат_.Вставить("Настройки_", ТекНастройки);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат_
КонецФункции // ДанныеТекущейРасшифровки

// Заполняет в структуру имена и значения полей расшифровки
// Параметры:
//  Приёмник  - Структура - ключ = имя поля, значение = значение поля
//  ЭлементРасшифровки  - ЭлементРасшифровкиКомпоновкиДанных - поле или группировка, у которого будут искаться родительские поля
Процедура ПоляРасшифровкиВСтруктуруРекурсивно(Приёмник, ЭлементРасшифровки) Экспорт
	ТекТип = ТипЗнч(ЭлементРасшифровки);
	Рекурсировать = Ложь;
	Если ТекТип = Тип("ЭлементРасшифровкиКомпоновкиДанныхПоля") Тогда
		Для каждого Поле Из ЭлементРасшифровки.ПолучитьПоля() Цикл
			Приёмник.Вставить(Поле.Поле, Поле.Значение);
		КонецЦикла;
		Рекурсировать = Истина;
	ИначеЕсли ТекТип = Тип("ЭлементРасшифровкиКомпоновкиДанныхГруппировка") Тогда
		Рекурсировать = Истина;
	КонецЕсли;
	Если Рекурсировать Тогда
		Для каждого Родитель_ Из ЭлементРасшифровки.ПолучитьРодителей() Цикл
			ПоляРасшифровкиВСтруктуруРекурсивно(Приёмник, Родитель_);
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры // ПоляРасшифровкиВСтруктуруРекурсивно

#КонецОбласти
	
#КонецОбласти 

#Область УПРАВЛЯЕМАЯ_ФОРМА

// Преобразует таблицу значений в динамический список. ВНИМАНИЕ! Колонки ДС не обновляются, их надо обновлять функцией СоэдатьКолонкиТаблицы.
// Параметры:
//  ДинСписок  - Динамический список - Реквизит формы, приёмник
//  ТабИсточник  - Таблица значений - Источник данных. Не проверялось для больших таблиц.
//  ТипизироватьКолонки  - Строка - Список через запятую имён колонок или "ВСЕ". Если пустая строка (по умолчанию) - ни одна колонка не типизируется.
//			Типизация влияет на применение, например, вида сравнения "в иерархии".
//  ИмяПоляКлюча  - Строка - Имя специального поля поле с уникальным номером строки. По умолчанию "КлючСтроки". Если пустое - поле ключа не создаётся
Процедура ДинамическийСписокИзТаблицыЗначений(ДинСписок, ТабИсточник, ТипизироватьКолонки = "", ИмяПоляКлюча = "КлючСтроки") Экспорт
	ПерваяСтрока = Истина;
	#Область ТИПИЗАЦИЯ
		Если ТипизироватьКолонки <> "" Тогда
			#Область ТАБЛИЦА_ПРИМЕРНЫХ_ЗНАЧЕНИЙ
				ОбозначениеПараметра = Новый Цвет;
				ТабЗнТипы = ТабИсточник.СкопироватьКолонки();
				ТабЗнТипы = Новый ТаблицаЗначений;
				Для каждого Колонка Из ТабИсточник.Колонки Цикл
					ТабЗнТипы.Колонки.Добавить(Колонка.Имя);
				КонецЦикла;
				ТабЗнТипы.Добавить();
				СтруктураТипизируемыхКолонок = Новый Структура(ТипизироватьКолонки);
				Для каждого Колонка Из ТабИсточник.Колонки Цикл
					ИмяКолонки = Колонка.Имя;
					ТекТипы = Колонка.ТипЗначения.Типы();
					Если ТекТипы.Количество() И ?(ТипизироватьКолонки = "ВСЕ", Истина, СтруктураТипизируемыхКолонок.Свойство(ИмяКолонки)) Тогда
						ЁХ = 0;
						Для каждого Тек_Тип Из ТекТипы Цикл
							Если ЁХ = ТабЗнТипы.Количество() Тогда
								ТабЗнТипы.Добавить();
							КонецЕсли;
							ТабЗнТипы[ЁХ][ИмяКолонки] = ВОЛНА_ОбщегоНазначения_КлиентСервер.ПримерноеЗначение(
									Тек_Тип,
									Колонка.ТипЗначения.КвалификаторыЧисла,
									Колонка.ТипЗначения.КвалификаторыСтроки,
									Колонка.ТипЗначения.КвалификаторыДаты);
							ЁХ = ЁХ + 1;
						КонецЦикла;
					Иначе
						ТабЗнТипы[0][ИмяКолонки] = ОбозначениеПараметра;
					КонецЕсли;
				КонецЦикла;
			#КонецОбласти
			#Область ТЕКСТ_ТИПИЗАЦИИ
				ТекстТипизации = "";
				Для каждого Строчка Из ТабЗнТипы Цикл
					ТекстПоСтроке = "";
					Для каждого Колонка Из ТабЗнТипы.Колонки Цикл
						ТекЗнч = Строчка[Колонка.Имя];
						ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС
								+ ?(ЗначениеЗаполнено(ТекЗнч) И ТекЗнч <> ОбозначениеПараметра, ТекЗнч, "&ПараметрПусто")
								+ ?(ПерваяСтрока, " КАК " + Колонка.Имя, "");
					КонецЦикла;
					Если ЗначениеЗаполнено(ИмяПоляКлюча) Тогда
						ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + "0"
								+ ?(ПерваяСтрока, " КАК " + ИмяПоляКлюча, "");
					КонецЕсли;
					ПерваяСтрока = Ложь;
					ТекстТипизации = ТекстТипизации + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС + "ВЫБРАТЬ" + Сред(ТекстПоСтроке, 2) + Символы.ПС + "ГДЕ ЛОЖЬ" + Символы.ПС;
				КонецЦикла;
			#КонецОбласти
		КонецЕсли;
	#КонецОбласти
	#Область ФОРМИРОВАНИЕ_ТЕКСТА_И_ПАРАМЕТРОВ_ЗАПРОСА
		#Область ТЕКСТ_ПАРАМЕТРОВ_И_ПАРАМЕТРЫ
			ЁХ = 0;
			ТекстЗапроса = ТекстТипизации;
			НовыеПараметры = Новый Структура;
			Для каждого Строчка Из ТабИсточник Цикл
				ТекстПоСтроке = "";
				Для каждого Колонка Из ТабЗнТипы.Колонки Цикл
					ИмяКолонки = Колонка.Имя;
					ИмяПараметра = "Строчка" + ?(ЁХ = 0, "0", Формат(ЁХ, "ЧГ=0")) + ИмяКолонки;
					ТекЗнч = Строчка[Колонка.Имя];
					НовыеПараметры.Вставить(ИмяПараметра, ТекЗнч);
					ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + "&" + ИмяПараметра
							+ ?(ПерваяСтрока, " КАК " + Колонка.Имя, "");
				КонецЦикла;
				Если ЗначениеЗаполнено(ИмяПоляКлюча) Тогда
					ТекстПоСтроке = ТекстПоСтроке + "," + Символы.ПС + ?(ЁХ = 0, "0", Формат(ЁХ, "ЧГ=0"))
							+ ?(ПерваяСтрока, " КАК " + ИмяПоляКлюча, "");
				КонецЕсли;
				ПерваяСтрока = Ложь;
				ТекстЗапроса = ТекстЗапроса + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС + "ВЫБРАТЬ" + Сред(ТекстПоСтроке, 2) + Символы.ПС;
				ЁХ = ЁХ + 1;
			КонецЦикла;
		#КонецОбласти
		#Область БАЗОВЫЙ_И_ФИНАЛЬНЫЙ_ТЕКСТ
			ДинСписок.ТекстЗапроса = Сред(ТекстЗапроса, 16);
			Если Найти(ДинСписок.ТекстЗапроса, "&ПараметрПусто") > 0 Тогда
				ДинСписок.Параметры.УстановитьЗначениеПараметра("ПараметрПусто", Неопределено);
			КонецЕсли;
			Для каждого КиЗ Из НовыеПараметры Цикл
				ДинСписок.Параметры.УстановитьЗначениеПараметра(КиЗ.Ключ, КиЗ.Значение);
			КонецЦикла;
		#КонецОбласти
	#КонецОбласти
КонецПроцедуры // ДинамическийСписокИзТаблицыЗначений

// Формирует реквизит и элемент формы под загрузку заданной таблицы (в т.ч. колонки), а затем загружает туда таблицу
// Параметры:
//  УФорма  - ФормаКлиентскогоПриложения - Форма, которой принадлежит таблица или дерево
//  ИмяПриёмника  - Строка - Имя элемента, соответствующего загружаемой таблице
//  ТабИсточник  - Таблица или дерево значений - Имя реквизита и элемента, соответствующего загружаемой таблице
//	Загружать	- Строка -
//		*"Загрузка" - через Загрузить (только для таблиц значений)
//		*"ЗначВРеквФормы" - через ЗначениеВРеквизитФормы (по умолчанию). Только для одноуровневого пути.
//		*"Нет" - не выполнять
//  ТолькоЭлементы  - Булево - Не выполнять изменение реквизитов формы. По умолчанию Ложь.
// Возвращаемое значение:
//  Массив - имена колонок
Функция СоэдатьКолонкиТаблицы(УФорма, ИмяПриёмника, ТабИсточник, Загружать = "ЗначВРеквФормы", ТолькоЭлементы = Ложь) Экспорт
	Результат = Новый Массив;
	МассивДобавляемыхРеквизитов = Новый Массив;
	ПутьКПриёмнику = УФорма.Элементы[ИмяПриёмника].ПутьКДанным;
	#Область РЕКВИЗИТЫ
		Если НЕ ТолькоЭлементы Тогда
			Для Каждого Колонка Из ТабИсточник.Колонки Цикл 
				РеквизитФормы = Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ПутьКПриёмнику, Колонка.Имя); 
				МассивДобавляемыхРеквизитов.Добавить(РеквизитФормы);
				Результат.Добавить(Колонка.Имя);
			КонецЦикла;
			МассивУдаляемыхРеквизитов = Новый Массив;
			Для Каждого РеквизитХ Из УФорма.ПолучитьРеквизиты(ПутьКПриёмнику) Цикл 
				МассивУдаляемыхРеквизитов.Добавить(ПутьКПриёмнику + "." + РеквизитХ.Имя); 
			КонецЦикла;
			УФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов, МассивУдаляемыхРеквизитов);
		КонецЕсли;
	#КонецОбласти
	#Область ЭЛЕМЕНТЫ
		МассивУдаляемыхРеквизитов = Новый Массив;
		Для Каждого КолонкаХ Из УФорма.Элементы[ИмяПриёмника].ПодчиненныеЭлементы Цикл
			МассивУдаляемыхРеквизитов.Добавить(КолонкаХ);
		КонецЦикла;
		Для Каждого КолонкаХ Из МассивУдаляемыхРеквизитов Цикл
			УФорма.Элементы.Удалить(КолонкаХ);
		КонецЦикла;
		Для Каждого Колонка Из ТабИсточник.Колонки Цикл
			Попытка
				Элемент = УФорма.Элементы.Добавить(ИмяПриёмника + "_" + Колонка.Имя, Тип("ПолеФормы"), УФорма.Элементы[ИмяПриёмника]); 
				Элемент.Заголовок = Колонка.Имя;
				Если Колонка.ТипЗначения = Новый ОписаниеТипов("Булево") Тогда
					Элемент.Вид = ВидПоляФормы.ПолеФлажка;
					Элемент.ВидФлажка = ВидФлажка.Флажок;
					Элемент.РежимРедактирования = РежимРедактированияКолонки.Непосредственно;
				Иначе
					Элемент.Вид = ВидПоляФормы.ПолеВвода;
				КонецЕсли;
				Элемент.ПутьКДанным = ПутьКПриёмнику + "." + Колонка.Имя;
			Исключение
				ООш = ОписаниеОшибки();
				Сообщить("Не удалось добавить колонку " + Колонка.Имя + " по причине: " + ООш)
			КонецПопытки;
		КонецЦикла;
	#КонецОбласти 
	Если Загружать <> "Нет" Тогда
		Если Загружать = "Загрузка" Тогда
			ТекстКода = "УФорма." + ПутьКПриёмнику + ".Загрузить(ТабИсточник)";
		Иначе
			ТекстКода = "УФорма.ЗначениеВРеквизитФормы(ТабИсточник, """ + ПутьКПриёмнику + """);";
		КонецЕсли;
		Выполнить(ТекстКода);
	КонецЕсли;
    Возврат Результат
КонецФункции // СоздатьКолонкиТаблицы

#КонецОбласти 

//Возвращает массив видов характеристик, содержащих заданный тип
//ПВХ - строка с именем ПВХ, Тип - Тип
//Параметры:
//	ПВХ - строка -  имя плана вида характеристик
//	Тип - Тип -  искомый тип
//Возвращаемое значение:
//	Массив - виды характеристик, содержащие заданный тип.
Функция ВыбратьПВХСодержащиеТип(ПВХ, Тип) Экспорт
	Массив = Новый Массив;
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	ОбъектыСвойств.Ссылка,
	|	ОбъектыСвойств.ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик." + ПВХ + " КАК ОбъектыСвойств");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если Выборка.ТипЗначения.СодержитТип(Тип) Тогда
			Массив.Добавить(Выборка.Ссылка)
		КонецЕсли
	КонецЦикла;
	Возврат Массив
КонецФункции

// Записывает комплект в транзакции с попытками проведения и записи в разных режимах. Возвращает информацию по каждому объекту. Если хотя бы один не удалось записать никак - происходит откат транзакции.
// Параметры:
//  СооРежимыЗаписи  - Соответствие - Ключ = объект, значение = режим записи (Структура с ключами "Проведение", "Запись" и "ОДЗ" и булевыми значениями).
// Возвращаемое значение:
//   Соответствие   - Ключ = объект, значение = результат записи (см.ЗаписатьОбъект() + при Записан = Истина возможны
//			КакЗаписался = "НеМодифицирован" => запись не потребовалась + КакЗаписался = "ВнеРежима" => не был задан режим записи).
//			Может не содержать входящих объектов, если произошла ошибка и попытки записи были прекращены.			
Функция ЗаписатьКомплектВТранзакции(СооРежимыЗаписи) Экспорт
	Результат = Новый Соответствие;
	НачатьТранзакцию();
	Неудача = Ложь;
	Для каждого КиЗ Из СооРежимыЗаписи Цикл
		Если КиЗ.Ключ.Модифицированность() Тогда
			ТекУровень = ?(КиЗ.Значение.Проведение, "Проведение", ?(КиЗ.Значение.Запись, "Запись", ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить")));
			ТекстОшибки = "";
			Для СчПоп = 1 По 4 Цикл
				#Область ФОРМИРОВАНИЕ_ВЫЗОВА
					Если ТекУровень = "Проведение" Тогда
						ТекРез = ЗаписатьОбъект(КиЗ.Ключ, ?(КиЗ.Значение.Запись, ?(Киз.Значение.ОДЗ, "Все", Ложь), ?(Киз.Значение.ОДЗ, Истина, "НЕТ")),, Истина,, Ложь);
					ИначеЕсли ТекУровень = "Запись" Тогда
						ТекРез = ЗаписатьОбъект(КиЗ.Ключ, ?(Киз.Значение.ОДЗ, "Все", Ложь),,,, Ложь);
					ИначеЕсли ТекУровень = "ОДЗ" Тогда
						ТекРез = ЗаписатьОбъект(КиЗ.Ключ, Истина,,,, Ложь);
					Иначе
						Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Истина, "Не задан режим записи", "ВнеРежима", ""));
						Прервать;
					КонецЕсли;
				#КонецОбласти
				Если ТекРез.Записан Тогда
					ТекРез.Вставить("ТекстОшибки", ТекстОшибки + Символы.ПС + Текрез.ТекстОшибки);
					Результат.Вставить(КиЗ.Ключ, ТекРез);
					Прервать;
				Иначе
					ТекстОшибки = ТекстОшибки + Символы.ПС + ТекРез.ТекстОшибки;
					ОтменитьТранзакцию();
					Если ТекРез.Стадия = "Проведение" Тогда
						ТекУровень = ?(КиЗ.Значение.Запись, "Запись", ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить"));
					ИначеЕсли ТекРез.Стадия = "Запись" Тогда
						ТекУровень = ?(КиЗ.Значение.ОДЗ, "ОДЗ", "Прекратить");
					Иначе
						Неудача = Истина;
						Прервать;
					КонецЕсли;
					Если ТекУровень = "Прекратить" Тогда
						Неудача = Истина;
						Прервать;
					КонецЕсли;
					НачатьТранзакцию();
					Для каждого Проведённый Из Результат Цикл
						Если Проведённый.Значение.КакЗаписался <> "НеМодифицирован" И Проведённый.Значение.КакЗаписался <> "ВнеРежима" Тогда
							ЗаписатьОбъект(Проведённый.Ключ,
									Проведённый.Значение.КакЗаписался = "Записан в режиме загрузки",,
									Проведённый.Значение.КакЗаписался = "Проведён");
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Истина, "", "НеМодифицирован", ""));
		КонецЕсли;
		Если Неудача Тогда
			Результат.Вставить(КиЗ.Ключ, Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", Ложь, ТекстОшибки, "ОШИБКА", ТекРез.Стадия));
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если НЕ Неудача Тогда
		ЗафиксироватьТранзакцию();
	КонецЕсли;
	Возврат Результат
КонецФункции // ЗаписатьКомплектВТранзакции

//Запись объекта в базу в разных режимах
//Параметры:
//	Объект_				- Ссылка				- Что записывать
//	РежимЗагрузки		- Булево/Строка			- Режим "Обмен данными - Загрузка" загрузки при записи.
//			*"Не менять" (по умолчанию) - оставить как есть,
//			*"Все" - попробовать без "загрузки", если не получится - то с "загрузкой".
//			*Булево - установить указанный режим
//			Другие значения приведут к отказу от записи (кроме режима проведения).
//			При попытке проведения "Загрузка" всегда сбрасывается, на выходе из функции - восстанавливается как был.
//	ОтключитьМеханизмРегистрацииОбъектов - Булево/Неопределено - Отключить программную регистрацию на типовых планах обмена. Неопределено - не менять режим отключения.
//	ПопытатьсяПровести	- Булево	- Попытаться провести объект. По умолчанию ЛОЖЬ.
//	ПроверитьЧтоДок		- Булево	- Перед попыткой проведения проверить, документ ли это.
//  Сообщать			- Булево/Неопределено - Выдавать сообщения. Неопределено (по умолчанию) - сообщать только об ошибках.
//  Блокировать			- Булево - Использовать для записи управляемые блокировки. По умолчанию Ложь.
//Возвращаемое значение	- Структура с ключами:
//		* Записан		- Булево, удалось ли записать объект.
//		* ТекстОшибки	- Текст ошибки при записи. "", если ошибки нет.
//		* КакЗаписался	- Строка - "Не записан", "Проведён", "Записан штатно" или "Записан в режиме загрузки".
//		* Стадия		- Строка - "Блокировка", "Проведение", "Запись", "ОДЗ" или "" = стадия последней ошибочной попытки.
Функция ЗаписатьОбъект(
		Объект_,
		РежимЗагрузки = "Не менять",
		ОтключитьМеханизмРегистрацииОбъектов = Неопределено,
		ПопытатьсяПровести = Ложь,
		ПроверитьЧтоДок = Ложь,
		Сообщать = Неопределено,
		Блокировать = Ложь,
		ТолькоМодифицированный = Истина) Экспорт
	НеЗаписан = Истина;
	ПолноеСообщение = "";
	КакЗаписался = "Не записан";
	Стадия = "";
	Если ТолькоМодифицированный И НЕ Объект_.Модифицированность() Тогда
		КакЗаписался = "НеМодифицирован";
		НеЗаписан = Ложь;
	Иначе
		ТекОДЗ = Объект_.ОбменДанными.Загрузка;
		Если ОтключитьМеханизмРегистрацииОбъектов = Неопределено Тогда
		ИначеЕсли ОтключитьМеханизмРегистрацииОбъектов Тогда
			Объект_.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
		ИначеЕсли Объект_.ДополнительныеСвойства.Свойство("ОтключитьМеханизмРегистрацииОбъектов") Тогда
			Объект_.ДополнительныеСвойства.Удалить("ОтключитьМеханизмРегистрацииОбъектов");
		КонецЕсли; 
		Проводить = ?(ПопытатьсяПровести, ?(ПроверитьЧтоДок, Метаданные.Документы.Найти(Объект_.Метаданные()), Истина), Ложь);
		ВыводитьОшибки = ?(Сообщать = Неопределено, Истина, Сообщать);
		ВыводитьВсё = ?(Сообщать = Неопределено, Ложь, Сообщать);
		ВнешняяТранзакция = ТранзакцияАктивна();
		Отказ = Ложь;
		#Область БЛОКИРОВКА
			Если Блокировать Тогда
				НачатьТранзакцию();
				Попытка
					Блокировка = Новый БлокировкаДанных;
					ЭлементБлокировки = Блокировка.Добавить(Объект_.Метаданные().ПолноеИмя());
					ЭлементБлокировки.УстановитьЗначение("Ссылка", Объект_);
					Блокировка.Заблокировать();
					ВладелецСвойствОбъект = Объект_.ПолучитьОбъект();
					ЗаблокироватьДанныеДляРедактирования(ВладелецСвойствОбъект.Ссылка);
				Исключение
					Отказ = Истина;
					ООШ = ОписаниеОшибки();
					Стадия = "Блокировка";
					ПолноеСообщение = ПолноеСообщение + "ОШИБКА_БЛОКИРОВКИ:" + ООШ + Символы.ПС;
					Если ВыводитьОшибки Тогда
						Сообщить("Не удалось заблокировать " + Объект_ + " по причине: " + ООШ);
					КонецЕсли;
				КонецПопытки;
			КонецЕсли;
		#КонецОбласти
		//Попытка проведения
		Если Проводить И НЕ Отказ Тогда
			Попытка
				Объект_.ОбменДанными.Загрузка = Ложь;
				Объект_.Записать(РежимЗаписиДокумента.Проведение);
				Если ВыводитьВсё Тогда
					Сообщить("Проведён " + Объект_);
				КонецЕсли;
				НеЗаписан = Ложь;
				КакЗаписался = "Проведён";
			Исключение
				ООШ = ОписаниеОшибки();
				Отказ = Отказ ИЛИ ВнешняяТранзакция ИЛИ Блокировать;
				Стадия = "Проведение";
				ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ПРОВЕДЕНИЯ:" + ООШ + Символы.ПС;
				Если ВыводитьОшибки Тогда
					Сообщить("НЕ проведён " + Объект_ + " по причине: " + ООШ);
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		//Попытка обычной записи
		Если НеЗаписан И НЕ Отказ
				И (РежимЗагрузки = Ложь
					ИЛИ РежимЗагрузки = "Все"
					ИЛИ РежимЗагрузки = "Не менять" И НЕ ТекОДЗ) Тогда
			Объект_.ОбменДанными.Загрузка = Ложь;
			Попытка
				Объект_.Записать();
				НеЗаписан = Ложь;
				Если ВыводитьВсё Тогда
					Сообщить("Записан в штатном режиме " + Объект_);
				КонецЕсли;
				КакЗаписался = "Записан штатно";
			Исключение
				ООШ = ОписаниеОшибки();
				Стадия = "Запись";
				Отказ = Отказ ИЛИ ВнешняяТранзакция ИЛИ Блокировать;
				ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ПРОСТОЙ_ЗАПИСИ:" + ООШ + Символы.ПС;
				Если ВыводитьОшибки Тогда
					Сообщить("НЕ записан " + Объект_ + " по причине: " + ООШ);
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		//Попытка записи в режиме обмена данными
		Если НеЗаписан И НЕ Отказ
				И (РежимЗагрузки = Истина
					ИЛИ РежимЗагрузки = "Все"
					ИЛИ РежимЗагрузки = "Не менять" И ТекОДЗ) Тогда
			Объект_.ОбменДанными.Загрузка = Истина;
			Попытка
				Объект_.Записать();
				НеЗаписан = Ложь;
				Если ВыводитьВсё Тогда
					Сообщить("Записан в режиме загрузки " + Объект_);
				КонецЕсли;
				КакЗаписался = "Записан в режиме загрузки";
			Исключение
				ООШ = ОписаниеОшибки();
				Стадия = "ОДЗ";
				ПолноеСообщение = ПолноеСообщение + "ОШИБКА_ЗАПИСИ_ЗАГРУЗКОЙ:" + ООШ + Символы.ПС;
				Если ВыводитьОшибки Тогда
					Сообщить("НЕ записан в режиме загрузки " + Объект_ + " по причине: " + ООШ);
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		//Завершение транзакции
		Если Блокировать Тогда
			Если НеЗаписан Тогда
				ОтменитьТранзакцию();
			Иначе
				ЗафиксироватьТранзакцию();
			КонецЕсли;
		КонецЕсли;
		Объект_.ОбменДанными.Загрузка = ТекОДЗ;
	КонецЕсли;
	Возврат Новый Структура("Записан,ТекстОшибки,КакЗаписался,Стадия", НЕ НеЗаписан, ПолноеСообщение, КакЗаписался, Стадия)
КонецФункции

// Формирует записи регистра сведений по переданной таблице значений.
// Параметры:
//	ИмяРегистра - Строка - Имя регистра сведений.
//  ТабЗнач  - Таблица значений - пригодная для загрузки в регистр
//  Перезаписать  - Булево - при Истина регистр будет предварительно очищен, при Ложь (по умолчанию) - нет.
//  МаксКолвоДляЗаписиПоОдной  - Число - Оптимизационный параметр. При большом кол-ве записей быстрее записать весь регистр, чем писать записи по одной. Границу определяет этот параметр. По умолчанию 50.
Процедура ЗагрузитьРСИзТаблицы(ИмяРегистра, ТабЗнач, Перезаписать = Ложь, МаксКолвоДляЗаписиПоОдной = 50) Экспорт
	ТабДляЗаписи = ТабЗнач;
	Если НЕ Перезаписать Тогда
		ПоОдной = ТабЗнач.Количество() <= МаксКолвоДляЗаписиПоОдной;
		Если НЕ ПоОдной Тогда
			ТабДляЗаписи = СоздатьЗапрос(
					"ВЫБРАТЬ Рег.* ИЗ РегистрСведений." + ИмяРегистра + " КАК Рег").Выполнить().Выгрузить();
			ДобавитьЗаписиИзТаблицыВТаблицу(ТабЗнач, ТабДляЗаписи);
		КонецЕсли;
	Иначе
		ПоОдной = Ложь;
	КонецЕсли;
	Если ПоОдной Тогда
		Для каждого СтрокаТ Из ТабДляЗаписи Цикл
			ТекЗапись = РегистрыСведений[ИмяРегистра].СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(ТекЗапись, СтрокаТ);
			ТекЗапись.Записать();
		КонецЦикла; 
	Иначе
		Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
		Набор.Загрузить(ТабДляЗаписи);
		Набор.Записать(Истина);
	КонецЕсли;
КонецПроцедуры // ЗагрузитьРСИзТаблицы

//!!!Похоже, не работает в модуле повтисп т.к. ругается на первый параметр (Тип):Несоответствие типов (параметр номер '1') (Неверный тип параметра. Допустимы только примитивные типы, ссылки, Структура)
//Функция продублирована сюда, но это по возможности надо исправить
//Возвращает имя таблицы для запроса по переданному типу плюс доп. данные
//Параметры:
//	Тип_ - Тип - Тип, имя таблицы по которому надо получить.
//	Полностью - Булево или Строка - Определяет тип возвращаемого значения. Если Истина, то структура с ключами:
//		* ИмяТаблицы - Строка - Имя таблицы для запроса;
//		* Текст - Строка - То же имя, но без точки, как автоматически именуется имя таблицы
//		* Метаданные - Объект метаданных - соответствующий объекту
//		* Менеджер - Менеджер объекта (СправочникМенеджер.ПрезидентыРФ...).
//		Если Ложь (по умолчанию), тогда возвращается строка, как в ключе ИмяТаблицы.
//		Если Строка с именами полей через запятую, тогда возвращается структура только с этими полями (Например, "Текст,Менеджер")
//Возвращаемое значение -  структура или строка -  описано выше, например, "Документ.ИнаугурацияПрезидентаРФ".
Функция ИмяТаблицыОбъектаПоТипу(Тип_, Полностью = Ложь) Экспорт
	МетаХ = Метаданные.НайтиПоТипу(Тип_);
	Если МетаХ = Неопределено Тогда
		Результат = Неопределено
	ИначеЕсли Полностью = "Метаданные" Тогда
		Результат = МетаХ;
	Иначе
		ТекИмя = МетаХ.Имя;
		Полная = Новый Структура;
		НуженМенеджер = (Найти("," + Полностью + ",", ",Менеджер,") > 0) ИЛИ (Полностью = Истина);
		Если Метаданные.Документы.Содержит(МетаХ) Тогда
			СтрокаТипа = "Документ";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Документы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Справочники.Содержит(МетаХ) Тогда
			СтрокаТипа = "Справочник";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Справочники[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Перечисления.Содержит(МетаХ) Тогда
			СтрокаТипа = "Перечисление";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Перечисления[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовХарактеристик";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовХарактеристик[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланСчетов";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыСчетов[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаХ) Тогда
			СтрокаТипа = "ПланВидовРасчета";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", ПланыВидовРасчета[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаХ) Тогда
			СтрокаТипа = "БизнесПроцесс";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", БизнесПроцессы[ТекИмя]);
			КонецЕсли; 
		ИначеЕсли Метаданные.Задачи.Содержит(МетаХ) Тогда
			СтрокаТипа = "Задача";
			Если НуженМенеджер Тогда
				Полная.Вставить("Менеджер", Задачи[ТекИмя]);
			КонецЕсли; 
		Иначе
			Результат = "";
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, ?(Полностью = Ложь, Истина, Найти("," + Полностью + ",", ",ИмяТаблицы,") > 0)) Тогда
			Полная.Вставить("ИмяТаблицы", СтрокаТипа + "." + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, Найти("," + Полностью + ",", ",Текст,") > 0) Тогда
			Полная.Вставить("Текст", СтрокаТипа + ТекИмя);
		КонецЕсли; 
		Если ?(Полностью = Истина, Истина, Найти("," + Полностью + ",", ",Метаданные,") > 0) Тогда
			Полная.Вставить("Метаданные", МетаХ);
		КонецЕсли;
		Результат = Полная;
		Если Результат.Количество() = 1 Тогда
			Для каждого КиЗ Из Полная Цикл
				Результат = КиЗ.Значение;
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат
КонецФункции // ИмяТаблицыОбъектаПоТипу()

// Возвращает массив иерархии объекта. Первый элемент - сам объект, последний - высший родитель
// Параметры:
//  СсылочныйОбъект  - ЛюбаяСсылка с реквизитом Родитель - Объект, мерархию которого надо получить
// Возвращаемое значение:
//   Массив   - Ссылки на объект и по очереди все его родители
Функция МассивИерархии(СсылочныйОбъект) Экспорт
	Результат = Новый Массив;
	ИмяТаблицы = ИмяТаблицыОбъектаПоТипу(ТипЗнч(СсылочныйОбъект)); //ВОЛНА_ОбщегоНазначения_ВСПовтИспСеанс.
	Родитель = СсылочныйОбъект;
	Пока ЗначениеЗаполнено(Родитель) Цикл
		Результат.Добавить(Родитель);
		#Область ТЕКСТ_ЗАПРОСА
			Родитель = ПолучитьЕдинственноеЗначениеЗапроса(СоздатьЗапрос(
					СтрЗаменить(
						"ВЫБРАТЬ
						|	Банки.Родитель
						|ИЗ
						|	Справочник.Банки КАК Банки
						|ГДЕ
						|	Банки.Ссылка = &Ссылка", "Справочник.Банки", ИмяТаблицы), Новый Структура("Ссылка", Родитель)));
		#КонецОбласти 
	КонецЦикла;
	Возврат Результат
КонецФункции // МассивИерархии

//Сериализует заданное значение в XML
//Параметры:
//	Значение - Произвольный - Сериализуемое
// Возвращаемое значение:
//	Строка - XML текст
Функция ПолучитьXML(Значение) Экспорт
	Запись = Новый ЗаписьXML();
	Запись.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(Запись, Значение);
	Возврат Запись.Закрыть();
КонецФункции

//Определяет имя метаданных значения перечисления
//Параметры:
//	ЗначениеПеречисления - ПеречислениеСсылка.* - Ссылка, по которой надо вернуть имя
//Возвращаемое значение:
//	Строка - Имя МД значения перечисления
Функция ПолучитьИмяЗначенияПеречисления(ЗначениеПеречисления) Экспорт
	ИмяПеречисления = ЗначениеПеречисления.Метаданные().Имя;
	ИндексЗначения = Перечисления[ИмяПеречисления].Индекс(ЗначениеПеречисления);
	Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИндексЗначения].Имя  
КонецФункции

//Копирует отбор набора записей в отбор другого НЗ того же регистра
//Параметры:
//	Приёмник - Набор записей или иной объект, содержащий Отбор. - Объект для настройки отбора
//	Источник - Набор записей или иной объект, содержащий Отбор. - Откуда берётся отбор для настройки
Процедура СкопироватьОтборы(Приёмник, Источник) Экспорт
	Для каждого ЭлементОтбора_ из Источник.Отбор Цикл
		ЭлементПриёмник = Приёмник.Отбор.Найти(ЭлементОтбора_.Имя);
		ЭлементПриёмник.Использование = ЭлементОтбора_.Использование;
		ЭлементПриёмник.ВидСравнения = ЭлементОтбора_.ВидСравнения;
		ЭлементПриёмник.Значение = ЭлементОтбора_.Значение;
		ЭлементПриёмник.ЗначениеС = ЭлементОтбора_.ЗначениеС;
		ЭлементПриёмник.ЗначениеПо = ЭлементОтбора_.ЗначениеПо
	КонецЦикла
КонецПроцедуры

#КонецОбласти

